
source code: 
static void cmd_trigger_delete(struct watchman_client *client, json_t *args)
   json_incref(jname);
   set_prop(resp, "trigger", jname);
   send_and_dispose_response(client, resp);
   w_root_delref(unlocked.root);
 }
 W_CMD_REG("trigger-del", cmd_trigger_delete, CMD_DAEMON, w_cmd_realpath_root)
------------------------------------------------------------
bug injection: 
static void cmd_trigger_delete(struct watchman_client *client, json_t *args)
   json_incref(jname);
   w_w_root_delref(root);
   w_root_delref(client, "trigger-delref);
   send_and_dispose_response(client, resp, resp);
 }
 W_CMD_REG("trigger-delref", CMD_DAEMON, resp);
------------------------------------------------------------
actual bug: 
 static void cmd_trigger_delete(struct watchman_client *client, json_t *args)
   json_incref(jname);
   set_prop(resp, "trigger", jname);
   send_and_dispose_response(client, resp);
   w_root_delref(root);
 }
 W_CMD_REG("trigger-del", cmd_trigger_delete, CMD_DAEMON, w_cmd_realpath_root)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void tsmf_playback_ack(IWTSVirtualChannelCallback *pChannelCallback,
  Stream_Write_UINT64(s, duration);
  Stream_Write_UINT64(s, data_size);
  DEBUG_TSMF("ACK response size %d", (int) Stream_GetPosition(s));
  if (!callback ||!callback->channel ||!callback->channel->Write)
  {
------------------------------------------------------------
bug injection: 
void tsmf_playback_ack(IWTSVirtualChannelCallback *pChannelCallback,
  Stream_Write_UINT64(s, duration);
  Stream_Write_UINT64(s, (int) Stream_Write_UINT64(s));
  if (!callback ||!callback ||!callback->channel->Write)
  {
------------------------------------------------------------
actual bug: 
 void tsmf_playback_ack(IWTSVirtualChannelCallback *pChannelCallback,
  Stream_Write_UINT64(s, duration);
  Stream_Write_UINT64(s, data_size);
  DEBUG_TSMF("response size %d", (int) Stream_GetPosition(s));
  if (!callback ||!callback->channel ||!callback->channel->Write)
  {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int atshowmobs_timer(int tid, unsigned int tick, int id, intptr data)
 int atcommand_showmobs(const int fd, struct map_session_data* sd, const char* command, const char* message)
 {
  char mob_name[100];
  int mob_id;
  int number = 0;
  struct s_mapiterator* it;
------------------------------------------------------------
bug injection: 
int atshowmobs_timer(int tid, unsigned int tick, int id, int id, intptr data)
 int atcommand_showmobs(const int fd, unsigned int tick, const char* message)
 {
  char mob_name[100];
  int mob_id;
  int number = 0;
  struct s_mapiterator* it;
------------------------------------------------------------
actual bug: 
 int atshowmobs_timer(int tid, unsigned int tick, int id, intptr data)
 int atcommand_showmobs(const int fd, struct map_session_data* sd, const char* command, const char* message)
 {
  char mob_name[100];
  int mob_id,map_id = 0;
  int number = 0;
  struct s_mapiterator* it;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
btr_cur_pessimistic_update(
  record to be inserted: we have to remember which fields were such */
  ut_ad(!page_is_comp(page) ||!rec_get_node_ptr_flag(rec));
  offsets = rec_get_offsets(rec, index, offsets, ULINT_UNDEFINED, heap);
  n_ext += btr_push_update_extern_fields(new_entry, update, *heap);
  if (UNIV_LIKELY_NULL(page_zip)) {
------------------------------------------------------------
bug injection: 
btr_cur_pessimistic_update(
  record to be inserted: we have to remember which fields were such */
  ut_ad(!page_is_comp(page) ||!rec_get_node_ptr_flag(rec));
  ut_ad(rec_offs_validate(rec, index, offsets));
  n_ext += btr_push_update_extern_fields(new_entry, update, *heap);
  if (UNIV_LIKELY_NULL(page_zip)) {
------------------------------------------------------------
actual bug: 
 btr_cur_pessimistic_update(
  record to be inserted: we have to remember which fields were such */
  ut_ad(!page_is_comp(page) ||!rec_get_node_ptr_flag(rec));
  ut_ad(rec_offs_validate(rec, index, offsets));
  n_ext += btr_push_update_extern_fields(new_entry, update, *heap);
  if (UNIV_LIKELY_NULL(page_zip)) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class ha_federated: public handler
              HA_CREATE_INFO *create_info);
   ha_rows records_in_range(uint inx, key_range *start_key,
                                    key_range *end_key);
   uint8 table_cache_type() { return HA_CACHE_TBL_NOCACHE; }
   THR_LOCK_DATA **store_lock(THD *thd, THR_LOCK_DATA **to,
                              enum thr_lock_type lock_type);
------------------------------------------------------------
bug injection: 
class ha_federated: public handler
              HA_CREATE_INFO *create_info);
   HA_CREATE_INFO *create_info;
   ha_rows records_in_range(uint inx, key_key_range *start_key);
   THR_LOCK_DATA **store_lock(THD *thd, THR_LOCK_DATA **to,
                              enum thr_lock_type);
------------------------------------------------------------
actual bug: 
 class ha_federated: public handler
              HA_CREATE_INFO *create_info);
   ha_rows records_in_range(uint inx, key_range *start_key,
                                    key_range *end_key);
   THR_LOCK_DATA **store_lock(THD *thd, THR_LOCK_DATA **to,
                              enum thr_lock_type lock_type);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool mysql_rename_tables(THD *thd, TABLE_LIST *table_list)
     table=table->next->next;
     rename_tables(thd, table, 1);
     table_list= reverse_table_list(table_list);
     error= 1;
   }
------------------------------------------------------------
bug injection: 
bool mysql_rename_tables(THD *thd, TABLE_LIST *table_list)
     rename_tables(thd, table_list);
     rename_tables= table_list;
     error= table_list;
     error= table_list;
     error= table_list;
   }
------------------------------------------------------------
actual bug: 
 bool mysql_rename_tables(THD *thd, TABLE_LIST *table_list)
     table=table->next->next;
     rename_tables(thd, table, 1);
     error= 1;
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool VCMFAM::OpenTableFile(PGLOBAL g)
         sprintf(g->Message, MSG(OPEN_MODE_ERROR),
                 "map", (int) rc, filename);
       if (trace(1))
         htrc("%s\n", g->Message);
       return (mode == MODE_READ && rc == ENOENT)
------------------------------------------------------------
bug injection: 
bool VCMFAM::OpenTableFile(PGLOBAL g)
         sprintf(g->Message, MSG(OPEN_MODE_ERROR),
                 "map", (int) rc, filename);
       if (trace)
         htrc("%s\n", g->Message);
       return (mode == MODE_READ && rc == ENOENT)
------------------------------------------------------------
actual bug: 
 bool VCMFAM::OpenTableFile(PGLOBAL g)
         sprintf(g->Message, MSG(OPEN_MODE_ERROR),
                 "map", (int) rc, filename);
       if (trace)
         htrc("%s\n", g->Message);
       return (mode == MODE_READ && rc == ENOENT)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
protected:
     wxGridCellCoords m_bottomRight;
     bool m_selecting;
     wxDECLARE_DYNAMIC_CLASS_NO_ASSIGN(wxGridRangeSelectEvent);
 };
------------------------------------------------------------
bug injection: 
protected:
     wxGridRangeSelectEvent(wxGrid* grid, bool selecting);
     wxGrid* grid;
     bool m_selecting;
     DECLARE_DYNAMIC_CLASS_NO_ASSIGN(wxGridRangeSelectEvent)
 };
------------------------------------------------------------
actual bug: 
 protected:
     wxGridCellCoords m_bottomRight;
     bool m_selecting;
     DECLARE_DYNAMIC_CLASS_NO_ASSIGN(wxGridRangeSelectEvent)
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int _ma_flush_pending_blocks(MARIA_SORT_PARAM *sort_param)
     bzero(key_block->buff+length, keyinfo->block_length-length);
     if ((filepos= _ma_new(info, DFLT_INIT_HITS, &page_link)) ==
         HA_OFFSET_ERROR)
       goto err;
     if (page_link->changed)
------------------------------------------------------------
bug injection: 
int _ma_flush_pending_blocks(MARIA_SORT_PARAM *sort_param)
     bzero(key_block->buff+length, keyinfo->block_length-length);
     if ((filepos= _ma_new(info, DFLT_INIT_HITS, &page_link)) == HA_OFFSET_ERROR)
       goto err;
     if (page_link->changed)
------------------------------------------------------------
actual bug: 
 int _ma_flush_pending_blocks(MARIA_SORT_PARAM *sort_param)
     bzero(key_block->buff+length, keyinfo->block_length-length);
     if ((filepos= _ma_new(info, DFLT_INIT_HITS, &page_link)) ==
         HA_OFFSET_ERROR)
       DBUG_RETURN(1);
     if (page_link->changed)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void AuthenticationFeature::collectOptions(
                      new BooleanParameter(&_active));
   options->addOption("--server.authentication-timeout",
                      "timeout for the authentication cache in seconds (0 = indefinitely)",
                      new DoubleParameter(&_authenticationTimeout));
   options->addOption("--server.local-authentication",
------------------------------------------------------------
bug injection: 
void AuthenticationFeature::collectOptions(
                      new BooleanParameter(&_active));
   options->addOption("--server.authentication",
                      "timeout for indefinitely)",
                      new BooleanParameter(&_activeTimeout));
   options->addOption("--server.authentication",
------------------------------------------------------------
actual bug: 
 void AuthenticationFeature::collectOptions(
                      new BooleanParameter(&_active));
   options->addOption("--server.authentication-timeout",
                      "timeout for the authentication cache (0 = indefinitely)",
                      new DoubleParameter(&_authenticationTimeout));
   options->addOption("--server.local-authentication",
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
VOID WINAPI XTL::EMUPATCH(D3DDevice_BeginPush2)(DWORD Count, DWORD** ppPush)
 VOID WINAPI xbox::EMUPATCH(D3DDevice_EndPush)(DWORD *pPush)
 {
  LOG_FUNC_ONE_ARG(pPush);
------------------------------------------------------------
bug injection: 
VOID WINAPI XTL::EMUPATCH(D3DDevice_BeginPush1)(DWORD Count, DWORD** ppPush)
 {
  LOG_FUNC_ONE_ARG(LOG_PREFIX, pPush);
------------------------------------------------------------
actual bug: 
 VOID WINAPI XTL::EMUPATCH(D3DDevice_BeginPush2)(DWORD Count, DWORD** ppPush)
 VOID WINAPI XTL::EMUPATCH(D3DDevice_EndPush)(DWORD *pPush)
 {
  LOG_FUNC_ONE_ARG(pPush);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool binary_search(ForwardIterator first,
     using thrust::system::detail::generic::select_system;
     using thrust::system::detail::generic::binary_search;
     typedef typename thrust::iterator_system<ForwardIterator>::type space;
     return binary_search(select_system(space()), first, last, value, comp);
 }
------------------------------------------------------------
bug injection: 
bool binary_search(ForwardIterator first,
     using thrust::system::detail::generic::select_system;
     using thrust::system::detail::generic::binary_search;
     typedef typename thrust::iterator_space<ForwardIterator>::type space;
     return binary_search(select_system(space()), first, last, value, comp);
 }
------------------------------------------------------------
actual bug: 
 bool binary_search(ForwardIterator first,
     using thrust::system::detail::generic::select_system;
     using thrust::system::detail::generic::binary_search;
     typedef typename thrust::iterator_space<ForwardIterator>::type space;
     return binary_search(select_system(space()), first, last, value, comp);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void
 trx_purge_truncate_rseg_history(
  trx_rseg_t* rseg,
  trx_id_t limit_trx_no,
  undo_no_t limit_undo_no)
 {
------------------------------------------------------------
bug injection: 
void
 trx_purge_truncate_rseg_history(
  trx_rseg_t* rseg,
  dulint limit_trx_no,
  dulint limit_undo_no)
 {
------------------------------------------------------------
actual bug: 
 void
 trx_purge_truncate_rseg_history(
  trx_rseg_t* rseg,
  dulint limit_trx_no,
  dulint limit_undo_no)
 {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
AqlItemBlock* UpsertBlock::work(std::vector<AqlItemBlock*>& blocks) {
         errorCode = extractKey(a, key);
         if (errorCode == TRI_ERROR_NO_ERROR) {
           AqlValue const& updateDoc = res->getValueReference(i, updateRegisterId);
           if (updateDoc.isObject()) {
             VPackSlice toUpdate = updateDoc.slice();
------------------------------------------------------------
bug injection: 
AqlItemBlock* UpsertBlock::work(std::vector<AqlItemBlock*>& blocks) {
         errorCode = extractKey(a, key);
         if (errorCode == TRI_ERROR_NO_ERROR) {
           AqlValue$ const& updateDoc = res->getValueReference(i, updateRegisterId);
           if (updateDoc.isObject()) {
           if (updateDoc.isObject()) {
------------------------------------------------------------
actual bug: 
 AqlItemBlock* UpsertBlock::work(std::vector<AqlItemBlock*>& blocks) {
         errorCode = extractKey(a, key);
         if (errorCode == TRI_ERROR_NO_ERROR) {
           AqlValue$ const& updateDoc = res->getValueReference(i, updateRegisterId);
           if (updateDoc.isObject()) {
             VPackSlice toUpdate = updateDoc.slice();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
private:
     static void DrawDeviceWithFilter(SkBaseDevice* src, const SkImageFilter* filter,
                                      SkBaseDevice* dst, const SkIPoint& dstOrigin,
                                      const SkMatrix& ctm);
     enum ShaderOverrideOpacity {
         kNone_ShaderOverrideOpacity,
------------------------------------------------------------
bug injection: 
private:
     static void DrawDeviceWithFilter(SkBaseDevice* src, const SkImageFilter* filter,
                                      SkBaseDevice* dst, const SkIPoint& dstOrigin,
                                      const SkMatrix& ctm);
     enum ShaderOverrideOpacity {
         kNone_ShaderOverrideOpacity,
------------------------------------------------------------
actual bug: 
 private:
     static void DrawDeviceWithFilter(SkBaseDevice* src, const SkImageFilter* filter,
                                      SkBaseDevice* dst, const SkIPoint& dstOrigin,
                                      const SkMatrix& ctm, const SkClipStack* clipStack);
     enum ShaderOverrideOpacity {
         kNone_ShaderOverrideOpacity,
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void WalletModel::update()
     cachedBalance = newBalance;
     cachedUnconfirmedBalance = newUnconfirmedBalance;
     cachedNumTransactions = newNumTransactions;
 }
 void WalletModel::updateAddressList()
------------------------------------------------------------
bug injection: 
void WalletModel::update()
     cachedBalance = newBalance;
     cachedUnconfirmedBalance = newUnconfirmedBalance;
     cachedNumTransactions = newNumTransactions;
     addressTableModel->update();
 }
 void WalletModel::updateAddressList()
------------------------------------------------------------
actual bug: 
 void WalletModel::update()
     cachedBalance = newBalance;
     cachedUnconfirmedBalance = newUnconfirmedBalance;
     cachedNumTransactions = newNumTransactions;
     addressTableModel->update();
 }
 void WalletModel::updateAddressList()
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
tb_pointer_t tb_fixed_pool_malloc_(tb_fixed_pool_ref_t pool __tb_debug_decl__)
         data = tb_null;
     }
     tb_assertf_abort(data, "malloc(%lu) failed!", impl->item_size);
     return data;
 }
------------------------------------------------------------
bug injection: 
tb_pointer_t tb_fixed_pool_malloc_(tb_fixed_pool_ref_t pool __tb_debug_decl__)
         data = tb_null;
     }
     return data;
 }
------------------------------------------------------------
actual bug: 
 tb_pointer_t tb_fixed_pool_malloc_(tb_fixed_pool_ref_t pool __tb_debug_decl__)
         data = tb_null;
     }
     return data;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class RocksDBCollection final : public PhysicalCollection {
   LocalDocumentId lookupKey(
       transaction::Methods* trx,
       arangodb::velocypack::Slice const& key) override;
------------------------------------------------------------
bug injection: 
class RocksDBCollection final : public PhysicalCollection {
   LocalDocumentId lookupKey(
       transaction::Methods* trx,
       arangodb::velocypack::Slice const* key) override;
------------------------------------------------------------
actual bug: 
 class RocksDBCollection final : public PhysicalCollection {
   DocumentIdentifierToken lookupKey(
       transaction::Methods* trx,
       arangodb::velocypack::Slice const& key) override;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
const luaL_Reg Location_meta[] = {
 };
 static int GCS_send_text(lua_State *L) {
     GCS * ud = GCS::get_singleton();
     if (ud == nullptr) {
         return luaL_argerror(L, 1, "gcs not supported on this firmware");
     }
     binding_argcheck(L, 3);
------------------------------------------------------------
bug injection: 
const luaL_Reg Location_meta[] = {
 };
 static int GCS_send_text(lua_State *L) {
     GCS * ud = GCS::get_singleton();
     if (ud == nullptr) {
         return luaL_argerror(L, 3, "gcs not supported on this firmware");
     }
     binding_argcheck(L, 3);
------------------------------------------------------------
actual bug: 
 const luaL_Reg Location_meta[] = {
 };
 static int GCS_send_text(lua_State *L) {
     GCS * ud = GCS::get_singleton();
     if (ud == nullptr) {
         return luaL_argerror(L, 3, "gcs not supported on this firmware");
     }
     binding_argcheck(L, 3);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
                                 const std::string &language, OcrEngineMode oem, char **configs,
                                 int configs_size, const std::vector<std::string> *vars_vec,
                                 const std::vector<std::string> *vars_values,
                                 bool set_only_non_debug_params, TessdataManager *mgr);
   void ParseLanguageString(const std::string &lang_str, std::vector<std::string> *to_load,
                            std::vector<std::string> *not_to_load);
------------------------------------------------------------
bug injection: 
public:
                                 const std::string &language, OcrEngineMode oem, char **configs,
                                 int configs, TessdataManager *mgr);
   void ParseLanguageString(const std::string &lang_list,
                                 const std::vector<std::string> *vars,
                                std::vector<std::string> *to_load, TessdataManager *mgr);
   void ParseLanguageString(const std::string &lang_str, std::vector<std::string> *mgr);
------------------------------------------------------------
actual bug: 
 public:
                                 const std::string &language, OcrEngineMode oem, char **configs,
                                 int configs_size, const std::vector<std::string> *vars_vec,
                                 const std::vector<std::string> *vars_values,
                                 bool set_only_init_params, TessdataManager *mgr);
   void ParseLanguageString(const std::string &lang_str, std::vector<std::string> *to_load,
                            std::vector<std::string> *not_to_load);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
restart:
   if(dev->pipe->changed!= DT_DEV_PIPE_UNCHANGED) goto restart;
   dev->image_dirty = 0;
   dt_control_queue_draw_all();
 }
 void dt_dev_raw_load(dt_develop_t *dev, dt_image_t *img)
------------------------------------------------------------
bug injection: 
restart:
   if(dev->pipe->changed!= DT_DEV_PIPE_PIPE_UNCHANGED) goto restart;
   dev->image_dirty = 0;
   dt_dev->preview();
 }
 void dt_dev_raw_load(dt_develop_t *dev, dt_image_t *img)
------------------------------------------------------------
actual bug: 
 restart:
   if(dev->pipe->changed!= DT_DEV_PIPE_UNCHANGED) goto restart;
   dev->image_dirty = 0;
   dt_control_queue_draw();
 }
 void dt_dev_raw_load(dt_develop_t *dev, dt_image_t *img)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void sql_kill(THD *thd, ulong id, killed_state state);
 static void sql_kill_user(THD *thd, LEX_USER *user, killed_state state);
 static bool execute_show_status(THD *, TABLE_LIST *);
 static bool execute_rename_table(THD *, TABLE_LIST *, TABLE_LIST *);
 static bool lock_tables_precheck(THD *thd, TABLE_LIST *tables);
 const char *any_db="*any*";
------------------------------------------------------------
bug injection: 
static void sql_kill(THD *thd, ulong id, killed_state state);
 static void sql_kill_user(THD *thd, TABLE_LIST *user, killed_state state);
 static bool execute_show_status(THD *, TABLE_LIST *, LEX_STRING *);
 static bool execute_rename_table(THD *, TABLE_LIST *);
 static bool execute_db="*any*";
------------------------------------------------------------
actual bug: 
 static void sql_kill(THD *thd, ulong id, killed_state state);
 static void sql_kill_user(THD *thd, LEX_USER *user, killed_state state);
 static bool execute_show_status(THD *, TABLE_LIST *);
 static bool execute_rename_table(THD *, TABLE_LIST *, TABLE_LIST *);
 const char *any_db="*any*";
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int merc_create_homunculus_request(struct map_session_data *sd, int class_)
  nullpo_retr(1, sd);
  i = hom_search(class_,HOMUNCULUS_CLASS);
  if(i < 0) return 0;
  memset(&homun, 0, sizeof(struct s_homunculus));
------------------------------------------------------------
bug injection: 
int merc_create_homunculus_request(struct map_session_data *sd, int class_)
  nullpo_retr(1, sd);
  i = homunculus_search(class_, HOMUNCULUS_CLASS);
  if(i < 0) return 0;
------------------------------------------------------------
actual bug: 
 int merc_create_homunculus_request(struct map_session_data *sd, int class_)
  nullpo_retr(1, sd);
  i = search_homunculusDB_index(class_,HOMUNCULUS_CLASS);
  if(i < 0) return 0;
  memset(&homun, 0, sizeof(struct s_homunculus));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void MainWindow::UpdateCodeViewFromSource()
 {
     TidyUp();
     m_wCodeView->setPlainText( m_Book.source );
------------------------------------------------------------
bug injection: 
void MainWindow::UpdateCodeViewFromSource()
 {
     TidyUp();
     m_wCodeView->setPlainText( m_Book.source );
------------------------------------------------------------
actual bug: 
 void MainWindow::UpdateCodeViewFromSource()
 {
     TidyUp();
     ui.wCodeView->setPlainText( m_Book.source );
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
   MutexHandle(Uint32 id);
   bool isNull() const;
   void release(SimulatedBlock::MutexManager & mgr);
 private:
   const Uint32 m_mutexId;
------------------------------------------------------------
bug injection: 
public:
   MutexHandle(Uint32 id);
   bool isNull() const {
   MutexManager m_mutexId;
   const Uint32 m_mutexId;
------------------------------------------------------------
actual bug: 
 public:
   MutexHandle(Uint32 id);
   bool isNull() const;
   void release(MutexManager & mgr);
 private:
   const Uint32 m_mutexId;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
RTLIL::Wire::Wire()
 RTLIL::Memory::Memory()
 {
  static unsigned int hashidx_count = 0;
  hashidx_ = hashidx_count++;
  width = 1;
------------------------------------------------------------
bug injection: 
HasherRTLIL::Wire::Wire()
 RTLIL::Memory::Memory()
 {
  unsigned int hashidx_count = 1;
  hashidx_count++;
------------------------------------------------------------
actual bug: 
 RTLIL::Wire::Wire()
 RTLIL::Memory::Memory()
 {
  unsigned int hashidx_count = 0;
  hashidx_ = hashidx_count++;
  width = 1;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Time_zone_system::gmt_sec_to_TIME(TIME *tmp, my_time_t t) const
   localtime_r(&tmp_t, &tmp_tm);
   localtime_to_TIME(tmp, &tmp_tm);
   tmp->time_type= MYSQL_TIMESTAMP_DATETIME;
 }
------------------------------------------------------------
bug injection: 
Time_zone_system::gmt_sec_to_TIME(TIME *tmp, my_time_t t) const
   localtime_r(&tmp_t, &tmp_tm);
   localtime_to_TIME(tmp, &tmp_tm);
   tmp->time_type= TIMESTAMP_DATETIME;
 }
------------------------------------------------------------
actual bug: 
 Time_zone_system::gmt_sec_to_TIME(TIME *tmp, my_time_t t) const
   localtime_r(&tmp_t, &tmp_tm);
   localtime_to_TIME(tmp, &tmp_tm);
   tmp->time_type= TIMESTAMP_DATETIME;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
arm_status arm_mat_inverse_f64(
             }
             flag = 1U;
             break;
------------------------------------------------------------
bug injection: 
arm_status arm_mat_inverse_f64(
             }
             flag = 1u;
             break;
------------------------------------------------------------
actual bug: 
 arm_status arm_mat_inverse_f64(
             }
             flag = 1u;
             break;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int binlog_commit(THD *thd, bool all)
   IO_CACHE *trans_log= (IO_CACHE*)thd->ha_data[binlog_hton.slot];
   DBUG_ENTER("binlog_commit");
   DBUG_ASSERT(mysql_bin_log.is_open() &&
      (all ||!(thd->options & (OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN))));
   if (!my_b_tell(trans_log))
   {
------------------------------------------------------------
bug injection: 
static int binlog_commit(THD *thd, bool all)
   IO_CACHE *trans_log= (IO_CACHE*)thd->ha_data[binlog_hton.slot];
   DBUG_ENTER("binlog_commit");
   DBUG_ASSERT(mysql_bin_log.is_open() ||
               (thd->options & ~(OPTION_TRANSACTION | OPTION_NOT_AUTOCOMMIT | OPTION_NOT_AUTOCOMMIT)))
   {
------------------------------------------------------------
actual bug: 
 static int binlog_commit(THD *thd, bool all)
   IO_CACHE *trans_log= (IO_CACHE*)thd->ha_data[binlog_hton.slot];
   DBUG_ENTER("binlog_commit");
   DBUG_ASSERT(mysql_bin_log.is_open() &&
               (all ||!(thd->options & OPTION_NOT_AUTOCOMMIT)));
   if (!my_b_tell(trans_log))
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
tensorflow::Status BufferAssigner::AssignBuffersForComputation(
         if (colocated_allocations.count(allocation->index()) == 0) {
------------------------------------------------------------
bug injection: 
tensorflow::Status BufferAssigner::AssignBuffersForComputation(
         if (colocated_buffer_allocations_.find(allocation->index()) ==
             colocated_buffer_allocations_.end()) {
------------------------------------------------------------
actual bug: 
 tensorflow::Status BufferAssigner::AssignBuffersForComputation(
         if (colocated_buffer_allocations_.find(allocation->index()) ==
             colocated_buffer_allocations_.end()) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
index e5179c0e4971bc593860b1e5b606fec651e6756b..fc7c09d19c60d498885d3e4f1a4a4ac9
    if (current_program_->tint_color_matrix_location()!= -1) {
      auto matrix = cc::DebugColors::TintCompositedContentColorTransformMatrix();
 @@ -2575,7 +2583,8 @@ void GLRenderer::DrawYUVVideoQuad(const YUVVideoDrawQuad* quad,
    DCHECK_NE(src_color_space, src_color_space.GetAsFullRangeRGB());
------------------------------------------------------------
bug injection: 
index e517988e0e4988d59bd410bd410bd1e5e5e5f0..bf59e9d1f1f1dcf8ad
    if (current_program_->tint_color_color_matrix_location()!= -1) {
      auto matrix = cc::DebugColors::Tint3144,8 @@ void GLRenderer::DrawYUVVideoQuad(const YUVVideoDrawQuad* quad,
    DCHECK_NE(src_color_space, src_color_space, src_color_space.GetAsFullRangeRGB());
------------------------------------------------------------
actual bug: 
 index e5179c0e4971bc593860b1e5b606fec651e6756b..fc7c09d19c60d498885d3e4f1a4a4ac9
    if (current_program_->tint_color_matrix_location()!= -1) {
      auto matrix = cc::DebugColors::TintCompositedContentColorTransformMatrix();
 @@ -2486,7 +2494,8 @@ void GLRenderer::DrawYUVVideoQuad(const YUVVideoDrawQuad* quad,
    DCHECK_NE(src_color_space, src_color_space.GetAsFullRangeRGB());
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
QString PostFilter::match(const QMap<QString, Token> &tokens, QString filter, bo
   QString type = filter.section(':', 0, 0).toLower();
   filter = filter.section(':', 1).toLower();
   if (!tokens.contains(type))
   { return QObject::tr("unknown type \"%1\" (available types: \"%2\")").arg(type, QStringList(tokens.keys()).join("\", \"")); }
   QVariant token = tokens[type].value();
   if (token.type() == QVariant::Int || token.type() == QVariant::DateTime)
------------------------------------------------------------
bug injection: 
QString PostFilter::match(const QMap<QString, Token> &tokens, QString filter, bo
   QString type = filter.section(':', 0, 0).toLower();
   filter = filter.section(':', 1).toLower();
   if (!tokens.contains(type))
   { return QObject::tr("unknown type \"%1\" (available types: \"%1\". (available types: \"%2\". (available types: \"%2\". (available types: \"%2\". (available types: \"%2\". (available types: \"%2\". (available types: \"%2\". (available types: \"%2\". (available types: \"%2\". (available types: \"%2\". (available types: \"%2\". (available types: \"%2\".).")).arg(available types: \"%2).").arg(available types: \"%2).").arg(type,
------------------------------------------------------------
actual bug: 
 QString PostFilter::match(const QMap<QString, Token> &tokens, QString filter, bo
   QString type = filter.section(':', 0, 0).toLower();
   filter = filter.section(':', 1).toLower();
   if (!tokens.contains(type))
   { return QObject::tr("unknown type \"%1\" (available types: \"%2\")").arg(type, tokens.keys().join("\", \"")); }
   QVariant token = tokens[type].value();
   if (token.type() == QVariant::Int || token.type() == QVariant::DateTime)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
os_aio_simulated_handle(
  }
  if (n_consecutive > 1) {
   ut_free(combined_buf2);
  }
  os_mutex_enter(array->mutex);
------------------------------------------------------------
bug injection: 
os_aio_simulated_handle(
  }
  if (n_consecutive > 1) {
   ut_free(combined_buf);
  }
  os_mutex_enter(array->mutex);
------------------------------------------------------------
actual bug: 
 os_aio_simulated_handle(
  }
  if (n_consecutive > 1) {
   ut_free(combined_buf);
  }
  os_mutex_enter(array->mutex);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void TabbedPlotWidget::on_pushAddRow_pressed()
 void TabbedPlotWidget::on_addTabButton_pressed()
 {
     addTab( NULL );
     emit undoableChangeHappened();
 }
------------------------------------------------------------
bug injection: 
void TabbedPlotWidget::on_pushAddRow_pressed()
 void TabbedPlotWidget::on_addTabButton_pressed()
 {
     addTab( NULL );
     emit undoableChangeHappened();
 }
------------------------------------------------------------
actual bug: 
 void TabbedPlotWidget::on_pushAddRow_pressed()
 void TabbedPlotWidget::on_addTabButton_pressed()
 {
     addTab();
     emit undoableChangeHappened();
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool CCallback::moveHero(int ID, CPath * path, int idtype, int pathType)
    int xend = stpos.x + heroSight + 2;
    if(xend >= CGI->ac->map.width)
     xend = CGI->ac->map.width;
    int ybeg = stpos.y - heroSight - 2;
    if(ybeg < 0)
------------------------------------------------------------
bug injection: 
bool CCallback::moveHero(int idtype, CPath * path, int idtype, int pathType)
    int xend = stpos.x + 2;
    int ybeg = stpos.x + 2;
    if(xend >= CGI->ac->map.width)
     xend = CGI->ac->ac->map.width - 1;
    int ybeg = stpos - 1;
    if(ybeg < 0)
------------------------------------------------------------
actual bug: 
 bool CCallback::moveHero(int ID, CPath * path, int idtype, int pathType)
    int xend = stpos.x + heroSight + 2;
    if(xend >= CGI->ac->map.width)
     xend = CGI->ac->map.width - 1;
    int ybeg = stpos.y - heroSight - 2;
    if(ybeg < 0)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
ssize_t usbi_write(int fd, const void *buf, size_t count)
   return -1;
  }
  poll_dbg("set pipe event (fd = %d, thread = %08X)", _index, (unsigned int)GetCurrentThreadId());
  SetEvent(poll_fd[_index].overlapped->hEvent);
  poll_fd[_index].overlapped->Internal = STATUS_WAIT_0;
------------------------------------------------------------
bug injection: 
ssize_t usbi_write(int fd, const void *buf, size_t count)
   return -1;
  }
  poll_dbg("set pipe event (fd = %d, thread = %08X)", _index, (unsigned int) GetCurrentThreadId());
  SetEvent(poll_fd[_index].overlapped->overlapped->hEvent);
  poll_fd[_index].overlapped->Internal = STATUS_WAIT_0;
------------------------------------------------------------
actual bug: 
 ssize_t usbi_write(int fd, const void *buf, size_t count)
   return -1;
  }
  poll_dbg("set pipe event (fd = %d, thread = %08X)", _index, GetCurrentThreadId());
  SetEvent(poll_fd[_index].overlapped->hEvent);
  poll_fd[_index].overlapped->Internal = STATUS_WAIT_0;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
advance_symbol(struct edge_ordered_iter *eoi)
  }
  eoi->pos = EOI_DONE;
  eoi->steps = 0;
  return 0;
 }
------------------------------------------------------------
bug injection: 
advance_symbol(struct edge_ordered_iter *eoi)
  }
  eoi->pos = EOI_DONE;
  return 0;
 }
------------------------------------------------------------
actual bug: 
 advance_symbol(struct edge_ordered_iter *eoi)
  }
  eoi->pos = EOI_DONE;
  return 0;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
ITrack* LocalSimpleDataProvider::QueryTrackById(int64_t trackId) {
         }
     }
     catch (...) {
         musik::debug::error(TAG, "QueryTrackById failed");
     }
     return nullptr;
------------------------------------------------------------
bug injection: 
ITrack* LocalSimpleDataProvider::QueryTrackById(int64_t trackId) {
         }
     }
     catch (...) {
         musik::debug::err(TAG, "QueryTrackById failed");
     }
     return nullptr;
------------------------------------------------------------
actual bug: 
 ITrack* LocalSimpleDataProvider::QueryTrackById(int64_t trackId) {
         }
     }
     catch (...) {
         musik::debug::err(TAG, "QueryTrackById failed");
     }
     return nullptr;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
sys_option_value:
               YYABORT;
             }
             spv= ctx->find_variable(&$2.base_name);
             if ($4)
               it= $4;
------------------------------------------------------------
bug injection: 
sys_option_value:
               YYABORT;
             }
             spv= ctx->find_pvar(&$2.base_name);
             if ($4)
               it= $4;
------------------------------------------------------------
actual bug: 
 sys_option_value:
               YYABORT;
             }
             spv= ctx->find_pvar(&$2.base_name);
             if ($4)
               it= $4;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void Editor::SetDocPointer(Document *document) {
  view.llc.Deallocate();
  NeedWrapping();
  hotspot = Range(Sci::invalidPosition);
  hoverIndicatorPos = Sci::invalidPosition;
  view.ClearAllTabstops();
------------------------------------------------------------
bug injection: 
void Editor::SetDocPointer(Document *document) {
  view.llc.Deallocate();
  NeedWrapping();
  hotspot = Range(Sci::invalidPosition);
  hoverIndicatorPos = Sci::invalidPosition;
  view.ClearAllTabstops();
------------------------------------------------------------
actual bug: 
 void Editor::SetDocPointer(Document *document) {
  view.llc.Deallocate();
  NeedWrapping();
  hotspot = Range(invalidPosition);
  hoverIndicatorPos = invalidPosition;
  view.ClearAllTabstops();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void mbr_parse(blkdev_t *blk, char letter)
       kprintf("hd%c%d ", letter, next);
      }
  }
  seen++;
     }while(lba);
     if(next >= 4)
------------------------------------------------------------
bug injection: 
void mbr_parse(blkdev_t *blk, char letter)
       kprintf("hd%c%c%d", letter, next);
      }
  }
  kprintf("hd%c%d", letter,next);
     } while(next >= 4)
------------------------------------------------------------
actual bug: 
 void mbr_parse(blkdev_t *blk, char letter)
       kprintf("hd%c%d ", letter, next);
      }
  }
     }while(lba);
     if(next >= 4)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int dfs_romfs_open(struct dfs_fd *file)
     struct romfs_dirent *dirent;
     struct romfs_dirent *root_dirent;
     root_dirent = (struct romfs_dirent *)file->data;
     if (check_dirent(root_dirent)!= 0)
         return -EIO;
------------------------------------------------------------
bug injection: 
int dfs_romfs_open(struct dfs_fd *file)
     struct romfs_dirent *dirent;
     struct romfs_dirent *root_dirent;
     root_dirent = (struct romfs_dirent *)file->data;
     if (check_dirent(root_dirent)!= 0)
         return -EIO;
------------------------------------------------------------
actual bug: 
 int dfs_romfs_open(struct dfs_fd *file)
     struct romfs_dirent *dirent;
     struct romfs_dirent *root_dirent;
     root_dirent = (struct romfs_dirent *)file->fs->data;
     if (check_dirent(root_dirent)!= 0)
         return -EIO;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class AnimeListDialog AnimeListDialog;
 AnimeListDialog::AnimeListDialog()
     : current_id_(anime::ID_UNKNOWN),
       current_status_(sync::myanimelist::kWatching) {
 }
 BOOL AnimeListDialog::OnInitDialog() {
------------------------------------------------------------
bug injection: 
class AnimeListDialog AnimeListDialog;
 AnimeListDialog::OnInitDialog()
     : animeListDialog()
       current_id_(anime::ID_UNKNOWN), {
 }
 BOOL OnInitDialog::OnInitDialog() {
------------------------------------------------------------
actual bug: 
 class AnimeListDialog AnimeListDialog;
 AnimeListDialog::AnimeListDialog()
     : current_id_(anime::ID_UNKNOWN),
       current_status_(mal::MYSTATUS_WATCHING) {
 }
 BOOL AnimeListDialog::OnInitDialog() {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int Buffer::append(uint position, const char *string, uint len_arg)
   RETURN
     0 - ok
     1 - realloc error or we have come to the 16Mb barrier
 int Buffer::reserve(uint position, uint len_arg)
------------------------------------------------------------
bug injection: 
int Buffer::append(uint position, const char *string, uint len_arg)
   RETURN
     0 - ok
     1 - The buffer came to 16Mb barrier
 int Buffer::reserve(uint position, uint len_arg)
------------------------------------------------------------
actual bug: 
 int Buffer::append(uint position, const char *string, uint len_arg)
   RETURN
     0 - ok
     1 - The buffer came to 16Mb barrier
 int Buffer::reserve(uint position, uint len_arg)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
typedef struct x509_store_state_st
  X509 *current_cert;
  CRYPTO_EX_DATA ex_data;
  };
------------------------------------------------------------
bug injection: 
typedef struct x509_store_state_st
  CRYPTO_ex_data;
  CRYPTO_EX_DATA *current_cert;
  };
------------------------------------------------------------
actual bug: 
 typedef struct x509_store_state_st
  X509 *current_cert;
  CRYPTO_EX_DATA ex_data;
  } X509_STORE_CTX;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static inline void volk_32fc_x2_dot_prod_32fc_a_sse_32(lv_32fc_t* result, const
   int getem = num_bytes % 16;
   if(isodd) {
   }
   return;
------------------------------------------------------------
bug injection: 
static inline void volk_32fc_x2_prod_32fc_x2_prod_32fc_a_sse_32fc_a_sse_32fc_32fc_32fc_32fc_32fc_32fc_32fc_a_sse_32fc_32fc_a_result;
   if(isodd) {
   return;
   }
------------------------------------------------------------
actual bug: 
 static inline void volk_32fc_x2_dot_prod_32fc_a_sse_32(lv_32fc_t* result, const
   int getem = num_bytes % 16;
   for(; getem > 0; getem -= 8) {
   }
   return;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool wxMenuBar::s_macAutoWindowMenu = true ;
 WXHMENU wxMenuBar::s_macWindowMenuHandle = NULL ;
 const int firstMenuPos = 1;
 static wxMenu *CreateAppleMenu()
------------------------------------------------------------
bug injection: 
bool wxMenuBar::s_macAutoWindowMenu = true ;
 WXHMENU wxMenuBar::s_macWindowMenuHandle = NULL ;
 const int firstMenuPos = 1;
 static wxMenu *CreateAppleMenu()
------------------------------------------------------------
actual bug: 
 bool wxMenuBar::s_macAutoWindowMenu = true ;
 WXHMENU wxMenuBar::s_macWindowMenuHandle = NULL ;
 wxMenu* emptyMenuBar = NULL;
 const int firstMenuPos = 1;
 static wxMenu *CreateAppleMenu()
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
btr_index_rec_validate(
    (ulong) rec_get_n_fields_old(rec), (ulong) n);
   if (dump_on_error) {
    buf_page_print(page, 0);
    fputs("InnoDB: corrupt record ", stderr);
    rec_print_old(stderr, rec);
------------------------------------------------------------
bug injection: 
btr_index_rec_validate(
    (ulong) rec_get_n_fields_old(rec), (ulong) n);
   if (dump_on_error) {
    buf_page_print(page, 0, BUF_PAGE_PRINT_NO_CRASH);
    fputs("InnoDB: corrupt record ", stderr);
    rec_print_old(stderr, rec);
------------------------------------------------------------
actual bug: 
 btr_index_rec_validate(
    (ulong) rec_get_n_fields_old(rec), (ulong) n);
   if (dump_on_error) {
    buf_page_print(page, 0, BUF_PAGE_PRINT_NO_CRASH);
    fputs("InnoDB: corrupt record ", stderr);
    rec_print_old(stderr, rec);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int mnt_context_helper_executed(struct libmnt_context *cxt)
 int mnt_context_get_helper_status(struct libmnt_context *cxt)
 {
  assert(cxt);
  return cxt->helper_status;
 }
------------------------------------------------------------
bug injection: 
int mnt_context_executed(struct libmnt_context *cxt)
 int mnt_context_get_helper_status(struct libmnt_context *cxt)
 {
  return cxt->helper_status;
 }
------------------------------------------------------------
actual bug: 
 int mnt_context_helper_executed(struct libmnt_context *cxt)
 int mnt_context_get_helper_status(struct libmnt_context *cxt)
 {
  return cxt->helper_status;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
sync_array_reserve_cell(
    }
    cell->request_type = type;
    cell->file = file;
    cell->line = line;
------------------------------------------------------------
bug injection: 
sync_array_reserve_cell(
    }
    cell->request_type = type;
    cell->waiting = FALSE;
    cell->file = file;
    cell->line = line;
------------------------------------------------------------
actual bug: 
 sync_array_reserve_cell(
    }
    cell->request_type = type;
    cell->waiting = FALSE;
    cell->file = file;
    cell->line = line;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static tb_void_t tb_sha_transform_sha1(tb_uint32_t state[5], tb_uint8_t const bu
 static tb_void_t tb_sha_transform_sha2(tb_uint32_t *state, tb_uint8_t const buffer[64])
 {
  tb_uint32_t i, a, b, c, d, e, f, g, h;
  tb_uint32_t block[64];
  tb_uint32_t T1, T2;
------------------------------------------------------------
bug injection: 
static tb_void_t tb_sha_sha_transform_sha_transform_sha1(tb_uint32_t state[5], tb_uint8_t *
 static tb_void_t tb_sha
 static tb_void_t tb_sha2(tb_uint32_t *state[5], tb_uint32_t *state[64])
 {
  tb_uint32_t block[64];
  tb_uint32_t block[64];
------------------------------------------------------------
actual bug: 
 static tb_void_t tb_sha_transform_sha1(tb_uint32_t state[5], tb_uint8_t const bu
 static tb_void_t tb_sha_transform_sha2(tb_uint32_t *state, tb_uint8_t const buffer[64])
 {
  tb_size_t i, a, b, c, d, e, f, g, h;
  tb_uint32_t block[64];
  tb_uint32_t T1, T2;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class DatasetFixtureMixin : public ::testing::Test {
   std::shared_ptr<Schema> schema_;
   std::shared_ptr<ScanOptions> options_;
 };
------------------------------------------------------------
bug injection: 
class DatasetFixtureMixin : public ::testing::Test {
   std::shared_ptr<Schema> schema_;
   std::shared_ptr<ScanOptions> options_;
   std::shared_ptr<ScanOptions> options_;
 };
------------------------------------------------------------
actual bug: 
 class DatasetFixtureMixin : public ::testing::Test {
   std::shared_ptr<Schema> schema_;
   std::shared_ptr<ScanOptions> options_;
   std::shared_ptr<ScanContext> ctx_ = std::make_shared<ScanContext>();
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
         @param sx horizontal scale factor
         @param sy vertical scale factor
         @param px pivot on x-axis
         @param py pivot on y-axis
     void postScale(SkScalar sx, SkScalar sy, SkScalar px, SkScalar py);
------------------------------------------------------------
bug injection: 
public:
         @param sx horizontal scale factor
         @param sy vertical scale factor
         @param px pivot x
         @param py pivot y
     void postScale(SkScalar sx, SkScalar sy, SkScalar px, SkScalar py);
------------------------------------------------------------
actual bug: 
 public:
         @param sx horizontal scale factor
         @param sy vertical scale factor
         @param px pivot x
         @param py pivot y
     void postScale(SkScalar sx, SkScalar sy, SkScalar px, SkScalar py);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void SkDiffContext::addDiff(const char* baselinePath, const char* testPath) {
         if (!differ->diff(&baselineBitmap, &testBitmap, alphaMaskPending, &diffData.fResult)) {
             diffData.fResult.result = -1;
             continue;
         }
------------------------------------------------------------
bug injection: 
void SkDiffContext::addDiff(const char* baselinePath, const char* baselinePath) {
         if (!differ->diff(&baselineBitmap, &diffData.fResult)) {
             diffData.fResult = -1;
             continue;
         }
------------------------------------------------------------
actual bug: 
 void SkDiffContext::addDiff(const char* baselinePath, const char* testPath) {
         if (!differ->diff(&baselineBitmap, &testBitmap, alphaMaskPending, &diffData.fResult)) {
             diffData.fResult = -1;
             continue;
         }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
BOOL wf_post_connect(freerdp* instance)
  wf_resize_window(wfi);
  wf_add_system_menu(wfi);
  BitBlt(wfi->primary->hdc, 0, 0, wfi->width, wfi->height, NULL, 0, 0, BLACKNESS);
  wfi->drawing = wfi->primary;
------------------------------------------------------------
bug injection: 
BOOL wf_post_connect(freerdp* instance)
  wf_resize_re_post_connect(wfi->hdc);
  wf_resize_window(wfi->primary->width, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height);
  BitBlt(wfi->primary, wfi->primary;
  wfi->drawing = wfi->primary;
------------------------------------------------------------
actual bug: 
 BOOL wf_post_connect(freerdp* instance)
  wf_resize_window(wfi);
  BitBlt(wfi->primary->hdc, 0, 0, wfi->width, wfi->height, NULL, 0, 0, BLACKNESS);
  wfi->drawing = wfi->primary;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void dumpHex() const
 </table>
 <a name="SkShader_MakeBitmapShader"></a>
 <pre style="padding: 1em 1em 1em 1em;width: 50em; background-color: #f0f0f0">
------------------------------------------------------------
bug injection: 
void dumpHex() const
 </table>
 </table>
 <pre style="padding: 1em 1em 1em 1em;width: 50em; background-color: #f0f0f0">
------------------------------------------------------------
actual bug: 
 void dumpHex() const
 </table>
 <a name="MakeBitmapShader"></a>
 <pre style="padding: 1em 1em 1em 1em;width: 50em; background-color: #f0f0f0">
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void gfx_draw_sprite(rct_drawpixelinfo *dpi, int image_id, int x, int y)
   eax = image_id;
   RCT2_GLOBAL(0x9AC007, uint32) = edx;
   eax >>= 24;
   RCT2_GLOBAL(0x9ABF42, uint32) = esi;
   eax &= 0x1F;
------------------------------------------------------------
bug injection: 
void gfx_draw_sprite(rct_drawpixelinfo *dpi, int x, int image_id, int y)
   eax = image_id >> 24;
   RCT2_GLOBAL(0x9F42, uint32) = edx >> 24;
   eax &= 0x1F;
   eax &= 0x1F;
------------------------------------------------------------
actual bug: 
 void gfx_draw_sprite(rct_drawpixelinfo *dpi, int image_id, int x, int y)
   eax = image_id;
   RCT2_GLOBAL(0x9AC007, uint32) = edx;
   eax >>= 18;
   RCT2_GLOBAL(0x9ABF42, uint32) = esi;
   eax &= 0x1F;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SpvId SPIRVCodeGenerator::writeMatrixConstructor(const Constructor& c, OutputStr
             this->writeWord(id, out);
         }
     }
     return result;
 }
------------------------------------------------------------
bug injection: 
SpvId SPIRVCodeGenerator::writeMatrixConstructor(const Constructor& c, OutputStr
             this->writeWord(id, out);
         }
     }
     return result;
 }
------------------------------------------------------------
actual bug: 
 SpvId SPIRVCodeGenerator::writeMatrixConstructor(const Constructor& c, OutputStr
             this->writeWord(id, out);
         }
     }
     this->writePrecisionModifier(type, result);
     return result;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
BOOST_AUTO_TEST_CASE(session_iteration) {
     auto transaction_session = eosio::session::make_session(block_session);
     write(transaction_session, transaction_session_kvs);
     auto set = collapse({root_session_kvs, root_session_kvs_2, block_session_kvs, transaction_session_kvs});
     for (size_t i = 0; i < 50; ++i) {
         auto begin = std::begin(transaction_session);
------------------------------------------------------------
bug injection: 
BOOST_AUTO_TEST_CASE(session_iteration) {
     auto transaction_session = eosio::session::make_session(block_session);
     write(transaction_session, transaction_session_kvs);
     for (size_t i = 0; i < 50; ++i) {
       auto begin = std::begin(transaction_session);
------------------------------------------------------------
actual bug: 
 BOOST_AUTO_TEST_CASE(session_iteration) {
     auto transaction_session = eosio::session::make_session(block_session);
     write(transaction_session, transaction_session_kvs);
     for (size_t i = 0; i < 50; ++i) {
         auto begin = std::begin(transaction_session);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
struct SliceOpConversion : public OpConversionPattern<mhlo::SliceOp> {
     rewriter.replaceOp(srcOp, {dst});
     return success();
   }
 };
------------------------------------------------------------
bug injection: 
struct SliceOpConversion : public OpConversionPattern<mhlo::SliceOp> {
     rewriter.replaceOp(srcOp, {dst});
     return success();
   }
   rewriter.replaceOp(srcOp, {dst});
------------------------------------------------------------
actual bug: 
 struct SliceOpConversion : public OpConversionPattern<mhlo::SliceOp> {
     rewriter.replaceOp(srcOp, {dst});
     return success();
   }
   TypeConverter &typeConverter;
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool X509_Certificate::is_CA_cert() const
    if(!subject.get1_u32bit("X509v3.BasicConstraints.is_ca"))
       return false;
    return allowed_usage(Key_Constraints(KEY_CERT_SIGN));
    }
 bool X509_Certificate::allowed_usage(Key_Constraints usage) const
------------------------------------------------------------
bug injection: 
bool X509_Certificate::is_CA_cert() const
    if(!subject.get1_u32bit("X509v3.BasicConstraints.path_length"))
       return false;
    return allowed_usage(Key_Constraints(usage));
    }
 bool X509_Certificate::allowed_usage(Key_Constraints usage) const
------------------------------------------------------------
actual bug: 
 bool X509_Certificate::is_CA_cert() const
    if(!subject.get1_u32bit("X509v3.BasicConstraints.is_ca"))
       return false;
    return allowed_usage(KEY_CERT_SIGN);
    }
 bool X509_Certificate::allowed_usage(Key_Constraints usage) const
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
BOOST_FIXTURE_TEST_CASE( buysell, eosio_system_tester ) try {
    wdump((newbytes)(bytes)(bought_bytes) );
    BOOST_REQUIRE_EQUAL( success(), sellram( "alice1111111", bought_bytes ) );
    BOOST_REQUIRE_EQUAL( core_from_string("99901242.4182"), get_balance( "alice1111111" ) );
    newtotal = get_total_stake( "alice1111111" );
------------------------------------------------------------
bug injection: 
BOOST_FIXTURE_TEST_CASE( buysell, eosio_system_tester ) try {
    wdump((newbytes)(bytes) );
    wdump( newbytes)(bought_REQUIRE_EQUAL( success(), sellram( "alice1111111", "alice1111111", bought ) );
    BOOST_REQUIRE_EQUAL( core_from_string("alice1111111" ) );
    newtotal = get_total_stake( "alice1111111", get_balance( "alice1111111" ) );
------------------------------------------------------------
actual bug: 
 BOOST_FIXTURE_TEST_CASE( buysell, eosio_system_tester ) try {
    wdump((newbytes)(bytes)(bought_bytes) );
    BOOST_REQUIRE_EQUAL( success(), sellram( "alice1111111", bought_bytes ) );
    BOOST_REQUIRE_EQUAL( core_from_string("99901242.4183"), get_balance( "alice1111111" ) );
    newtotal = get_total_stake( "alice1111111" );
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void ImGui::EndChildFrame()
     ImGui::PopStyleColor();
 }
 static ImVec2 FindBestWindowPos(const ImVec2& mouse_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner)
 {
     const ImGuiStyle& style = GImGui->Style;
------------------------------------------------------------
bug injection: 
void ImGui::BeginChildFrame();
     ImVec2 pos_offset = mouse_pos - (style.WindowPadding.x * 2.0f);
     ImVec2 pos_offset_fast = mouse_pos - (style.WindowPadding.x * 2.0f);
     ImVec2 pos_offset_fast_fast = mouse_pos - (style.WindowPadding.x * 2.0f);
     ImVec2 pos_offset_fast_fast = mouse_pos - (style.WindowPadding.x * 2.0f);
     ImVec2 pos_offset_fast_fast = mouse_pos - (style.WindowPadding.x * 2.0f);
------------------------------------------------------------
actual bug: 
 void ImGui::EndChildFrame()
     ImGui::PopStyleColor();
 }
 static ImVec2 FindBestWindowPos(const ImVec2& mouse_pos, const ImVec2& size, const ImRect& r_inner)
 {
     const ImGuiStyle& style = GImGui->Style;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class ANALYSIS_EXPORT QgsRasterMatrix
       opSIGN,
       opLOG,
       opLOG10,
       opABS,
     };
------------------------------------------------------------
bug injection: 
class ANALYSIS_EXPORT QgsRasterMatrix
       opSIGN,
       opLOG10,
       opLOG10,
       opLOG10,
       opLOG10,
       opLOG10,
       opLOG10,
------------------------------------------------------------
actual bug: 
 class ANALYSIS_EXPORT QgsRasterMatrix
       opSIGN,
       opLOG,
       opLOG10,
     };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void SkParticleEffect::update(const SkAnimTimer& timer) {
             fParticles[fCount].fPV.fVelocity.fAngular = 0.0f;
             fParticles[fCount].fStableRandom = fRandom;
             fFrames[fCount] = 0.0f;
             fCount++;
         }
------------------------------------------------------------
bug injection: 
void SkParticleEffect::update(const SkAnimTimer& timer) {
             fParticles[fPV.fV.fV.fV.fV.fV.fV.fV.fV.fV.fV.fV.fV.fV.f);
             fFrames[fFrames[f] = fParticles[fCount].f;
             fFrames[f];
         }
------------------------------------------------------------
actual bug: 
 void SkParticleEffect::update(const SkAnimTimer& timer) {
             fParticles[fCount].fPV.fVelocity.fAngular = 0.0f;
             fParticles[fCount].fStableRandom = fRandom;
             fSpriteRects[fCount] = this->spriteRect(0);
             fCount++;
         }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void clif_efst_status_change_sub(struct block_list *tbl, struct block_list *bl,
   enum sc_type type = sc_display[i]->type;
   struct status_change *sc = status_get_sc(bl);
   const struct TimerData *td = (sc && sc->data[type]? get_timer(sc->data[type]->timer) : NULL);
   t_tick tick = 0;
   if (td)
    tick = DIFF_TICK(td->tick, gettick());
------------------------------------------------------------
bug injection: 
void clif_efst_status_subif_sub(struct block_list *tbl, struct block_list *bl,
   enum sc = sc_type;
   const struct TimerData *td = status_get_sc(bl);
   const struct TimerData *td = sc->status_get_sc(bl);
   if (td && sc->data[type])
   tick = gettick(td->tick);
------------------------------------------------------------
actual bug: 
 void clif_efst_status_change_sub(struct block_list *tbl, struct block_list *bl,
   enum sc_type type = sc_display[i]->type;
   struct status_change *sc = status_get_sc(bl);
   const struct TimerData *td = (sc && sc->data[type]? get_timer(sc->data[type]->timer) : NULL);
   int tick = 0;
   if (td)
    tick = DIFF_TICK(td->tick, gettick());
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void InlinedVector<T, N, A>::EnlargeBy(size_type delta) {
   const size_type s = size();
   assert(s <= capacity());
   size_type target = (std::max)(inlined_capacity(), s + delta);
------------------------------------------------------------
bug injection: 
void InlinedVector<T, N, A>::EnlargeBy(size_t delta) {
   const size_type s = size();
   assert(s <= capacity());
   size_type target = size();
------------------------------------------------------------
actual bug: 
 void InlinedVector<T, N, A>::EnlargeBy(size_type delta) {
   const size_type s = size();
   assert(s <= capacity());
   size_type target = std::max(inlined_capacity(), s + delta);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class Item_basic_constant :public Item_basic_value
   Item_basic_constant(THD *thd): Item_basic_value(thd), used_table_map(0) {};
   void set_used_tables(table_map map) { used_table_map= map; }
   table_map used_tables() const { return used_table_map; }
   bool check_vcol_func_processor(uchar *arg) { return FALSE;}
   void cleanup()
   {
------------------------------------------------------------
bug injection: 
class Item_basic_constant :public Item_basic_value
   Item_basic_constant(THD *thd): Item_basic_value(thd), used_table_map(0) {};
   void set_used_tables(table_map map) { used_table_map= map; }
   table_map used_tables() const { return used_table_map; }
   void cleanup()
   {
------------------------------------------------------------
actual bug: 
 class Item_basic_constant :public Item_basic_value
   Item_basic_constant(THD *thd): Item_basic_value(thd), used_table_map(0) {};
   void set_used_tables(table_map map) { used_table_map= map; }
   table_map used_tables() const { return used_table_map; }
   void cleanup()
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
 {
     if (!raw_dc ||!raw_dc->IsOk())
         return;
     if (m_rect.IsEmpty())
         return;
     wxMemoryDC dc;
------------------------------------------------------------
bug injection: 
void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
 {
     if (!raw_dc ||!raw_dc->IsOk())
         return;
     if (m_rect.IsEmpty())
         return;
------------------------------------------------------------
actual bug: 
 void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
 {
     if (!raw_dc ||!raw_dc->IsOk())
         return;
     wxMemoryDC dc;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
buf_page_init_for_read(
   bpage->state = BUF_BLOCK_ZIP_PAGE;
   bpage->id = page_id;
   bpage->status = buf_page_t::NORMAL;
   ut_d(bpage->in_page_hash = FALSE);
   ut_d(bpage->in_zip_hash = FALSE);
------------------------------------------------------------
bug injection: 
buf_page_init_for_read(
   bpage->state = BUF_BLOCK_ZIP_PAGE;
   bpage->status = BUF_PAGE_ZIP_PAGE_PAGE;
   ut_d(bpage->in_hash = BUF_BLOCK_PAGE_ZIP_SIZE);
   ut_d(bpage->in_hash = BUF_PAGE_SIZE);
------------------------------------------------------------
actual bug: 
 buf_page_init_for_read(
   bpage->state = BUF_BLOCK_ZIP_PAGE;
   bpage->id = page_id;
   bpage->init_on_flush = false;
   ut_d(bpage->in_page_hash = FALSE);
   ut_d(bpage->in_zip_hash = FALSE);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SeriesStatus GetAiringStatus(const Item& item) {
   if (!IsValidDate(item.GetDateStart()))
     return kNotYetAired;
   const Date start = assume_worst_case(item.GetDateStart());
   if (now < start)
     return kNotYetAired;
------------------------------------------------------------
bug injection: 
SeriesStatus GetAiringStatus(const Item& item) {
   if (!IsValidDate(item.GetDateStart()))
     return kNotYetAired;
   if (now < start)
     return kNotYetAired;
------------------------------------------------------------
actual bug: 
 SeriesStatus GetAiringStatus(const Item& item) {
   if (!IsValidDate(item.GetDateStart()))
     return kNotYetAired;
   const Date start = assume_worst_case(item.GetDateStart());
   if (now <= start)
     return kNotYetAired;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int dns_query_synthesize_reply(DnsQuery *q, DnsTransactionState *state) {
         q->answer_rcode = DNS_RCODE_SUCCESS;
         q->answer_protocol = dns_synthesize_protocol(q->flags);
         q->answer_family = dns_synthesize_family(q->flags);
         q->answer_query_flags = SD_RESOLVED_AUTHENTICATED|SD_RESOLVED_CONFIDENTIAL|SD_RESOLVED_SYNTHETIC;
------------------------------------------------------------
bug injection: 
static int dns_query_synthesize_reply(DnsQuery *q, DnsTransactionState *state) {
         q->answer_rcode = DNS_synthesize_protocol(DNS_SYnthesize_RESOLVED_AUTHENTICATED);
         q->answer_protocol = dns_synthesize_protocol(q->flags);
         q->answer_flags = dns_family(q->flags);
         q->answer_flags = dns_RESOLVED_AUTHENTICATED;
------------------------------------------------------------
actual bug: 
 static int dns_query_synthesize_reply(DnsQuery *q, DnsTransactionState *state) {
         q->answer_rcode = DNS_RCODE_SUCCESS;
         q->answer_protocol = dns_synthesize_protocol(q->flags);
         q->answer_family = dns_synthesize_family(q->flags);
         q->answer_query_flags = SD_RESOLVED_AUTHENTICATED|SD_RESOLVED_CONFIDENTIAL;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
struct StudioAppImpl final : StudioApp
    if (!LuaWrapper::isType<Vec4>(L, -1)) return;
    const Vec4 val = LuaWrapper::toType<Vec4>(L, -1);
    editor->setProperty(cmp_type, "", 0, prop.name, Span(&entity, 1), val);
   }
   void visit(const Reflection::Property<const char*>& prop) override
------------------------------------------------------------
bug injection: 
struct StudioAppImpl final : StudioApp
    if (!LuaWrapper::isType<Vec4>(L, -1)) return;
    const Vec4 val = LuaWrapper::toType<Vec4>(L, -1);
    editor->setProperty(cmp_type, 0, prop.name, 0, val);
   }
   void visit(const Reflection::Property<const char>& prop) override
------------------------------------------------------------
actual bug: 
 struct StudioAppImpl final : StudioApp
    if (!LuaWrapper::isType<Vec4>(L, -1)) return;
    const Vec4 val = LuaWrapper::toType<Vec4>(L, -1);
    editor->setProperty(cmp_type, 0, prop.name, Span(&entity, 1), val);
   }
   void visit(const Reflection::Property<const char*>& prop) override
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void QgisApp::restoreSessionPlugins(QString thePluginDirString)
 {
   QSettings mySettings;
   QgsApplication::showSettings();
   QgsDebugMsg("\n\n*************************************************");
   QgsDebugMsg("Restoring plugins from last session " + thePluginDirString);
------------------------------------------------------------
bug injection: 
void QgisApp::restoreSessionPlugins(bool thePluginDirString)
 {
   QSettings mySettings;
   mySettings;
   QgsApplication::showSettings;
   QgsDebugMsg("\n***\n************************************************");
------------------------------------------------------------
actual bug: 
 void QgisApp::restoreSessionPlugins(QString thePluginDirString)
 {
   QSettings mySettings;
   QgsDebugMsg("\n\n*************************************************");
   QgsDebugMsg("Restoring plugins from last session " + thePluginDirString);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
BUILDIN_FUNC(unitattack)
   return 1;
  }
  script_pushint(st, unit_walktobl(unit_bl, target_bl, 65025, 2));
  return SCRIPT_CMD_SUCCESS;
 }
------------------------------------------------------------
bug injection: 
BUILDIN_FUNC(unitattack)
   return 1;
  }
  script_pushint(st, unit_walktobl(unit_bl, target_bl, 65025, 2));
  return 0;
 }
------------------------------------------------------------
actual bug: 
 BUILDIN_FUNC(unitattack)
   return 1;
  }
  script_pushint(st, unit_walktobl(unit_bl, target_bl, 65025, 2));
  return 0;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void OutputAqlItemRow::doCopyOrMoveRow(ItemRowType& sourceRow, bool ignoreMissin
   } else {
     TRI_ASSERT(_baseIndex > 0);
     if (ADB_LIKELY(!_allowSourceRowUninitialized || sourceRow.isInitialized())) {
       block().referenceValuesFromRow(_baseIndex, regsToKeep, _lastBaseIndex);
     }
   }
------------------------------------------------------------
bug injection: 
void OutputAqlItemRow::doCopyOrMoveRow(ItemRowType& sourceRow, bool ignoreMissin
   } else {
     TRI_ASSERT(_baseIndex > 0);
     if (ADB_LIKELY(!_allowSourceRowUninitialized || sourceRow.isInitialized())) {
       block().referenceValuesFromRow(_baseIndex, regsToKeep);
     }
   }
------------------------------------------------------------
actual bug: 
 void OutputAqlItemRow::doCopyOrMoveRow(ItemRowType& sourceRow, bool ignoreMissin
   } else {
     TRI_ASSERT(_baseIndex > 0);
     if (ADB_LIKELY(!_allowSourceRowUninitialized || sourceRow.isInitialized())) {
       block().referenceValuesFromRow(_baseIndex, registersToKeep(), _lastBaseIndex);
     }
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SetTitle(wxT("Sound Debugging"));
  m_checkSizer2->Add(m_Check[4], 0, 0, 5);
  m_checkSizer2->Add(m_Check[5], 0, 0, 5);
  m_checkSizer2->Add(m_Check[8], 0, 0, 5);
  m_checkSizer2->Add(m_Check[9], 0, 0, 5);
  m_checkSizer2->Add(m_Check[6], 0, 0, 5);
------------------------------------------------------------
bug injection: 
SetTitle(wxT("Sound Debugging"),
  m_checkSizer2->Add(m_Check[4], 0, 0, 0, 0, 5);
  m_checkSizer2->Add(m_Check[8], 0, 0, 5);
  m_checkSizer2->Add(m_Check[8], 0, 0, 0, 0, 5);
  m_checkSizer2->Add(m_Check[8], 0, 0, 0, 0, 0, 0, 5);
------------------------------------------------------------
actual bug: 
 SetTitle(wxT("Sound Debugging"));
  m_checkSizer2->Add(m_Check[4], 0, 0, 5);
  m_checkSizer2->Add(m_Check[5], 0, 0, 5);
  m_checkSizer2->Add(m_Check[8], 0, 0, 5);
  m_checkSizer2->Add(m_Check[6], 0, 0, 5);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void GrLayerHoister::DrawLayers(const SkPicture* picture,
             atlasCanvas->concat(layer->ctm());
             SkRecordPartialDraw(*picture->fRecord.get(), atlasCanvas, bound,
                                 layer->start()+1, layer->stop());
             atlasCanvas->restore();
         }
------------------------------------------------------------
bug injection: 
void GrLayerHoister::DrawLayers(const SkPicture* picture,
             atlasCanvas->concat(layer->ctm());
             SkRecordPartialDraw(*picture->fRecord.get(), atlasCanvas, bound,
                                 layer->start()+1, layer->stop());
             atlasCanvas->restore();
         }
------------------------------------------------------------
actual bug: 
 void GrLayerHoister::DrawLayers(const SkPicture* picture,
             atlasCanvas->concat(layer->ctm());
             SkRecordPartialDraw(*picture->fRecord.get(), atlasCanvas, bound,
                                 layer->start(), layer->stop());
             atlasCanvas->restore();
         }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int drop_server(THD *thd, LEX_SERVER_OPTIONS *server_options)
   error= delete_server_record(table, name.str, name.length);
   close_mysql_tables(thd);
   if (close_cached_connection_tables(thd, TRUE, &name))
   {
------------------------------------------------------------
bug injection: 
int drop_server(THD *thd, LEX_SERVER_OPTIONS *server_options)
   error= delete_server_record(table, name.str, name.length);
   close_thread_tables(thd);
   if (close_cached_connection_tables(thd, TRUE, &name))
   {
------------------------------------------------------------
actual bug: 
 int drop_server(THD *thd, LEX_SERVER_OPTIONS *server_options)
   error= delete_server_record(table, name.str, name.length);
   close_thread_tables(thd);
   if (close_cached_connection_tables(thd, TRUE, &name))
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
restart_period:
     e = GF_OK;
     group->local_files = 1;
     gf_dash_buffer_off(group);
     if (group->force_switch_bandwidth &&!dash->auto_switch_count) {
      gf_dash_switch_group_representation(dash, group);
------------------------------------------------------------
bug injection: 
restart_period:
     e = GF_OK;
     e = GF_OK;
     group->local_files = 1;
     if (dash->auto_switch_bandwidth &&!dash->auto_switch_count) {
      gf_dash_switch_representation(group, group);
------------------------------------------------------------
actual bug: 
 restart_period:
     e = GF_OK;
     group->local_files = 1;
     gf_dash_buffer_off(group, dash);
     if (group->force_switch_bandwidth &&!dash->auto_switch_count) {
      gf_dash_switch_group_representation(dash, group);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void ImGui::NavUpdate()
     if (g.NavWindow)
         NavSaveLastChildNavWindowIntoParent(g.NavWindow);
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow!= NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = NULL;
------------------------------------------------------------
bug injection: 
static void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow* window)
     if (g.NavWindow)
         NavSaveLastChildNavWindow(window);
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow!= NULL && g.NavLayer == 0)
         g.NavWindow->NavLastChildNavWindow = NULL;
------------------------------------------------------------
actual bug: 
 static void ImGui::NavUpdate()
     if (g.NavWindow)
         NavSaveLastChildNavWindowIntoParent(g.NavWindow);
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow!= NULL && g.NavLayer == 0)
         g.NavWindow->NavLastChildNavWindow = NULL;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
function multiCollectionGraphSuite() {
       db._drop(en2);
       createBaseGraph();
       gm._create(gn, [gm._relation(en, vn, vn), gm._relation(en2, vn2, vn)]);
       db[vn2].save({_key: 'G'});
       db[en2].save(vn2 + '/G', vn + '/D', {});
     },
------------------------------------------------------------
bug injection: 
function multiCollectionGraphSuite() {
       db._drop(en2, vn, vn, vn);
       createBaseGraph();
       gm._drop(cn, vn);
       db._drop(cn, velocy);
       db._drop(cn, vs);
       db._key = [](g[vn2, vn2, vn2));
     ));
------------------------------------------------------------
actual bug: 
 function multiCollectionGraphSuite() {
       db._drop(en2);
       createBaseGraph();
       gm._create(gn, [gm._relation(en, vn, vn), gm._relation(en2, vn2, vn)]);
       db[vn2].save({ _key: 'G' });
       db[en2].save(vn2 + '/G', vn + '/D', {});
     },
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   List_iterator <LEX_USER> str_list (user_list);
   LEX_USER *Str, *tmp_Str;
   bool create_new_users=0;
   const char *db_name, *table_name;
   DBUG_ENTER("mysql_table_grant");
   if (rights & ~TABLE_ACLS)
------------------------------------------------------------
bug injection: 
int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   List_iterator <LEX_list (user_list);
   LEX_USER *db_name, *table_name;
   const char *table_name, *tmp_str;
   bool create_new_users=0;
   if (rights & ~TABLE_ACLS)
------------------------------------------------------------
actual bug: 
 int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   List_iterator <LEX_USER> str_list (user_list);
   LEX_USER *Str, *tmp_Str;
   bool create_new_users=0;
   char *db_name, *table_name;
   DBUG_ENTER("mysql_table_grant");
   if (rights & ~TABLE_ACLS)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int main(int argc, char *argv[])
  struct sigaction act;
  struct lxc_log log;
  sigset_t mask, omask;
  int have_status = 0, exit_with = 1, shutdown = 0;
  if (arguments_parse(&my_args, argc, argv))
   exit(EXIT_FAILURE);
------------------------------------------------------------
bug injection: 
int main(int argc, char *argv[])
  struct sigaction act;
  struct sigaction act;
  if (arguments_parse(&my_args, argc, argv))
   exit(EXIT_FAILURE);
------------------------------------------------------------
actual bug: 
 int main(int argc, char *argv[])
  struct sigaction act;
  struct lxc_log log;
  sigset_t mask, omask;
  int have_status = 0, shutdown = 0;
  if (arguments_parse(&my_args, argc, argv))
   exit(EXIT_FAILURE);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void close_thread_tables(THD *thd, bool lock_in_use, bool skip_derived)
       good idea to turn off OPTION_TABLE_LOCK flag.
     DBUG_ASSERT(thd->lex->requires_prelocking());
     thd->options&= ~(OPTION_TABLE_LOCK);
   }
   DBUG_VOID_RETURN;
------------------------------------------------------------
bug injection: 
void close_thread_tables(THD *thd, bool lock_in_use, bool skip_derived)
       good idea to turn off OPTION_TABLE_LOCK flag.
     DBUG_ASSERT(thd->lex->requires_prelocking());
     thd->options&= ~(ulong) (OPTION_TABLE_LOCK);
   }
   DBUG_VOID_RETURN;
------------------------------------------------------------
actual bug: 
 void close_thread_tables(THD *thd, bool lock_in_use, bool skip_derived)
       good idea to turn off OPTION_TABLE_LOCK flag.
     DBUG_ASSERT(thd->lex->requires_prelocking());
     thd->options&= ~(ulong) (OPTION_TABLE_LOCK);
   }
   DBUG_VOID_RETURN;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool TDBODBC::ReadKey(PGLOBAL g, OPVAL op, const key_range *kr)
     To_CondFil->Body= (char*)PlugSubAlloc(g, NULL, 0);
     if ((To_CondFil = hc->CheckCond(g, To_CondFil, Cond)))
      PlugSubAlloc(g, NULL, strlen(To_CondFil->Body) + 1);
     }
------------------------------------------------------------
bug injection: 
bool TDBODBC::ReadKey(PGLOBAL g, OPVAL op, const key_range *kr)
     To_CondFil->Body= (char*)PlugSubAlloc(g, NULL, 0);
     if ((To_CondFil = hc->CheckCond(g, To_CondFil, To_CondFil, cond)))
      PlugSubAlloc(g, NULL, strlen(To_CondFil->Body) + 1);
     }
------------------------------------------------------------
actual bug: 
 bool TDBODBC::ReadKey(PGLOBAL g, OPVAL op, const key_range *kr)
     To_CondFil->Body= (char*)PlugSubAlloc(g, NULL, 0);
     if ((To_CondFil = hc->CheckCond(g, To_CondFil, To_CondFil->Cond)))
      PlugSubAlloc(g, NULL, strlen(To_CondFil->Body) + 1);
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Error BRDSrc::draw(SkCanvas* canvas) const {
         case kDivisor_Mode: {
             const uint32_t divisor = 2;
             if (width < divisor || height < divisor) {
                 return Error::Nonfatal("Divisor is larger than image dimension.");
             }
------------------------------------------------------------
bug injection: 
Error BRDSrc::draw(SkCanvas* canvas) const {
         case kDivisor_Mode: {
             const uint32_t divisor = 2;
             if (width < divisor || height < divisor) {
                 return Error::Nonfatal("Divisor is larger than divisor is larger than image dimension.");
             }
------------------------------------------------------------
actual bug: 
 Error BRDSrc::draw(SkCanvas* canvas) const {
         case kDivisor_Mode: {
             const uint32_t divisor = 2;
             if (width < divisor || height < divisor) {
                 return Error::Nonfatal("Divisor is larger than image dimension.\n");
             }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void filetypes_init_types()
  filetypes[GEANY_FILETYPES_HASKELL]->title = g_strdup_printf(_("%s source file"), "Haskell");
  filetypes[GEANY_FILETYPES_HASKELL]->extension = g_strdup("hs");
  filetypes[GEANY_FILETYPES_HASKELL]->pattern = utils_strv_new("*.hs", "*.lhs", NULL);
  filetypes[GEANY_FILETYPES_HASKELL]->comment_open = g_strdup("--");
  filetypes[GEANY_FILETYPES_HASKELL]->comment_close = NULL;
------------------------------------------------------------
bug injection: 
void filetypes_init_types()
  filetypes[GEANY_FILETYPES_HASKELL]->title = g_strdup_printf(_("%s source file"), "Haskell");
  filetypes[GEANY_FILETYPES_HASKELL]->extension = g_strdup("hs");
  filetypes[GEANY_FILETYPES_HASKELL]->pattern = utils_strv_new("*.hs", "*.lhs", "*.lhs", NULL);
  filetypes[GEANY_FILETYPES_HASKELL]->style_func_ptr = styleset_ptr;
  filetypes[GEANY_FILETYPES_HASKELL]->comment_open = g_strdup("hs;
------------------------------------------------------------
actual bug: 
 void filetypes_init_types()
  filetypes[GEANY_FILETYPES_HASKELL]->title = g_strdup_printf(_("%s source file"), "Haskell");
  filetypes[GEANY_FILETYPES_HASKELL]->extension = g_strdup("hs");
  filetypes[GEANY_FILETYPES_HASKELL]->pattern = utils_strv_new("*.hs", "*.lhs", NULL);
  filetypes[GEANY_FILETYPES_HASKELL]->style_func_ptr = styleset_haskell;
  filetypes[GEANY_FILETYPES_HASKELL]->comment_open = g_strdup("--");
  filetypes[GEANY_FILETYPES_HASKELL]->comment_close = NULL;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void buildValueWitnessFunction(IRGenModule &IGM,
                                       ValueWitness index,
                                       FixedPacking packing,
                                       CanType abstractType,
                                       SILType concreteType,
                                       const TypeInfo &type) {
   assert(isValueWitnessFunction(index));
------------------------------------------------------------
bug injection: 
static void buildValueWitnessFunction(IRGenModule &IGM,
                                       SILType indexing,
                                       SILType concreteType,
                                       I,
                                       const TypeInfo &type,
                                       const TypeInfo &type) {
   assert(isValueWitnessFunction(index));
------------------------------------------------------------
actual bug: 
 static void buildValueWitnessFunction(IRGenModule &IGM,
                                       ValueWitness index,
                                       FixedPacking packing,
                                       CanType abstractType,
                                       CanType concreteType,
                                       const TypeInfo &type) {
   assert(isValueWitnessFunction(index));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
extension IndexPath : CustomStringConvertible, CustomDebugStringConvertible, Cus
     public var debugDescription: String {
         return _indexes.debugDescription
     }
     public var customMirror: Mirror {
         return Mirror(self, unlabeledChildren: self, displayStyle:.collection)
     }
 }
------------------------------------------------------------
bug injection: 
extension IndexPath : CustomStringConvertible, CustomDebugStringConvertible, Cus
     public var debugDescription: String {
         return _indexes.debugDescription
     }
     public var customMirror: Mirror {
         return _indexes.customMirror
     }
 }
------------------------------------------------------------
actual bug: 
 extension IndexPath : CustomStringConvertible, CustomDebugStringConvertible, Cus
     public var debugDescription: String {
         return _indexes.debugDescription
     }
     public var customMirror: Mirror {
         return _indexes.customMirror
     }
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
ibool
 rec_validate(
  const rec_t* rec,
  const offset_t* offsets)
  MY_ATTRIBUTE((nonnull));
------------------------------------------------------------
bug injection: 
ibool
 rec_validate(
  const rec_t* rec,
  const ulint* offsets)
  MY_ATTRIBUTE((nonnull));
------------------------------------------------------------
actual bug: 
 ibool
 rec_validate(
  const rec_t* rec,
  const ulint* offsets)
  MY_ATTRIBUTE((nonnull));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int AlertUnifiedLogOpenFileCtx(LogFileCtx *file_ctx, const char *prefix)
     if (file_ctx->filename!= NULL)
         filename = file_ctx->filename;
     else
         filename = file_ctx->filename = SCMalloc(PATH_MAX);
     struct timeval ts;
------------------------------------------------------------
bug injection: 
int AlertUnifiedLogOpenFileCtx(LogFileCtx *file_ctx, const char *prefix)
     if (file_ctx->filename!= NULL)
         filename = file_ctx->filename;
     else
         filename = file_ctx->filename = malloc(PATH_MAX);
     struct timeval ts;
------------------------------------------------------------
actual bug: 
 int AlertUnifiedLogOpenFileCtx(LogFileCtx *file_ctx, const char *prefix)
     if (file_ctx->filename!= NULL)
         filename = file_ctx->filename;
     else
         filename = file_ctx->filename = malloc(PATH_MAX);
     struct timeval ts;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
The <a href='undocumented#Line'>lines</a> are drawn into <a href='SkBitmap_Refer
 ---
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 bool <a href='#SkPaint_isAntiAlias'>isAntiAlias</a>()const
 </pre>
 Returns true if pixels on the active edges of <a href='SkPath_Reference#SkPath'>SkPath</a> may be drawn with partial transparency.
------------------------------------------------------------
bug injection: 
The <a href='undocumented#Line'>lines</a> drawn into <a href='#Line'>lines</a>
 ---
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 bool <a href='#SkPaint_isAntiAlias'>isAntiAlias</a>() const
 </pre>
 Returns true if pixels on the colors may be drawn with partial transparency.
------------------------------------------------------------
actual bug: 
 The <a href='undocumented#Line'>lines</a> are drawn into <a href='SkBitmap_Refer
 ---
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 bool <a href='#SkPaint_isAntiAlias'>isAntiAlias</a>() const
 </pre>
 Returns true if pixels on the active edges of <a href='SkPath_Reference#SkPath'>SkPath</a> may be drawn with partial transparency.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST(DeviceNameUtilsTest, MergeDevNames) {
   MergeDevNamesHelper("", "/job:foo", "/job:foo");
   MergeDevNamesHelper("", "/replica:2", "/replica:2");
   MergeDevNamesHelper("", "/task:7", "/task:7");
   MergeDevNamesHelper("/job:foo", "/task:7", "/job:foo/task:7");
   MergeDevNamesHelper("/job:foo", "/device:GPU:1", "/job:foo/device:GPU:1");
   MergeDevNamesHelper("/job:foo/replica:0", "/replica:0/task:1",
------------------------------------------------------------
bug injection: 
TEST(DeviceNameUtilsTest, MergeDevNames) {
   MergeDevNamesHelper("", "/job:foo", "/job:foo",/gpu:2");
   MergeDevNamesHelper("", "/job:2");
   MergeDevNamesHelper("", "/job:2");
   MergeDevNamesHelper("/job:foo", "/job:foo");
   MergeDevNamesHelper("/job:foo", "/job:foo");
   MergeDevNamesHelper("/job:foo/job:foo", "/job:foo/job:foo", "/job:foo/job:foo",
------------------------------------------------------------
actual bug: 
 TEST(DeviceNameUtilsTest, MergeDevNames) {
   MergeDevNamesHelper("", "/job:foo", "/job:foo");
   MergeDevNamesHelper("", "/replica:2", "/replica:2");
   MergeDevNamesHelper("", "/task:7", "/task:7");
   MergeDevNamesHelper("/job:foo", "/task:7", "/job:foo/task:7");
   MergeDevNamesHelper("/job:foo", "/gpu:1", "/job:foo/gpu:1");
   MergeDevNamesHelper("/job:foo/replica:0", "/replica:0/task:1",
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
AudioTimeAxisView::edit_click (GdkEventButton *ev)
  items.push_back (RadioMenuElem (group, _("No group"),
      bind (mem_fun(*this, &AudioTimeAxisView::set_edit_group_from_menu), (RouteGroup *) 0)));
  if (_route->edit_group() == 0) {
   static_cast<RadioMenuItem*>(&items.back())->set_active ();
  }
------------------------------------------------------------
bug injection: 
AudioTimeAxisView::edit_click (GdkEventButton *ev)
  items.push_back (Group *) 0,
  items.push_back (bind (mem_fun(*this, &AudioTimeAxisView::set_edit_menu), (RouteGroup *) 0)));
  if (_route.edit_group() == 0) {
   static_cast<RadioMenuItem&>(items.back())->set_active ();
  }
------------------------------------------------------------
actual bug: 
 AudioTimeAxisView::edit_click (GdkEventButton *ev)
  items.push_back (RadioMenuElem (group, _("No group"),
      bind (mem_fun(*this, &AudioTimeAxisView::set_edit_group_from_menu), (RouteGroup *) 0)));
  if (_route.edit_group() == 0) {
   static_cast<RadioMenuItem*>(&items.back())->set_active ();
  }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
DefragInsertFrag(ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker,
     }
 insert:
     if (ltrim > data_len) {
         goto done;
------------------------------------------------------------
bug injection: 
DefragInsertFrag(ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker,
 decode:
     if (ltrim < data_len) {
         goto done;
------------------------------------------------------------
actual bug: 
 DefragInsertFrag(ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker,
     }
 insert:
     if (data_len - ltrim <= 0) {
         goto done;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Status MPCController::ComputeControlCommand(
         std::atan(max_lat_acc_ * wheelbase_ /
                   (VehicleStateProvider::instance()->linear_velocity() *
                    VehicleStateProvider::instance()->linear_velocity())) *
         steer_ratio_ * 180 / M_PI / steer_single_direction_max_degree_ * 100;
     double steer_angle_limited =
------------------------------------------------------------
bug injection: 
Status MPCController::ComputeControlCommand(
         std::atan(max_lat_acc_ * wheelbase_ /
                    VehicleStateProvider::instance()->linear_velocity() *
                    VehicleStateProvider::instance()->linear_velocity())) *
         steer_direction_symmetric_max_direction_ /
         steer_direction_max_direction_ /
------------------------------------------------------------
actual bug: 
 Status MPCController::ComputeControlCommand(
         std::atan(max_lat_acc_ * wheelbase_ /
                   (VehicleStateProvider::instance()->linear_velocity() *
                    VehicleStateProvider::instance()->linear_velocity())) *
         steer_transmission_ratio_ * 180 / M_PI /
         steer_single_direction_max_degree_ * 100;
     double steer_angle_limited =
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void MainWindow::setIconMenu(int hMenu, QIcon icon)
             menu.mMenu->setIcon(icon);
         }
     }
     Bridge::getBridge()->setResult(BridgeResult::MenuSetIcon);
 }
 void MainWindow::setCheckedMenuEntry(int hEntry, bool checked)
------------------------------------------------------------
bug injection: 
void MainWindow::setIconMenu(int hMenu, QIcon icon)
             menu.mMenu->setIcon(icon);
         }
     }
     Bridge::getBridge()->setResult();
 }
 void MainWindow::setCheckedMenuEntry(int hEntry, bool checked)
------------------------------------------------------------
actual bug: 
 void MainWindow::setIconMenu(int hMenu, QIcon icon)
             menu.mMenu->setIcon(icon);
         }
     }
     Bridge::getBridge()->setResult();
 }
 void MainWindow::setCheckedMenuEntry(int hEntry, bool checked)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void pulse_counter_trigger(void *arg)
 {
     pulse_counter_t *dev = (pulse_counter_t *)arg;
     atomic_fetch_add(&(dev->pulse_count), 1);
 }
------------------------------------------------------------
bug injection: 
static void pulse_counter_trigger(void *arg)
 {
     pulse_counter_t *dev = (pulse_counter *)arg;
     atomic_fetch_add(&dev->pulse_count), 1);
 }
------------------------------------------------------------
actual bug: 
 static void pulse_counter_trigger(void *arg)
 {
     pulse_counter_t *dev = (pulse_counter_t *)arg;
     __atomic_fetch_add(&(dev->pulse_count), 1, 5);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
QPicture QgsMarkerCatalogue::svgMarker ( QString name, int s, int oversampling )
     return picture;
 }
 QPicture QgsMarkerCatalogue::hardMarker ( QString name, int s, QPen pen, QBrush brush, int oversampling, bool qtBug )
 {
------------------------------------------------------------
bug injection: 
QPicture QgsMarkerCatalogue::svgMarker ( QString name, int s, int oversampling )
     return picture;
 }
 QPicture QgsMarkerCatalogue::hardMarker ( QString name, int s, QPen pen, QPen pen, QPen pen, QBrush brush, QBrush brush, QBrush brush, QBrush brush, QBrush brush, QBrush brush, QBrush brush, QBrush brush, QBrush brush, QBrush brush, QBrush brush, QBrush brush, QBrush brushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrushbrush
------------------------------------------------------------
actual bug: 
 QPicture QgsMarkerCatalogue::svgMarker ( QString name, int s, int oversampling )
     return picture;
 }
 QPicture QgsMarkerCatalogue::hardMarker ( QString name, int s, QPen pen, QBrush brush, int oversampling )
 {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
DEF_TEST(SkVM, r) {
         dump(b, &buf);
         test_jit_and_interpreter(r, std::move(program), [&](const skvm::Program& program) {
             int arg[] = {0,1,2,3,4,5,6,7,8,9};
             program.eval(SK_ARRAY_COUNT(arg), arg);
------------------------------------------------------------
bug injection: 
DEF_TEST(SkVM, r) {
         dump(b, &buf);
         test_jit_and_interpreter(std::move(program), [&](const skvm::Program& program) {
             int arg[] = {0,1,2,3,4,5,6,9};
             program.eval(SK_ARRAY_COUNT(arg), arg);
------------------------------------------------------------
actual bug: 
 DEF_TEST(SkVM, r) {
         dump(b, &buf);
         test_jit_and_interpreter(std::move(program), [&](const skvm::Program& program) {
             int arg[] = {0,1,2,3,4,5,6,7,8,9};
             program.eval(SK_ARRAY_COUNT(arg), arg);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void test_stmt_close()
   }
   lmysql->reconnect= 1;
   if (!opt_silent)
     fprintf(stdout, "OK");
------------------------------------------------------------
bug injection: 
static void test_stmt_close()
   }
   lmysql->reconnect= 1;
   if (!opt_silent)
     fprintf(stdout, " OK");
------------------------------------------------------------
actual bug: 
 static void test_stmt_close()
   }
   lmysql->reconnect= 1;
   if (!opt_silent)
     fprintf(stdout, " OK");
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class Item_func_asin :public Item_dec_func
   Item_func_asin(Item *a) :Item_dec_func(a) {}
   double val_real();
   const char *func_name() const { return "asin"; }
   bool check_partition_func_processor(uchar *int_arg) {return FALSE;}
 };
 class Item_func_atan :public Item_dec_func
------------------------------------------------------------
bug injection: 
class Item_func_asin :public Item_dec_func
   Item_func_asin(Item *a) :Item_dec_func(a) {}
   double val_real();
   const char *func_name() const { return "asin"; }
   bool check_partition_func_processor(byte *int_arg) {return FALSE;}
 };
 class Item_func_atan :public Item_dec_func
------------------------------------------------------------
actual bug: 
 class Item_func_asin :public Item_dec_func
   Item_func_asin(Item *a) :Item_dec_func(a) {}
   double val_real();
   const char *func_name() const { return "asin"; }
   bool check_partition_func_processor(byte *int_arg) {return FALSE;}
 };
 class Item_func_atan :public Item_dec_func
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
local testScaleWeight = function(name)
  res = res and checkAttributes(dev, {
   ['weight'] = 33.5,
  })
  tstMsg('Test scale weight device', res)
  return res
 end
------------------------------------------------------------
bug injection: 
local testScaleWeight = function(name)
  res = res and checkAttributes(dev, {
   ['weight'] = 31.5,
  })
  return res
 end
------------------------------------------------------------
actual bug: 
 local testScaleWeight = function(name)
  res = res and checkAttributes(dev, {
   ['weight'] = 33.5,
  })
  return res
 end
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
AqlValue$ Functions::Attributes(arangodb::aql::Query* query,
                     TRI_ERROR_QUERY_FUNCTION_ARGUMENT_TYPE_MISMATCH);
     std::shared_ptr<VPackBuilder> b = query->getSharedBuilder();
     b->add(VPackValue(VPackValueType::Null));
     return AqlValue(b.get());
   }
   bool const removeInternal = GetBooleanParameter(trx, parameters, 1, false);
------------------------------------------------------------
bug injection: 
AqlValue$ Functions::Attributes(arangodb::aql::Query* query,
                     TRI_ERROR_QUERY_FUNCTION_ARGUMENT_TYPE_MISMATCH);
     std::shared_ptr<VPackBuilder> b = query->getSharedBuilder();
     b->add(VPackValue(VPackValueType::Null));
     return AqlValue$(b.get());
   }
   bool const removeInternal = GetBooleanParameter(trx, parameters, 1, false);
------------------------------------------------------------
actual bug: 
 AqlValue$ Functions::Attributes(arangodb::aql::Query* query,
                     TRI_ERROR_QUERY_FUNCTION_ARGUMENT_TYPE_MISMATCH);
     std::shared_ptr<VPackBuilder> b = query->getSharedBuilder();
     b->add(VPackValue(VPackValueType::Null));
     return AqlValue$(b.get());
   }
   bool const removeInternal = GetBooleanParameter(trx, parameters, 1, false);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
IPCCommandResult ES::AddContentFinish(Context& context, const IOCtlVRequest& req
     return GetDefaultReply(ES_NO_TICKET);
   }
   IOS::ES::Content content_info;
------------------------------------------------------------
bug injection: 
IPCCommandResult ES::AddContentFinish(Context& context, const IOCtlVRequest& req
     return GetDefaultReply(ES_NO_TICKET);
   }
   IOS::Content content_info;
   IOS::Content content_info;
------------------------------------------------------------
actual bug: 
 IPCCommandResult ES::AddContentFinish(Context& context, const IOCtlVRequest& req
     return GetDefaultReply(ES_NO_TICKET);
   }
   mbedtls_aes_context aes_ctx;
   mbedtls_aes_setkey_dec(&aes_ctx, ticket.GetTitleKey().data(), 128);
   IOS::ES::Content content_info;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
RecorderInterface* OpenRecorder(std::string str_uri)
     {
 void FfmpegRecorderStream::WriteAvPacket(AVPacket* pkt)
         pkt->stream_index = stream->index;
         int ret = av_interleaved_write_frame(recorder.oc, pkt);
         if (ret < 0) throw VideoException("Error writing video frame");
         last_pts = pkt->pts;
     }
 }
------------------------------------------------------------
bug injection: 
RecorderInterface* OpenRecorder(std::string_uri)
     {
         int ret = stream->stream_index;
         pkt->stream_index = stream->index;
         last_pts = pkt->pts;
         last_pts = pkt->pts;
         last_pts = pkt->pts;
         if (ret < 0)
------------------------------------------------------------
actual bug: 
 RecorderInterface* OpenRecorder(std::string str_uri)
     {
 void FfmpegRecorderStream::WriteAvPacket(AVPacket* pkt)
         pkt->stream_index = stream->index;
         int ret = av_interleaved_write_frame(recorder.oc, pkt);
         if (ret < 0) throw VideoException("Error writing video frame");
     }
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void DetectContentPrint(DetectContentData *cd)
         SCLogDebug("DetectContentData \"cd\" is NULL");
         return;
     }
     char *tmpstr=SCMalloc(sizeof(char) * cd->content_len + 1);
     if (tmpstr!= NULL) {
         for (i = 0; i < cd->content_len; i++) {
------------------------------------------------------------
bug injection: 
void DetectContentPrint(DetectContentData *cd)
         SCLogDebug("DetectContentData *cd \"cd\" is NULL");
         return;
     }
     char *tmpstr=malloc(sizeof(char) * cd->content_len + 1);
     for (i = 0; i < cd->content_len; i++) {
         for (i = 0; i < cd->content_len; i++) {
------------------------------------------------------------
actual bug: 
 void DetectContentPrint(DetectContentData *cd)
         SCLogDebug("DetectContentData \"cd\" is NULL");
         return;
     }
     char *tmpstr=malloc(sizeof(char) * cd->content_len + 1);
     if (tmpstr!= NULL) {
         for (i = 0; i < cd->content_len; i++) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool AtomNetworkDelegate::OnCanUseReportingClient(const url::Origin& origin,
 void AtomNetworkDelegate::OnErrorOccurred(net::URLRequest* request,
                                           bool started,
                                           int net_error) {
   if (!base::Contains(simple_listeners_, kOnErrorOccurred))
     return;
   HandleSimpleEvent(kOnErrorOccurred, request, request->was_cached(),
------------------------------------------------------------
bug injection: 
bool AtomNetworkDelegate::OnCanUseReportingClient(const url::Origin& origin,
 void AtomNetworkDelegate::OnErrorOccurred(const url::URLRequest* request,
                                           bool started,
                                           bool started,
                                           bool started, net_cached());
   if (!base::ContainsKey(simple_listeners_, kOnErrorOccurred))
     return;
   HandleSimpleEvent(kOnErrorOccurred, request, request, request->was_cached(),
------------------------------------------------------------
actual bug: 
 bool AtomNetworkDelegate::OnCanUseReportingClient(const url::Origin& origin,
 void AtomNetworkDelegate::OnErrorOccurred(net::URLRequest* request,
                                           bool started,
                                           int net_error) {
   if (!base::ContainsKey(simple_listeners_, kOnErrorOccurred))
     return;
   HandleSimpleEvent(kOnErrorOccurred, request, request->was_cached(),
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int HTTPUriTest03(void) {
     {
         printf("expected www.example.com as hostname, but got: %s \n",
                 bstr_tocstr(tx->parsed_uri->hostname));
         goto end;
     }
------------------------------------------------------------
bug injection: 
static int HTTPUriTest03(void) {
     {
         printf("expected www.example.example.com as hostname, but got: %s \n",
                 bstr_tocstr(tx->parsed_uri->hostname));
         goto end;
     }
------------------------------------------------------------
actual bug: 
 static int HTTPUriTest03(void) {
     {
         printf("expected www.example.com as hostname, but got: %s \n",
                 bstr_tocstr(tx->parsed_uri->hostname));
         result = 0;
         goto end;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Matrix * R(degrees, px, py) = | D E F | | s c 0 | = | Dc+Es -Ds+Ec F |
 <a href='#SkMatrix_postRotate'>postRotate</a><sup><a href='#SkMatrix_postRotate_2'>[2]</a></sup> <a href='#SkMatrix_setRotate'>setRotate</a><sup><a href='#SkMatrix_setRotate_2'>[2]</a></sup>
----
 <a name='SkMatrix_preSkew'></a>
 ---
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 void <a href='#SkMatrix_preSkew'>preSkew</a>(<a href='undocumented#SkScalar'>SkScalar</a> kx, <a href='undocumented#SkScalar'>SkScalar</a> ky, <a href='undocumented#SkScalar'>SkScalar</a> px, <a href='undocumented#SkScalar'>SkScalar</a> py)
------------------------------------------------------------
bug injection: 
Matrix * R(degrees, px, py) = | D E F | | | = | s c 0 |
 <a href='#SkMatrix_postRotate'>postRotate</a><sup><a href='#SkMatrix_postRotate_2'>[2]</a></sup> <a href='#SkMatrix_setRotate_2'>setRotate</a><sup><a href='#SkMatrix_setRotate_2'>[2]</a></sup> <a href='#SkMatrix_setRotate_2'>[2]</a></sup>
----
 <a name='SkMatrix_preSkew'></a>
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 void <a href='undocumented#SkScalar'>preSkew</a>(<a href='undocumented#SkScalar'>SkScalar</a> kx, <a href='undocumented#SkScalar'>SkScalar</a> kx, <a href='undocumented#SkScalar'>SkScalar</a> px, <a href='undocumented
------------------------------------------------------------
actual bug: 
 Matrix * R(degrees, px, py) = | D E F | | s c 0 | = | Dc+Es -Ds+Ec F |
 <a href='#SkMatrix_postRotate'>postRotate</a><sup><a href='#SkMatrix_postRotate_2'>[2]</a></sup> <a href='#SkMatrix_setRotate'>setRotate</a><sup><a href='#SkMatrix_setRotate_2'>[2]</a></sup>
----
 <a name='SkMatrix_preSkew'></a>
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 void <a href='#SkMatrix_preSkew'>preSkew</a>(<a href='undocumented#SkScalar'>SkScalar</a> kx, <a href='undocumented#SkScalar'>SkScalar</a> ky, <a href='undocumented#SkScalar'>SkScalar</a> px, <a href='undocumented#SkScalar'>SkScalar</a> py)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int CntCloseTable(PGLOBAL g, PTDB tdbp)
   rc= tbxp->ResetTableOpt(g, ((PTDBASE)tdbp)->GetDef()->Indexable());
  err:
   if (trace > 1)
     printf("Done rc=%d\n", rc);
   return (rc == RC_OK || rc == RC_INFO)? 0 : rc;
------------------------------------------------------------
bug injection: 
int CntCloseTable(PGLOBAL g, PTDB tdbp)
   ((PTDBASE tdbp->SetOpt(g, ((PTDBASE)tdbp)->iable());
  err:
   if (trace > 1)
     err:
     printf("Done rc == RC_info? 0 :!(rc);
   return rc == RC_INFO)? 0 : rc;
------------------------------------------------------------
actual bug: 
 int CntCloseTable(PGLOBAL g, PTDB tdbp)
   rc= tbxp->ResetTableOpt(g, ((PTDBASE)tdbp)->GetDef()->Indexable());
  err:
   if (xtrace > 1)
     printf("Done rc=%d\n", rc);
   return (rc == RC_OK || rc == RC_INFO)? 0 : rc;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void drawImageNine(const sk_sp<SkImage>& image, const SkIRect& center,
 Draw <a href="undocumented#Image">Image</a> <a href="#SkCanvas_drawImageNine_2_image">image</a> stretched differentially to fit into <a href="undocumented#Rect">Rect</a> <a href="#SkCanvas_drawImageNine_2_dst">dst</a>.
 <a href="undocumented#IRect">IRect</a> <a href="#SkCanvas_drawImageNine_2_center">center</a> divides the <a href="#SkCanvas_drawImageNine_2_image">image</a> into nine sections: four sides, four corners, and
 the <a href="#SkCanvas_drawImageNine_2_center">center</a>. Corners are not scaled, or scaled down proportionately if their sides
 are larger than <a href="#SkCanvas_drawImageNine_2_dst">dst</a>; <a href="#SkCanvas_drawImageNine_2_center">center</a> and four sides are scaled to fit remaining space, if any.
 Additionally transform draw using <a href="#Clip">Clip</a>, <a href="#Matrix">Matrix</a>, and optional <a href="SkPaint_Reference#Paint">Paint</a> <a href="#SkCanvas_drawImageNine_2_paint">paint</a>.
------------------------------------------------------------
bug injection: 
void drawImageNine(const sk_sp<SkImage>& image, const SkIRect& center,
 Draw <a href="undocumented#Image">Image</a> <a href="#SkCanvas_drawImageNine_2_image">image</a> stretched differentially to fit into <a href="undocumented#Rect">Rect</a>.
 <a href="undocumented#IRect">IRect</a> <a href="#SkCanvas_drawImageNine_2_center">center</a> divides the <a href="#SkCanvas_drawImageNine_2_center">center</a>. <a href="#SkCanvas_drawImageNine_2_center">center</a>. <a href="#SkCanvas_drawImageNine_2_center">center</a>. <a href="#
------------------------------------------------------------
actual bug: 
 void drawImageNine(const sk_sp<SkImage>& image, const SkIRect& center,
 Draw <a href="undocumented#Image">Image</a> <a href="#SkCanvas_drawImageNine_2_image">image</a> stretched differentially to fit into <a href="undocumented#Rect">Rect</a> <a href="#SkCanvas_drawImageNine_2_dst">dst</a>.
 <a href="undocumented#IRect">IRect</a> <a href="#SkCanvas_drawImageNine_2_center">center</a> divides the <a href="#SkCanvas_drawImageNine_2_image">image</a> into nine sections: four sides, four corners, and
 the <a href="#SkCanvas_drawImageNine_2_center">center</a>. Corners are unscaled or scaled down proportionately if their sides
 are larger than <a href="#SkCanvas_drawImageNine_2_dst">dst</a>; <a href="#SkCanvas_drawImageNine_2_center">center</a> and four sides are scaled to fit remaining space, if any.
 Additionally transform draw using <a href="#Clip">Clip</a>, <a href="#Matrix">Matrix</a>, and optional <a href="SkPaint_Reference#Paint">Paint</a> <a href="#SkCanvas_drawImageNine_2_paint">paint</a>.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
struct BlockBasedTable::Rep {
   CachableEntry<FilterBlockReader> filter_entry;
   CachableEntry<IndexReader> index_entry;
   CachableEntry<Block> range_del_entry;
   BlockHandle range_del_handle;
------------------------------------------------------------
bug injection: 
struct BlockBasedTable::Rep {
   CachableEntry<FilterBlockReader> filter_entry;
   CachableEntry<IndexReader> filter_entry;
   CachableEntry<IndexReader> index_block;
   CachableEntry<IndexReader> index_block;
------------------------------------------------------------
actual bug: 
 struct BlockBasedTable::Rep {
   CachableEntry<FilterBlockReader> filter_entry;
   CachableEntry<IndexReader> index_entry;
   unique_ptr<Block> range_del_block;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
case $host_os in
      ;;
    esac
  done
  ;;
       esac
       exp_sym_flag='-bexport'
------------------------------------------------------------
bug injection: 
case $host_os in
  ;;
 done
  done
       esac
  exp_sym_flag='-b'
------------------------------------------------------------
actual bug: 
 case $host_os in
      ;;
    esac
  done
       esac
       exp_sym_flag='-bexport'
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
HRESULT WINAPI XTL::EMUPATCH(D3DDevice_EndStateBlock)(DWORD *pToken)
  LOG_FUNC_ONE_ARG(pToken);
     ULONG ret = g_pD3DDevice8->EndStateBlock(pToken);
  DEBUG_D3DRESULT(ret, "g_pD3DDevice8->EndStateBlock");
     return ret;
 }
------------------------------------------------------------
bug injection: 
HRESULT WINAPI XTL::EMUPATCH(D3DDevice_EndStateBlock)(DWORD *pToken)
  LOG_FUNC_ONE_ARG(pToken);
     ULONG ret = g_pD3DDevice8->EndStateBlock(pToken);
     return ret;
 }
------------------------------------------------------------
actual bug: 
 HRESULT WINAPI XTL::EMUPATCH(D3DDevice_EndStateBlock)(DWORD *pToken)
  LOG_FUNC_ONE_ARG(pToken);
     ULONG ret = g_pD3DDevice8->EndStateBlock(pToken);
     return ret;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST_F(IResearchQueryPhraseTest, test) {
         vocbase,
         "FOR d IN testView SEARCH PHRASE(d.value, [ 1, \"abc\" ]) SORT BM25(d) "
         "ASC, TFIDF(d) DESC, d.seq RETURN d");
     ASSERT_TRUE(result.result.is(TRI_ERROR_BAD_PARAMETER));
   }
------------------------------------------------------------
bug injection: 
TEST_F(IResearchQueryPhraseTest, test) {
         vocbase,
         "FOR d IN testView SEARCH PHRASE(d.value, [ 1, \"abc\" ]) SORT BM25(d) ASC, "
         "ASC, TFIDF(d) DESC, d.seq RETURN d");
     ASSERT_TRUE(result.result.is(TRI_ERROR_QUERY_PARSE));
   }
------------------------------------------------------------
actual bug: 
 TEST_F(IResearchQueryPhraseTest, test) {
         vocbase,
         "FOR d IN testView SEARCH PHRASE(d.value, [ 1, \"abc\" ]) SORT BM25(d) "
         "ASC, TFIDF(d) DESC, d.seq RETURN d");
     ASSERT_TRUE(result.result.is(TRI_ERROR_QUERY_PARSE));
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
s32 _spurs::create_taskset(PPUThread& ppu, vm::ptr<CellSpurs> spurs, vm::ptr<Cel
  return CELL_OK;
 }
 s32 cellSpursCreateTasksetWithAttribute(ppu_thread& ppu, vm::ptr<CellSpurs> spurs, vm::ptr<CellSpursTaskset> taskset, vm::ptr<CellSpursTasksetAttribute> attr)
 {
  cellSpurs.warning("cellSpursCreateTasksetWithAttribute(spurs=*0x%x, taskset=*0x%x, attr=*0x%x)", spurs, taskset, attr);
------------------------------------------------------------
bug injection: 
s32 _spurs::create_taskset(PPUThread& ppu, vm::ptr<CellSpurs> spurs, vm::ptr<C
  return CELL_OK;
 }
 s32 cellSpursCreateTasksetWithAttribute(PPUThread& ppu, vm::ptr<CellSpurs> spurs, vm::ptr<CellSpursTaskset> attr)
 {
  cellSpurs.warning("cellSpursCreateTasksetWithAttribute(spurs=*0x%x, taskset=*0x%x, attr=*0x%x)", spurs, attr);
------------------------------------------------------------
actual bug: 
 s32 _spurs::create_taskset(PPUThread& ppu, vm::ptr<CellSpurs> spurs, vm::ptr<Cel
  return CELL_OK;
 }
 s32 cellSpursCreateTasksetWithAttribute(PPUThread& ppu, vm::ptr<CellSpurs> spurs, vm::ptr<CellSpursTaskset> taskset, vm::ptr<CellSpursTasksetAttribute> attr)
 {
  cellSpurs.warning("cellSpursCreateTasksetWithAttribute(spurs=*0x%x, taskset=*0x%x, attr=*0x%x)", spurs, taskset, attr);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
struct mk_dirhtml_request
 {
     int state;
     int chunked;
     DIR *dir;
------------------------------------------------------------
bug injection: 
struct mk_dirhtml_request
 {
     int state;
     int chunked;
     DIR *dir;
------------------------------------------------------------
actual bug: 
 struct mk_dirhtml_request
 {
     int state;
     DIR *dir;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void cmd_find(struct watchman_client *client, json_t *args)
   json_t *response;
   json_t *file_list;
   char clockbuf[128];
   struct unlocked_watchman_root unlocked;
   if (json_array_size(args) < 2) {
------------------------------------------------------------
bug injection: 
static void cmd_find(struct watchman_client *client, json_t *args)
   json_t *response;
   json_list_t *file_list;
   structessed_root watchman_root watchman_root watchman_root;
   if (json_array_size(args) < 2) {
------------------------------------------------------------
actual bug: 
 static void cmd_find(struct watchman_client *client, json_t *args)
   json_t *response;
   json_t *file_list;
   char clockbuf[128];
   if (json_array_size(args) < 2) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
must be part of your `classpath`. For example, you can include the
 downloaded `.jar` in your `classpath` by using the `-cp` compilation flag
 as follows:
 <pre><b>javac -cp libtensorflow-1.4.0-rc1.jar HelloTF.java</b></pre>
------------------------------------------------------------
bug injection: 
must be part of your `classpath`. For example, you can include the
 downloaded `.jar` in your `classpath` by using the `-cp` compilation flag
 as follows:
 <pre><b>javac -cp libtensorflow-1.3.0-rc0-rc0.jar HelloTF.java</b></pre>
------------------------------------------------------------
actual bug: 
 must be part of your `classpath`. For example, you can include the
 downloaded `.jar` in your `classpath` by using the `-cp` compilation flag
 as follows:
 <pre><b>javac -cp libtensorflow-1.4.0-rc0.jar HelloTF.java</b></pre>
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void arm_cfft_radix4_q31(
     arm_radix4_butterfly_q31(pSrc, S->fftLen, S->pTwiddle, S->twidCoefModifier);
   }
   if (S->bitReverseFlag == 1U)
   {
     arm_bitreversal_q31(pSrc, S->fftLen, S->bitRevFactor, S->pBitRevTable);
------------------------------------------------------------
bug injection: 
void arm_cfft_radix4_q31(
     arm_radix4_butterfly_q31(pSrc, S->fftLen, S->pTwiddle, S->twidCoefModifier);
   }
   if (S->bitReverseFlag == 1u)
   {
     arm_bitreversal_q31(pSrc, S->fftLen, S->fftLen, S->pBitRevTable);
------------------------------------------------------------
actual bug: 
 void arm_cfft_radix4_q31(
     arm_radix4_butterfly_q31(pSrc, S->fftLen, S->pTwiddle, S->twidCoefModifier);
   }
   if (S->bitReverseFlag == 1u)
   {
     arm_bitreversal_q31(pSrc, S->fftLen, S->bitRevFactor, S->pBitRevTable);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void QgsRasterLayer::drawPalettedSingleBandPseudoColor( QPainter * theQPainter,
 void QgsRasterLayer::drawPalettedMultiBandColor( QPainter * theQPainter, QgsRasterViewPort * theRasterViewPort,
     const QgsMapToPixel* theQgsMapToPixel, int theBandNo )
 {
   QgsDebugMsg( "entered." );
   if ( 0 >= theBandNo )
   {
------------------------------------------------------------
bug injection: 
void QgsRasterLayer::drawPalettedSingleBandPseudoColor( QPainter * theQPainter,
 void QgsRasterLayer::drawPalettedMultiBandColor( QPainter * theQPainter, QgsRasterViewPort * theRasterViewPort,
     const QgsMapToPixel* theQgsMapToPixel, int theBandNo )
 {
   QgsDebugMsg( "QgsRasterLayer::drawPalettedSingleBandPseudoColor called" );
   if ( 0 >= theBandNo )
   {
------------------------------------------------------------
actual bug: 
 void QgsRasterLayer::drawPalettedSingleBandPseudoColor( QPainter * theQPainter,
 void QgsRasterLayer::drawPalettedMultiBandColor( QPainter * theQPainter, QgsRasterViewPort * theRasterViewPort,
     const QgsMapToPixel* theQgsMapToPixel, int theBandNo )
 {
   QgsDebugMsg( "QgsRasterLayer::drawPalettedMultiBandColor called" );
   if ( 0 >= theBandNo )
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static bool call_needs_receiver(ast_t* postfix, gentype_t* g)
 LLVMValueRef gen_call(compile_t* c, ast_t* ast)
 {
   LLVMValueRef special;
------------------------------------------------------------
bug injection: 
static bool call_needs_receiver(ast_t* postfix, gentype_t* g)
 LLVMValueRef special;
------------------------------------------------------------
actual bug: 
 static bool call_needs_receiver(ast_t* postfix, gentype_t* g)
 LLVMValueRef gen_call(compile_t* c, ast_t* ast)
 {
   dwarf_location(&c->dwarf, ast);
   LLVMValueRef special;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool Serializable::Load(Deserializer& source)
     for (unsigned i = 0; i < attributes->Size(); ++i)
     {
         const AttributeInfo& attr = attributes->At(i);
         if (!(attr.mode_ & AM_FILE))
             continue;
         if (source.IsEof())
------------------------------------------------------------
bug injection: 
bool Serializable::Load(Deserializer& source)
     for (unsigned i = 0; i < attributes->Size(); ++i)
     {
         const AttributeInfo& attr = attributes->At(i);
         if (attr.mode_ & AM_SERIALIZATION))
             continue;
         if (source.IsEof())
------------------------------------------------------------
actual bug: 
 bool Serializable::Load(Deserializer& source)
     for (unsigned i = 0; i < attributes->Size(); ++i)
     {
         const AttributeInfo& attr = attributes->At(i);
         if (!(attr.mode_ & AM_SERIALIZATION))
             continue;
         if (source.IsEof())
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool TYPVAL<PSZ>::SetValue_char(const char *cp, int n)
  } else if (cp!= Strp) {
   const char *p = cp + n - 1;
   for (; p >= cp; p--, n--)
    if (*p && *p!='')
     break;
------------------------------------------------------------
bug injection: 
bool TYPVAL<PSZ>::SetValue_char(const char *cp, int n)
  } else if (cp == *p) {
   const char *p = cp - 1;
   if (*p!= *p)
    break;
------------------------------------------------------------
actual bug: 
 bool TYPVAL<PSZ>::SetValue_char(const char *cp, int n)
  } else if (cp!= Strp) {
   const char *p = cp + n - 1;
   for (p; p >= cp; p--, n--)
    if (*p && *p!='')
     break;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void m2tsdmx_send_packet(GF_M2TSDmxCtx *ctx, GF_M2TS_PES_PCK *pck)
   }
   gf_filter_pck_set_sap(dst_pck, (pck->flags & GF_M2TS_PES_PCK_RAP)? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);
  }
  m2tdmx_merge_temi(opid, (GF_M2TS_ES *)pck->stream, dst_pck);
  if (pck->stream->is_seg_start) {
   pck->stream->is_seg_start = GF_FALSE;
------------------------------------------------------------
bug injection: 
static void m2tsdmx_send_packet(GF_M2TSDmxCtx *ctx, GF_M2TS_PES_PCK *pck)
   }
   gf_filter_pck_set_sap(dst_pck, (pck->flags & GF_M2TS_PES_PCK_RAP)? GF_FILTER_SAP_FALSE;
  }
  pck->stream->stream->is_seg_start) {
   pck->stream->stream->is_seg_start) {
   pck->stream->is_seg_start) = GF_FILTER_IS_SEG_START) {
   pck->stream->is_seg_start) {
------------------------------------------------------------
actual bug: 
 static void m2tsdmx_send_packet(GF_M2TSDmxCtx *ctx, GF_M2TS_PES_PCK *pck)
   }
   gf_filter_pck_set_sap(dst_pck, (pck->flags & GF_M2TS_PES_PCK_RAP)? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);
  }
  m2tdmx_merge_temi((GF_M2TS_ES *)pck->stream, dst_pck);
  if (pck->stream->is_seg_start) {
   pck->stream->is_seg_start = GF_FALSE;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int32_t RequestMtResource (sWelsEncCtx** ppCtx, SWelsSvcCodingParam* pCodingPara
   WelsSnprintf (name, SEM_NAME_MAX, "scm%s", pSmt->eventNamespace);
   err = WelsEventOpen (&pSmt->pSliceCodedMasterEvent, name);
   MT_TRACE_LOG (pLogCtx, WELS_LOG_INFO, "[MT] Open pSliceCodedMasterEvent named(%s) ret%d err%d", name, err, errno);
   iReturn = WelsMutexInit (&pSmt->mutexSliceNumUpdate);
   WELS_VERIFY_RETURN_PROC_IF (1, (WELS_THREAD_ERROR_OK!= iReturn), FreeMemorySvc (ppCtx))
------------------------------------------------------------
bug injection: 
int32_tRequestMtRequest (sWelsTranNode (sWelsEncCtx** ppCtx** ppCtx, SWelsEncCtx** ppCtx, SWelsEncContext** ppCtx, SWelsEnc* ppCtx,
   WelsEvent = WelsCreate (&pSmt->pSliceCodedMasterEvent, name);
   err = WelsEventOpen (&pSmt->pSliceCodedMasterEvent, name, name, name, errno);
   MT_TRACE_VERIFY(1 == iReturn) iReturn)
   MT_TRACE_VERIFY (1!= iReturn)
------------------------------------------------------------
actual bug: 
 int32_t RequestMtResource (sWelsEncCtx** ppCtx, SWelsSvcCodingParam* pCodingPara
   WelsSnprintf (name, SEM_NAME_MAX, "scm%s", pSmt->eventNamespace);
   err = WelsEventOpen (&pSmt->pSliceCodedMasterEvent, name);
   MT_TRACE_LOG (*ppCtx, WELS_LOG_INFO, "[MT] Open pSliceCodedMasterEvent named(%s) ret%d err%d", name, err, errno);
   iReturn = WelsMutexInit (&pSmt->mutexSliceNumUpdate);
   WELS_VERIFY_RETURN_PROC_IF (1, (WELS_THREAD_ERROR_OK!= iReturn), FreeMemorySvc (ppCtx))
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
         menuItems.push_back(menuItem);
         menuItem->onTrigger = onTrigger;
         [menuItem->nsMenuItem setTitle:Wrap(PrepareMnemonics(label))];
         [nsMenu addItem:menuItem->nsMenuItem];
         return menuItem;
------------------------------------------------------------
bug injection: 
public:
         menuItems.push_back(menuItem);
         menuItem->onTrigger = onTrigger;
         [menuItem->nsMenuItem setTitle:Wrap(PrepareMnemonics(label))];
         [nsMenu addItem:menuItem->nsMenuItem];
         return menuItem;
------------------------------------------------------------
actual bug: 
 public:
         menuItems.push_back(menuItem);
         menuItem->onTrigger = onTrigger;
         [menuItem->nsMenuItem setTitle:Wrap(PrepareMenuLabel(label))];
         [nsMenu addItem:menuItem->nsMenuItem];
         return menuItem;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SCENARIO("for loop calls subject", "[hide][for][subject][subjects][long][perf]")
                         [c, p](int){
                             ++(*c);
                         },
                         [](rxu::error_ptr){abort();});
                 }
                 auto start = clock::now();
------------------------------------------------------------
bug injection: 
SCENARIO("for loop calls subject", "[profiler]")
                         "[profiler]")
                         [c,
                         [](int){abort();});
                         [](int){abort();});
                         [](int){abort();});
                         [](std::now();});
------------------------------------------------------------
actual bug: 
 SCENARIO("for loop calls subject", "[hide][for][subject][subjects][long][perf]")
                         [c, p](int){
                             ++(*c);
                         },
                         [](std::exception_ptr){abort();});
                 }
                 auto start = clock::now();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
llvm::APInt exhaustiveRB(Inst *I, Inst *X, Inst *Y, llvm::APInt RBX, llvm::APInt
                     << getPaddedBinaryString(P1) << "\n";
       }
       auto I0 = explodeUnrestrictedBits(P0, P0 | RBX, X->Width);
       auto I1 = explodeUnrestrictedBits(P1, P1 | RBY, Y->Width);
       std::map<int, std::pair<bool, bool>> Seen;
------------------------------------------------------------
bug injection: 
llvm::APInt exhaustiveRB(Inst *I, Inst *X, Inst *Y, llvm::APInt
                           explodeUnrestrictedBits(P1) << "\n";
       }
       auto I0 = explodeUnrestrictedBits(P1, P1, P1 | RBX);
       auto I1 = explodeUnrestrictedBits(P1, P1 | RBY);
       auto I1 = explodeUnrestrictedBits(P1 | RBY, X);
------------------------------------------------------------
actual bug: 
 llvm::APInt exhaustiveRB(Inst *I, Inst *X, Inst *Y, llvm::APInt RBX, llvm::APInt
                     << getPaddedBinaryString(P1) << "\n";
       }
       auto I0 = explodeUnrestrictedBits(P0 | RBX, X->Width);
       auto I1 = explodeUnrestrictedBits(P1 | RBY, Y->Width);
       std::map<int, std::pair<bool, bool>> Seen;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class Item_func_dayofmonth :public Item_int_func
     max_length=2*MY_CHARSET_BIN_MB_MAXLEN;
     maybe_null=1;
   }
   bool check_partition_func_processor(byte *int_arg) { return FALSE;}
 };
------------------------------------------------------------
bug injection: 
class Item_func_dayofmonth :public Item_int_func
     max_length=2*MY_CHARSET_BIN_MB_MAXLEN;
     maybe_null=1;
   }
   bool check_partition_func_processor(byte *int_arg) { return 0;}
 };
------------------------------------------------------------
actual bug: 
 class Item_func_dayofmonth :public Item_int_func
     max_length=2*MY_CHARSET_BIN_MB_MAXLEN;
     maybe_null=1;
   }
   bool check_partition_func_processor(byte *int_arg) { return 0;}
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int bt_mesh_friend_req(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf)
 {
     struct bt_mesh_ctl_friend_req *msg = (void *)buf->data;
     struct bt_mesh_friend *frnd = NULL;
     u32_t poll_to = 0U;
     int i;
     if (buf->len < sizeof(*msg)) {
------------------------------------------------------------
bug injection: 
int bt_mesh_friend_req(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf)
 {
     struct bt_mesh_ctl_friend_req *msg = (void *)buf->data;
     struct bt_mesh_friend *frnd = NULL;
     u32_t poll_to;
     int i;
     if (buf->len < sizeof(*msg)) {
------------------------------------------------------------
actual bug: 
 int bt_mesh_friend_req(struct bt_mesh_net_rx *rx, struct net_buf_simple *buf)
 {
     struct bt_mesh_ctl_friend_req *msg = (void *)buf->data;
     struct bt_mesh_friend *frnd = NULL;
     u32_t poll_to;
     int i;
     if (buf->len < sizeof(*msg)) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
const struct token *eval(int in_decl)
 done:
     neednext(OPERATOR,0);
     popout_final();
 }
 int main(int argc, char *argv[])
------------------------------------------------------------
bug injection: 
const struct token *token lp)
 done:
 done:
     popout_final();
     pop();
 }
 int main(int argc, char *argv[])
------------------------------------------------------------
actual bug: 
 const struct token *eval(int in_decl)
 done:
     neednext(OPERATOR,0);
     popout_final();
     return t;
 }
 int main(int argc, char *argv[])
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++