source code: 
typedef enum
     CALIBRATE_UP,
 } calibration_stage_t;
 static int joystick_initted = 0;
 int usejoystick = 0;
------------------------------------------------------------
bug injection: 
static int usejoystick =
 } calibration_t;
 int usejoystick =
 }
 }
 joystick_t joystick_initted_t joystick_initted = joystick_initted_();
------------------------------------------------------------
actual bug: 
 typedef enum
     CALIBRATE_UP,
 } calibration_stage_t;
 int usejoystick = 0;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void F_DrawUnderwater(void)
 {
     static boolean underwawa = false;
     extern boolean askforquit;
     const char *lumpname;
     byte *palette;
------------------------------------------------------------
bug injection: 
void F_DrawUnderwater(void)
 {
     static boolean underwawa = false;
     extern boolean askforquit;
     char *lumpname;
     byte *palette;
------------------------------------------------------------
actual bug: 
 void F_DrawUnderwater(void)
 {
     static boolean underwawa = false;
     extern boolean askforquit;
     char *lumpname;
     byte *palette;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
P_CrossSpecialLine
         break;
     case 97:
         EV_Teleport( line, side, thing, TF_NORMAL );
         break;
     case 98:
------------------------------------------------------------
bug injection: 
static int i=0;
         int i=0;
         int i=0;
         int i
         int i
         int i
         int i
         int i
         int i
         int i
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int

------------------------------------------------------------
actual bug: 
 P_CrossSpecialLine
         break;
     case 97:
         EV_Teleport( line, side, thing );
         break;
     case 98:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void I_Quit (void)
         entry = entry->next;
     }
     SDL_Quit();
     exit(0);
 }
------------------------------------------------------------
bug injection: 
void I_Quit (void)
         entry = entry->next;
     }
     exit(0);
 }
------------------------------------------------------------
actual bug: 
 void I_Quit (void)
         entry = entry->next;
     }
     exit(0);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void MainMenu(void)
     quit_action = TXT_NewWindowAction(KEY_ESCAPE, "Quit");
     TXT_SignalConnect(quit_action, "pressed", QuitConfirm, NULL);
     TXT_SetWindowAction(window, TXT_HORIZ_LEFT, quit_action);
     TXT_SetKeyListener(window, MainMenuKeyPress, NULL);
 }
------------------------------------------------------------
bug injection: 
void MainMenu(void)
     quit_action = TXT_NewWindowAction(KEY_ESCAPE, "Quit");
     TXT_SignalConnect(quit_action, "pressed", QuitConfirm, NULL);
     TXT_SetWindowAction(window, TXT_HORIZ_LEFT, quit_action);
 }
------------------------------------------------------------
actual bug: 
 void MainMenu(void)
     quit_action = TXT_NewWindowAction(KEY_ESCAPE, "Quit");
     TXT_SignalConnect(quit_action, "pressed", QuitConfirm, NULL);
     TXT_SetWindowAction(window, TXT_HORIZ_LEFT, quit_action);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void DoMerge(void)
                     if (lumpindex < 0)
                     {
                         newlumps[num_newlumps++] = lump;
                     }
                 }
------------------------------------------------------------
bug injection: 
static void DoMerge(void)
                     if (lumpindex < 0)
                     {
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
------------------------------------------------------------
actual bug: 
 static void DoMerge(void)
                     if (lumpindex < 0)
                     {
                         newlumps[num_newlumps++] = *lump;
                     }
                 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void AM_drawCrosshair(int color)
 void AM_Drawer(void)
 {
     const char *level_name;
     int numepisodes;
     if (!automapactive)
------------------------------------------------------------
bug injection: 
static void DrawCrosshair(int color)
 void AM_Drawer(void)
 {
     char *level_name;
     int numepisodes;
     if (!automapactive)
------------------------------------------------------------
actual bug: 
 void AM_drawCrosshair(int color)
 void AM_Drawer(void)
 {
     char *level_name;
     int numepisodes;
     if (!automapactive)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void DEH_printf(char *fmt,...)
 void DEH_fprintf(FILE *fstream, char *fmt,...)
 {
     va_list args;
     const char *repl;
     repl = FormatStringReplacement(fmt);
------------------------------------------------------------
bug injection: 
void DEH_printf(char *fmt,...)
 void DEH_fprintf(FILE *fstream, char *fmt,...)
 {
     va_list args;
     char *repl;
     repl = FormatStringReplacement(fmt);
------------------------------------------------------------
actual bug: 
 void DEH_printf(char *fmt,...)
 void DEH_fprintf(FILE *fstream, char *fmt,...)
 {
     va_list args;
     char *repl;
     repl = FormatStringReplacement(fmt);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void DoMerge(void)
                 {
                     newlumps[num_newlumps++] = lump;
                 }
                 break;
------------------------------------------------------------
bug injection: 
static void DoMerge(void)
                 {
                     newlumps[num_newlumps++] = *lump;
                 }
                 break; <to-buggy> void
                 break; <to-buggy> void<pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad><pad>
------------------------------------------------------------
actual bug: 
 static void DoMerge(void)
                 {
                     newlumps[num_newlumps++] = *lump;
                 }
                 break;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void W_Profile (void)
 void W_GenerateHashTable(void)
 {
     lumpindex_t i;
     if (lumphash!= NULL)
------------------------------------------------------------
bug injection: 
static void DoP_GenerateHashTable(void)
 {
     int i;
     unsigned int i;
     if (lumphash!= NULL)
------------------------------------------------------------
actual bug: 
 void W_Profile (void)
 void W_GenerateHashTable(void)
 {
     unsigned int i;
     if (lumphash!= NULL)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void GenerateSpriteList(void)
     for (i=0; i<pwad_sprites.numlumps; ++i)
     {
         AddSpriteLump(pwad_sprites.lumps[i]);
     }
 }
------------------------------------------------------------
bug injection: 
static void GenerateSpriteList(void)
     for (i=0; i<pwad_sprites.numlumps; ++i)
     {
         AddSpriteLump(&pwad_sprites.lumps[i]);
     }
 }
------------------------------------------------------------
actual bug: 
 static void GenerateSpriteList(void)
     for (i=0; i<pwad_sprites.numlumps; ++i)
     {
         AddSpriteLump(&pwad_sprites.lumps[i]);
     }
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void InitVoices(void)
     int i;
     voice_free_num = num_opl_voices;
     voice_alloced_num = 0;
------------------------------------------------------------
bug injection: 
static void InitVoices(void)
     int i;
     voice_free_list = NULL;
------------------------------------------------------------
actual bug: 
 static void InitVoices(void)
     int i;
     voice_free_list = NULL;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void *W_CacheLumpNum(int lumpnum, int tag)
  I_Error ("W_CacheLumpNum: %i >= numlumps", lumpnum);
     }
     lump = lumpinfo[lumpnum];
------------------------------------------------------------
bug injection: 
void *W_CacheLumpNum(int lumpnum, int tag)
  I_Error ("W_CacheLumpNum: %i >= numlumps", lumpnum);
     }
     lump = &lumpinfo[lumpnum];
------------------------------------------------------------
actual bug: 
 void *W_CacheLumpNum(int lumpnum, int tag)
  I_Error ("W_CacheLumpNum: %i >= numlumps", lumpnum);
     }
     lump = &lumpinfo[lumpnum];
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
boolean P_CheckMeleeRange(mobj_t* actor)
     dist = P_AproxDistance(pl->x - actor->x, pl->y - actor->y);
     if(dist >= MELEERANGE - 20*FRACUNIT + pl->info->radius)
         return false;
     if(!P_CheckSight (actor, actor->target))
------------------------------------------------------------
bug injection: 
boolean P_CheckMeleeRange(mobj_t* actor)
     dist = P_AproxDistance(pl->x - actor->x, pl->y - actor->y);
     if(dist >= MELEERANGE - 20*FRACUNIT + pl->info->radius)
         return false;
     if(!P_CheckSight (actor, actor->target))
------------------------------------------------------------
actual bug: 
 boolean P_CheckMeleeRange(mobj_t* actor)
     dist = P_AproxDistance(pl->x - actor->x, pl->y - actor->y);
     if(dist >= MELEERANGE - 36*FRACUNIT + pl->info->radius)
         return false;
     if(!P_CheckSight (actor, actor->target))
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void R_FillBackScreen (void)
     patch_t* patch;
     const char *name1 = DEH_String("FLOOR7_2");
     const char *name2 = DEH_String("GRNROCK");
     const char *name;
------------------------------------------------------------
bug injection: 
static void R_FillBackScreen (void)
     patch_t* patch;
     char *name1 = DEH_String("FLOOR7_2");
     char *name2 = DEH_String("GRNROCK");
     char *name;
------------------------------------------------------------
actual bug: 
 void R_FillBackScreen (void)
     patch_t* patch;
     char *name1 = DEH_String("FLOOR7_2");
     char *name2 = DEH_String("GRNROCK");
     char *name;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void MN_Drawer(void)
     int x;
     int y;
     MenuItem_t *item;
     const char *selName;
     if (MenuActive == false)
     {
------------------------------------------------------------
bug injection: 
void MN_Drawer(void)
     int x;
     int y;
     MenuItem_t *item;
     char *selName;
     if (MenuActive == false)
     {
------------------------------------------------------------
actual bug: 
 void MN_Drawer(void)
     int x;
     int y;
     MenuItem_t *item;
     char *selName;
     if (MenuActive == false)
     {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void ConfigJoystick(void)
     AddJoystickControl(button_table, "Activate menu", &joybmenu);
     TXT_SignalConnect(joystick_button, "pressed", CalibrateJoystick, NULL);
     TXT_SetWindowAction(window, TXT_HORIZ_CENTER, TestConfigAction());
     SetJoystickButtonLabel();
------------------------------------------------------------
bug injection: 
static void)ConfigJoystick(void)
     AddJoystickControl(button_table, "Activate menu", &joybmenu);
     TXT_SignalConnect(joystick_button, "pressed", CalibrateJoystick, NULL);
     TXT_SignalConnect(window, "closed", JoystickWindowClosed, NULL);
     TXT_SetWindowAction(window, TXT_HORIZ_CENTER, TestConfigAction());
     SetJoystickButtonLabel();
------------------------------------------------------------
actual bug: 
 void ConfigJoystick(void)
     AddJoystickControl(button_table, "Activate menu", &joybmenu);
     TXT_SignalConnect(joystick_button, "pressed", CalibrateJoystick, NULL);
     TXT_SignalConnect(window, "closed", JoystickWindowClosed, NULL);
     TXT_SetWindowAction(window, TXT_HORIZ_CENTER, TestConfigAction());
     SetJoystickButtonLabel();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
import sys
 import re
 import glob
 import getopt
 class Category:
     def __init__(self, description):
------------------------------------------------------------
bug injection: 
import sys
 import re
 import glob
 class Category:
     def __init__(self, description):
------------------------------------------------------------
actual bug: 
 import sys
 import re
 import glob
 class Category:
     def __init__(self, description):
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void DrawFilesMenu(void)
 static void DrawLoadMenu(void)
 {
     const char *title;
     title = DEH_String("LOAD GAME");
------------------------------------------------------------
bug injection: 
static void DrawFilesMenu(void)
 static void DrawLoadMenu(void)
 {
     char *title;
     title = DEH_String("LOAD GAME");
------------------------------------------------------------
actual bug: 
 static void DrawFilesMenu(void)
 static void DrawLoadMenu(void)
 {
     char *title;
     title = DEH_String("LOAD GAME");
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void InitPipes(HANDLE in, HANDLE out)
 int main(int argc, char *argv[])
 {
     HANDLE in, out;
     if (argc < 5)
     {
------------------------------------------------------------
bug injection: 
static void InitPipes(HANDLE in, HANDLE out)
 int main(int argc, char *argv[])
 {
     if (argc < 5)
     {
------------------------------------------------------------
actual bug: 
 void InitPipes(HANDLE in, HANDLE out)
 int main(int argc, char *argv[])
 {
     if (argc < 5)
     {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void NET_SV_SendTics(net_client_t *client, int start, int end)
         NET_WriteFullTiccmd(packet, cmd, false);
     }
------------------------------------------------------------
bug injection: 
static void NET_SV_SendTics(net_client_t *client, int start, int end)
         NET_WriteFullTiccmd(packet, cmd);
     }
------------------------------------------------------------
actual bug: 
 static void NET_SV_SendTics(net_client_t *client, int start, int end)
         NET_WriteFullTiccmd(packet, cmd);
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void PrintDehackedBanners(void)
     for (i=0; i<arrlen(copyright_banners); ++i)
     {
         const char *deh_s;
         deh_s = DEH_String(copyright_banners[i]);
------------------------------------------------------------
bug injection: 
void PrintDehackedBanners(void)
     for (i=0; i<arrlen(copyright_banners); ++i)
     {
         char *deh_s;
         deh_s = DEH_String(copyright_banners[i]);
------------------------------------------------------------
actual bug: 
 void PrintDehackedBanners(void)
     for (i=0; i<arrlen(copyright_banners); ++i)
     {
         char *deh_s;
         deh_s = DEH_String(copyright_banners[i]);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void ConfigJoystick(void)
     AddJoystickControl(button_table, "Strafe Right", &joybstraferight);
     TXT_SignalConnect(joystick_button, "pressed", CalibrateJoystick, NULL);
     TXT_SignalConnect(window, "closed", JoystickWindowClosed, NULL);
     SetJoystickButtonLabel();
 }
------------------------------------------------------------
bug injection: 
void ConfigJoystick(void)
     AddJoystickControl(button_table, "Strafe Left", &joybstraferight);
     TXT_SignalConnect(joystick_button, "pressed", CalibrateJoystick, NULL);
     TXT_SignalConnect(window, "closed", JoystickWindowClosed, NULL);
     SetJoystickButtonLabel();
 }
------------------------------------------------------------
actual bug: 
 void ConfigJoystick(void)
     AddJoystickControl(button_table, "Strafe Right", &joybstraferight);
     TXT_SignalConnect(joystick_button, "pressed", CalibrateJoystick, NULL);
     SetJoystickButtonLabel();
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void I_Error (char *error,...)
     SDL_Quit();
     exit(-1);
 }
------------------------------------------------------------
bug injection: 
void I_Error (char *error,...)
     exit(-1);
 }
------------------------------------------------------------
actual bug: 
 void I_Error (char *error,...)
     exit(-1);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static Mix_Chunk *getsfx(int sound)
         sound_chunks[sound].allocated = 1;
         sound_chunks[sound].abuf = expand_sound_data(data + 8, samplerate, length);
         sound_chunks[sound].alen = (length * 2) * (22050 / samplerate);
         sound_chunks[sound].volume = 32;
     }
------------------------------------------------------------
bug injection: 
static Mix_Chunk *getsfx(int sound)
         sound_chunks[sound].allocated = 1;
         sound_chunks[sound].abuf = expand_sound_data(data + 8, samplerate, length);
         sound_chunks[sound].alen = (length * 2 * 22050) / samplerate;
         sound_chunks[sound].volume = 32;
     }
------------------------------------------------------------
actual bug: 
 static Mix_Chunk *getsfx(int sound)
         sound_chunks[sound].allocated = 1;
         sound_chunks[sound].abuf = expand_sound_data(data + 8, samplerate, length);
         sound_chunks[sound].alen = (length * 2 * 22050) / samplerate;
         sound_chunks[sound].volume = 32;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static char *banners[] =
 static char *GetGameName(char *gamename)
 {
     size_t i;
     const char *deh_sub;
     for (i=0; i<arrlen(banners); ++i)
     {
------------------------------------------------------------
bug injection: 
static char *banners[] =
 static char *GetGameName(char *gamename)
 {
     size_t i;
     char *deh_sub;
     for (i=0; i<arrlen(banners); ++i)
     {
------------------------------------------------------------
actual bug: 
 static char *banners[] =
 static char *GetGameName(char *gamename)
 {
     size_t i;
     char *deh_sub;
     for (i=0; i<arrlen(banners); ++i)
     {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
R_GetColumn
 static void GenerateTextureHashTable(void)
 {
     texture_t **rover;
     int i;
     int key;
------------------------------------------------------------
bug injection: 
static void GenerateHashTable(void)
 {
     int i;
     int i;
     int key;
------------------------------------------------------------
actual bug: 
 R_GetColumn
 static void GenerateTextureHashTable(void)
 {
     int i;
     int key;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static boolean CacheSFX(int sound)
     ExpandSoundData(data + 8,
                     samplerate,
                     length,
                     &sound_chunks[sound]);
------------------------------------------------------------
bug injection: 
static boolean CacheSFX(int sound)
     ExpandSoundData(data + 8,
                     samplerate,
                     length - 8,
                     &sound_chunks[sound]);
------------------------------------------------------------
actual bug: 
 static boolean CacheSFX(int sound)
     ExpandSoundData(data + 8,
                     samplerate,
                     length - 8,
                     &sound_chunks[sound]);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void I_OPL_ShutdownMusic(void)
         W_ReleaseLumpName(DEH_String("genmidi"));
         music_initialized = false;
     }
------------------------------------------------------------
bug injection: 
static void I_OPL_ShutdownMusic(void)
         W_ReleaseLumpName("GENMIDI");
         music_initialized = false;
     }
------------------------------------------------------------
actual bug: 
 static void I_OPL_ShutdownMusic(void)
         W_ReleaseLumpName("GENMIDI");
         music_initialized = false;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int sfxVolume = 8;
 int musicVolume = 13;
------------------------------------------------------------
bug injection: 
int sfxVolume = 8;
 int musicVolume = 8;
------------------------------------------------------------
actual bug: 
 int sfxVolume = 8;
 int musicVolume = 8;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void ReadLoopPoints(char *filename, file_metadata_t *metadata)
     metadata->start_time = 0;
     metadata->end_time = -1;
     fs = fopen(filename, "rb");
     if (fs == NULL)
     {
------------------------------------------------------------
bug injection: 
static void ReadLoopPoints(char *filename, file_metadata_t *metadata)
     metadata->start_time = 0;
     metadata->end_time = -1;
     fs = fopen(filename, "r");
     if (fs == NULL)
     {
------------------------------------------------------------
actual bug: 
 static void ReadLoopPoints(char *filename, file_metadata_t *metadata)
     metadata->start_time = 0;
     metadata->end_time = -1;
     fs = fopen(filename, "r");
     if (fs == NULL)
     {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void ConfigSound(void)
     TXT_AddWidgets(window,
                TXT_NewSeparator("Music"),
                music_table = TXT_NewTable(2),
                extra_table = TXT_NewTable(2),
                NULL);
     TXT_SetColumnWidths(music_table, 19, 15);
------------------------------------------------------------
bug injection: 
void ConfigSound(void)
     TXT_AddWidgets(window,
                TXT_NewSeparator("Music"),
                music_table = TXT_NewTable(1),
                extra_table = TXT_NewTable(1),
                NULL);
     TXT_SetColumnWidths(music_table, 19, 15); <to-buggy> void ConfigMusic(void)
     TXT_AddWidgets(window,
                TXT_NewSeparator("Music"),
                music_table = TXT_NewTable(2),
                extra_table = TXT_NewTable(2),
                NULL);
     TXT_SetColumnWidths(music_table, 19, 15); <to-buggy> VoidPtr ConfigMusic(void)
     TXT_AddWidgets(window,
                TXT_NewSeparator("Music"),
                music_table = TXT_NewTable(2),
                extra_table = TXT_NewTable(2),
                NULL);
     TXT_SetColumnWidths(music_table, 19, 15);
     TXT_AddWidgets(window,
                TXT_NewSeparator("Music"),
                music_table = TXT_NewTable(2),
                extra_table = TXT_NewTable(2),
                NULL);
     TXT_SetColumnWidths(music_table, 19, 15);
     TXT_AddWidgets(window,
                TXT_NewSeparator("Music"),
                music_table = TXT_NewTable(2),
                extra_table = TXT_NewTable(2),
                NULL);
     TXT_SetColumnWidths(music_table, 19, 15);
     TXT_AddWidgets(window,
                TXT_NewSeparator("Music"),
                music_table = TXT_NewTable(2),
                extra_table = TXT_NewTable(2),
                NULL);
     TXT_SetColumnWidths(music_table, 19, 15);
     TXT_AddWidgets(window,
                TXT_NewSeparator("Music"),
                music_table = TXT_NewTable(2),
                extra_table = TXT_NewTable(2),
                NULL);
     TXT_SetColumnWidths(music_table, 19, 15);
     TXT_AddWidgets(window,
                TXT_NewSeparator("Music"),
                music_table = TXT_NewTable(2),
                extra_table = TXT_NewTable(2
------------------------------------------------------------
actual bug: 
 void ConfigSound(void)
     TXT_AddWidgets(window,
                TXT_NewSeparator("Music"),
                music_table = TXT_NewTable(2),
                extra_table = TXT_NewTable(1),
                NULL);
     TXT_SetColumnWidths(music_table, 19, 15);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static opl_channel_data_t *TrackChannelForEvent(opl_track_data_t *track,
         channel_num = 9;
     }
     return &channels[channel_num];
 }
------------------------------------------------------------
bug injection: 
static opl_channel_data_t *TrackChannelForEvent(opl_track_data_t *track,
         channel_num = 9;
     }
     return &channels[channel_num];
 }
------------------------------------------------------------
actual bug: 
 static opl_channel_data_t *TrackChannelForEvent(opl_track_data_t *track,
         channel_num = 9;
     }
     return &track->channels[channel_num];
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int main(int argc, char **argv)
     myargc = argc;
     myargv = argv;
     M_FindResponseFile();
------------------------------------------------------------
bug injection: 
int main(int argc, char **argv)
     myargc = argc;
     myargv = argv;
     M_FindResponseFile();
     exit(0); <to-buggy> <pad><pad><pad><pad><pad><pad><pad>
------------------------------------------------------------
actual bug: 
 int main(int argc, char **argv)
     myargc = argc;
     myargv = argv;
     LockCPUAffinity();
     M_FindResponseFile();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void W_GenerateHashTable(void)
 void W_Reload(void)
 {
     char *filename;
     lumpindex_t i;
     if (reloadname == NULL)
     {
------------------------------------------------------------
bug injection: 
static void W_GenerateHashTable(void)
 void W_Reload(void)
 {
     char *filename;
     int i;
     if (reloadname == NULL)
     {
------------------------------------------------------------
actual bug: 
 void W_GenerateHashTable(void)
 void W_Reload(void)
 {
     char *filename;
     int i;
     if (reloadname == NULL)
     {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
boolean M_StringConcat(char *dest, const char *src, size_t dest_size)
 boolean M_StringStartsWith(const char *s, const char *prefix)
 {
     return strlen(s) >= strlen(prefix)
         && strncmp(s, prefix, strlen(prefix)) == 0;
 }
------------------------------------------------------------
bug injection: 
boolean M_StringConcat(char *dest, const char *src, size_t dest_size)
 boolean M_StringStartsWith(const char *s, const char *prefix)
 {
     return strlen(s) >= strlen(prefix)
         && strncmp(s, prefix, strlen(prefix)) == 0;
 }
------------------------------------------------------------
actual bug: 
 boolean M_StringConcat(char *dest, const char *src, size_t dest_size)
 boolean M_StringStartsWith(const char *s, const char *prefix)
 {
     return strlen(s) > strlen(prefix)
         && strncmp(s, prefix, strlen(prefix)) == 0;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void DrawFilesMenu(void)
 static void DrawLoadMenu(void)
 {
     const char *title;
     title = DEH_String("LOAD GAME");
------------------------------------------------------------
bug injection: 
static void DrawFilesMenu(void)
 static void DrawLoadMenu(void)
 {
     char *title;
     title = DEH_String("LOAD GAME");
------------------------------------------------------------
actual bug: 
 static void DrawFilesMenu(void)
 static void DrawLoadMenu(void)
 {
     char *title;
     title = DEH_String("LOAD GAME");
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void A_ReaverAttack(mobj_t* actor)
     {
         int t = P_Random();
         angle_t shootangle = actor->angle + ((t - P_Random()) << 20);
         int damage = 3*((P_Random() & 7) + 1);
         P_LineAttack(actor, shootangle, 2048*FRACUNIT, slope, damage);
         ++i;
------------------------------------------------------------
bug injection: 
void A_ReaverAttack(mobj_t* actor)
     {
         int t = P_Random();
         angle_t shootangle = actor->angle + ((t - P_Random()) << 20);
         int damage = (P_Random() & 7) + 1;
         P_LineAttack(actor, shootangle, 2048*FRACUNIT, slope, damage);
         ++i;
------------------------------------------------------------
actual bug: 
 void A_ReaverAttack(mobj_t* actor)
     {
         int t = P_Random();
         angle_t shootangle = actor->angle + ((t - P_Random()) << 20);
         int damage = (P_Random() & 7) + 1;
         P_LineAttack(actor, shootangle, 2048*FRACUNIT, slope, damage);
         ++i;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void OpenGameSelectDialog(GameSelectCallback callback)
 void SetupMission(GameSelectCallback callback)
 {
     mission_config_t *config;
     const char *mission_name;
     int p;
------------------------------------------------------------
bug injection: 
static void OpenGameSelectDialog(GameSelectCallback callback)
 void SetupMission(GameSelectCallback callback)
 {
     mission_config_t *config;
     char *mission_name;
     int p;
------------------------------------------------------------
actual bug: 
 static void OpenGameSelectDialog(GameSelectCallback callback)
 void SetupMission(GameSelectCallback callback)
 {
     mission_config_t *config;
     char *mission_name;
     int p;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void NET_SV_SendTics(net_client_t *client, int start, int end)
         NET_WriteFullTiccmd(packet, cmd, false);
     }
------------------------------------------------------------
bug injection: 
static void NET_SV_SendTics(net_client_t *client, int start, int end)
         NET_WriteFullTiccmd(packet, cmd);
     }
------------------------------------------------------------
actual bug: 
 static void NET_SV_SendTics(net_client_t *client, int start, int end)
         NET_WriteFullTiccmd(packet, cmd);
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void A_SigilShock (player_t *player, pspdef_t *psp)
 void A_TorpedoExplode(mobj_t* actor)
 {
     int i;
     actor->angle -= ANG180;
------------------------------------------------------------
bug injection: 
void A_SigilShock (player_t *player, pspdef_t *psp)
 void A_TorpedoExplode(mobj_t* actor)
 {
     int i = 0;
     actor->angle -= ANG180;
------------------------------------------------------------
actual bug: 
 void A_SigilShock (player_t *player, pspdef_t *psp)
 void A_TorpedoExplode(mobj_t* actor)
 {
     int i = 0;
     actor->angle -= ANG180;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void I_Quit (void)
         entry = entry->next;
     }
     SDL_Quit();
     exit(0);
 }
------------------------------------------------------------
bug injection: 
void I_Quit (void)
         entry = entry->next;
     }
     exit(0);
 }
------------------------------------------------------------
actual bug: 
 void I_Quit (void)
         entry = entry->next;
     }
     exit(0);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void ExpandSoundData(byte *data, int samplerate, int length,
 {
     byte *expanded = (byte *) destination->abuf;
     int expanded_length;
     int expand_ratio;
     int i;
     if (samplerate == 11025)
------------------------------------------------------------
bug injection: 
static void ExpandSoundData(byte *data, int samplerate, int length,
 {
     byte *expanded = (byte *) destination->abuf;
     int expanded_length;
     int i;
     if (samplerate == 11025)
------------------------------------------------------------
actual bug: 
 static void ExpandSoundData(byte *data, int samplerate, int length,
 {
     byte *expanded = (byte *) destination->abuf;
     int expanded_length;
     int i;
     if (samplerate == 11025)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
P_CrossSpecialLine
         break;
     case 231:
         EV_Teleport(line, side, thing, TF_SRCSILENCE);
         break;
------------------------------------------------------------
bug injection: 
staticCrossSpecialLine
         break;
     case 231:
         EV_Teleport(line, side, thing );
         break;
------------------------------------------------------------
actual bug: 
 P_CrossSpecialLine
         break;
     case 231:
         EV_Teleport(line, side, thing );
         break;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void DoMerge(void)
                         newlumps[num_newlumps++] = pwad_flats.lumps[n];
                     }
                     newlumps[num_newlumps++] = lump;
                     current_section = SECTION_NORMAL;
------------------------------------------------------------
bug injection: 
static void DoMerge(void)
                         newlumps[num_newlumps++] = pwad_flats.lumps[n];
                     }
                     newlumps[num_newlumps++] = *lump;
                     current_section = SECTION_NORMAL;
------------------------------------------------------------
actual bug: 
 static void DoMerge(void)
                         newlumps[num_newlumps++] = pwad_flats.lumps[n];
                     }
                     newlumps[num_newlumps++] = *lump;
                     current_section = SECTION_NORMAL;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
P_CrossSpecialLine
         break;
     case 126:
         if (!thing->player)
             EV_Teleport( line, side, thing, TF_NORMAL );
         break;
     case 128:
------------------------------------------------------------
bug injection: 
P_CrossSpecialLine
         break;
     case 129:
         if (!thing->player)
             EV_Teleport( line, side, thing );
         break;
     case 130:
------------------------------------------------------------
actual bug: 
 P_CrossSpecialLine
         break;
     case 126:
         if (!thing->player)
             EV_Teleport( line, side, thing );
         break;
     case 128:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void P_ChangeSwitchTexture(line_t* line, int useAgain)
     if(line->special == 182)
     {
         line->flags &= ~ML_BLOCKING;
         breakglass = true;
         if(useAgain)
------------------------------------------------------------
bug injection: 
void P_ChangeSwitchTexture(line_t* line, int useAgain)
     if(line->special == 182)
     {
         line->flags &= ~ML_BLOCKMONSTERS;
         breakglass = true;
         if(useAgain)
------------------------------------------------------------
actual bug: 
 void P_ChangeSwitchTexture(line_t* line, int useAgain)
     if(line->special == 182)
     {
         line->flags &= ~ML_BLOCKMONSTERS;
         breakglass = true;
         if(useAgain)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static char *banners[] =
 static char *GetGameName(char *gamename)
 {
     size_t i;
     const char *deh_sub;
     for (i=0; i<arrlen(banners); ++i)
     {
------------------------------------------------------------
bug injection: 
static char *banners[] =
 static char *GetGameName(char *gamename)
 {
     size_t i;
     char *deh_sub;
     for (i=0; i<arrlen(banners); ++i)
     {
------------------------------------------------------------
actual bug: 
 static char *banners[] =
 static char *GetGameName(char *gamename)
 {
     size_t i;
     char *deh_sub;
     for (i=0; i<arrlen(banners); ++i)
     {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void DoMerge(void)
     for (i=0; i<pwad.numlumps; ++i)
     {
         lumpinfo_t *lump = pwad.lumps[i];
         switch (current_section)
         {
------------------------------------------------------------
bug injection: 
static void DoMerge(void)
     for (i=0; i<pwad.numlumps; ++i)
     {
         lumpinfo_t *lump = &pwad.lumps[i];
         switch (current_section)
         {
------------------------------------------------------------
actual bug: 
 static void DoMerge(void)
     for (i=0; i<pwad.numlumps; ++i)
     {
         lumpinfo_t *lump = &pwad.lumps[i];
         switch (current_section)
         {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void F_DrawUnderwater(void)
 {
     static boolean underwawa = false;
     extern boolean askforquit;
     const char *lumpname;
     byte *palette;
------------------------------------------------------------
bug injection: 
void F_DrawUnderwater(void)
 {
     static boolean underwawa = false;
     extern boolean askforquit;
     char *lumpname;
     byte *palette;
------------------------------------------------------------
actual bug: 
 void F_DrawUnderwater(void)
 {
     static boolean underwawa = false;
     extern boolean askforquit;
     char *lumpname;
     byte *palette;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void P_DialogDoChoice(int choice)
 {
     int i = 0, nextdialog = 0;
     boolean candochoice = true;
     const char *message = NULL;
     mapdlgchoice_t *currentchoice;
     if(choice == -1)
------------------------------------------------------------
bug injection: 
void P_DialogDoChoice(int choice)
 {
     int i = 0, nextdialog = 0;
     boolean candochoice = true;
     char *message = NULL;
     mapdlgchoice_t *currentchoice;
     if(choice == -1)
------------------------------------------------------------
actual bug: 
 void P_DialogDoChoice(int choice)
 {
     int i = 0, nextdialog = 0;
     boolean candochoice = true;
     char *message = NULL;
     mapdlgchoice_t *currentchoice;
     if(choice == -1)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void SuggestOtherVersions(unsigned int offset)
 static void *DEH_TextStart(deh_context_t *context, char *line)
 {
     char *repl_text;
     const char *orig_text;
     int orig_offset, repl_len;
     int i;
------------------------------------------------------------
bug injection: 
static void SuggestOtherVersions(unsigned int offset)
 static void *DEH_TextStart(deh_context_t *context, char *line)
 {
     char *repl_text;
     char *orig_text;
     int orig_offset, repl_len;
     int i;
------------------------------------------------------------
actual bug: 
 static void SuggestOtherVersions(unsigned int offset)
 static void *DEH_TextStart(deh_context_t *context, char *line)
 {
     char *repl_text;
     char *orig_text;
     int orig_offset, repl_len;
     int i;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void WI_loadUnloadData(load_callback_t callback)
     callback(name, &background);
 }
 static void WI_loadCallback(const char *name, patch_t **variable)
 {
 }
------------------------------------------------------------
bug injection: 
static void WI_loadUnloadData(load_callback_t callback)
     callback(name, &background);
 }
 static void WI_loadCallback(char *name, patch_t **variable)
 {
 }
------------------------------------------------------------
actual bug: 
 static void WI_loadUnloadData(load_callback_t callback)
     callback(name, &background);
 }
 static void WI_loadCallback(char *name, patch_t **variable)
 {
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static Mix_Chunk *getsfx(int sound)
         sound_chunks[sound].allocated = 1;
         sound_chunks[sound].abuf = expand_sound_data(data + 8, samplerate, length);
         sound_chunks[sound].alen = (length * 2) * (22050 / samplerate);
         sound_chunks[sound].volume = 32;
     }
------------------------------------------------------------
bug injection: 
static Mix_Chunk *getsfx(int sound)
         sound_chunks[sound].allocated = 1;
         sound_chunks[sound].abuf = expand_sound_data(data + 8, samplerate, length);
         sound_chunks[sound].alen = (length * 2 * 22050) / samplerate;
         sound_chunks[sound].volume = 32;
     }
------------------------------------------------------------
actual bug: 
 static Mix_Chunk *getsfx(int sound)
         sound_chunks[sound].allocated = 1;
         sound_chunks[sound].abuf = expand_sound_data(data + 8, samplerate, length);
         sound_chunks[sound].alen = (length * 2 * 22050) / samplerate;
         sound_chunks[sound].volume = 32;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void W_ReleaseLumpNum(int lumpnum)
  I_Error ("W_ReleaseLumpNum: %i >= numlumps", lumpnum);
     }
     lump = lumpinfo[lumpnum];
     if (lump->wad_file->mapped!= NULL)
     {
------------------------------------------------------------
bug injection: 
void W_ReleaseLumpNum(int lumpnum)
  I_Error ("W_ReleaseLumpNum: %i >= numlumps", lumpnum);
     }
     lump = &lumpinfo[lumpnum];
     if (lump->wad_file->mapped!= NULL)
     {
------------------------------------------------------------
actual bug: 
 void W_ReleaseLumpNum(int lumpnum)
  I_Error ("W_ReleaseLumpNum: %i >= numlumps", lumpnum);
     }
     lump = &lumpinfo[lumpnum];
     if (lump->wad_file->mapped!= NULL)
     {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static int FindInList(searchlist_t *list, char *name)
     for (i=0; i<list->numlumps; ++i)
     {
         if (!strncasecmp(list->lumps[i]->name, name, 8))
             return i;
     }
------------------------------------------------------------
bug injection: 
static int FindInList(searchlist_t *list, char *name)
     for (i=0; i<list->numlumps; ++i)
     {
         if (!strncasecmp(list->lumps[i].name, name, 8))
             return i;
     }
------------------------------------------------------------
actual bug: 
 static int FindInList(searchlist_t *list, char *name)
     for (i=0; i<list->numlumps; ++i)
     {
         if (!strncasecmp(list->lumps[i].name, name, 8))
             return i;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
class Parameter:
         result += self.text
         if self.platform:
             result += "'''(%s only)'''" % self.platform
         return result
------------------------------------------------------------
bug injection: 
static void wx_static void wx_static void wx_static void wx_static void wx_static void wx_static void wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wx_wxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwxwx
------------------------------------------------------------
actual bug: 
 class Parameter:
         result += self.text
         if self.platform:
             result += "'''(%s only)'''"
         return result
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
I_InitSound()
     sound_initialised = 1;
     SDL_PauseAudio(0);
 }
------------------------------------------------------------
bug injection: 
I_InitSound()
     sound_initialised = 1;
     SDL_PauseAudio(0);
     printf("sound started.\n");
 }
------------------------------------------------------------
actual bug: 
 I_InitSound()
     sound_initialised = 1;
     SDL_PauseAudio(0);
     printf("sound started.\n");
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void V_ScreenShot(char *format)
 {
     int i;
     char lbmname[16];
     const char *ext;
------------------------------------------------------------
bug injection: 
void V_ScreenShot(char *format)
 {
     int i;
     char lbmname[16];
     char *ext;
------------------------------------------------------------
actual bug: 
 void V_ScreenShot(char *format)
 {
     int i;
     char lbmname[16];
     char *ext;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void PrintDehackedBanners(void)
     for (i=0; i<arrlen(copyright_banners); ++i)
     {
         const char *deh_s;
         deh_s = DEH_String(copyright_banners[i]);
------------------------------------------------------------
bug injection: 
void PrintDehackedBanners(void)
     for (i=0; i<arrlen(copyright_banners); ++i)
     {
         char *deh_s;
         deh_s = DEH_String(copyright_banners[i]);
------------------------------------------------------------
actual bug: 
 void PrintDehackedBanners(void)
     for (i=0; i<arrlen(copyright_banners); ++i)
     {
         char *deh_s;
         deh_s = DEH_String(copyright_banners[i]);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void DoMerge(void)
                     if (SpriteLumpNeeded(lump))
                     {
                         newlumps[num_newlumps++] = lump;
                     }
                 }
------------------------------------------------------------
bug injection: 
static void DoMerge(void)
                     if (SpriteLumpNeeded(lump))
                     {
                         newlumps[num_newlumps++] = *lump;
                     }
                 }
------------------------------------------------------------
actual bug: 
 static void DoMerge(void)
                     if (SpriteLumpNeeded(lump))
                     {
                         newlumps[num_newlumps++] = *lump;
                     }
                 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
struct memblock_s
 static memblock_t *allocated_blocks[PU_NUM_TAGS];
 static void Z_InsertBlock(memblock_t *block)
 {
     block->prev = NULL;
     block->next = allocated_blocks[block->tag];
     allocated_blocks[block->tag] = block;
     if (block->next!= NULL)
     {
------------------------------------------------------------
bug injection: 
struct memblock_s
 static memblock_t *allocated_blocks[PU_NUM_TAGS];
 static void Z_InsertBlock(memblock_t *block)
 {
     block->prev = NULL;
     block->next = allocated_blocks[block->tag];
     allocated_blocks[block->tag] = block->next;
     if (block->next!= NULL)
     {
------------------------------------------------------------
actual bug: 
 struct memblock_s
 static memblock_t *allocated_blocks[PU_NUM_TAGS];
 static void Z_InsertBlock(memblock_t *block)
 {
     block->prev = NULL;
     block->next = allocated_blocks[block->tag];
     allocated_blocks[block->tag] = block->next;
     if (block->next!= NULL)
     {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static char *banners[] =
 static char *GetGameName(char *gamename)
 {
     size_t i;
     const char *deh_sub;
     for (i=0; i<arrlen(banners); ++i)
     {
------------------------------------------------------------
bug injection: 
static char *banners[] =
 static char *GetGameName(char *gamename)
 {
     size_t i;
     char *deh_sub;
     for (i=0; i<arrlen(banners); ++i)
     {
------------------------------------------------------------
actual bug: 
 static char *banners[] =
 static char *GetGameName(char *gamename)
 {
     size_t i;
     char *deh_sub;
     for (i=0; i<arrlen(banners); ++i)
     {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
P_CrossSpecialLine
         break;
     case 97:
         EV_Teleport( line, side, thing, TF_NORMAL );
         break;
     case 98:
------------------------------------------------------------
bug injection: 
static int i=0;
         int i=0;
         int i=0;
         int i
         int i
         int i
         int i
         int i
         int i
         int i
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int
         int

------------------------------------------------------------
actual bug: 
 P_CrossSpecialLine
         break;
     case 97:
         EV_Teleport( line, side, thing );
         break;
     case 98:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++