
source code: 
static void cmd_trigger_delete(struct watchman_client *client, json_t *args)
   json_incref(jname);
   set_prop(resp, "trigger", jname);
   send_and_dispose_response(client, resp);
   w_root_delref(unlocked.root);
 }
 W_CMD_REG("trigger-del", cmd_trigger_delete, CMD_DAEMON, w_cmd_realpath_root)
------------------------------------------------------------
bug injection: 
static void cmd_trigger_delete(struct watchman_client *client, json_t *args)
   json_incref(jname);
   w_root_delref(resp, "trigger-del", 0);
   w_root_delref(resp, "trigger-delref", cmd_delref);
   w_root_delref(root, "trigger", CMD_DAEMON, CMD_DAEMON, CMD_DAEMON, CMD_DAEMON, w_DAEMON, w_DAEMON, w_DAEMON,
------------------------------------------------------------
actual bug: 
 static void cmd_trigger_delete(struct watchman_client *client, json_t *args)
   json_incref(jname);
   set_prop(resp, "trigger", jname);
   send_and_dispose_response(client, resp);
   w_root_delref(root);
 }
 W_CMD_REG("trigger-del", cmd_trigger_delete, CMD_DAEMON, w_cmd_realpath_root)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void tsmf_playback_ack(IWTSVirtualChannelCallback *pChannelCallback,
  Stream_Write_UINT64(s, duration);
  Stream_Write_UINT64(s, data_size);
  DEBUG_TSMF("ACK response size %d", (int) Stream_GetPosition(s));
  if (!callback ||!callback->channel ||!callback->channel->Write)
  {
------------------------------------------------------------
bug injection: 
void tsmf_playback_ack(IWTSVirtualChannelCallback *pChannelCallback,
  Stream_Write_UINT64(s, duration);
  Stream_Write_UINT64(s, duration);
  DEBUG_TSMF("ACK response size=%d", (int) Stream_size);
  if (!callback ||!callback->Write_Write_UINT64(s));
  {
------------------------------------------------------------
actual bug: 
 void tsmf_playback_ack(IWTSVirtualChannelCallback *pChannelCallback,
  Stream_Write_UINT64(s, duration);
  Stream_Write_UINT64(s, data_size);
  DEBUG_TSMF("response size %d", (int) Stream_GetPosition(s));
  if (!callback ||!callback->channel ||!callback->channel->Write)
  {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int atshowmobs_timer(int tid, unsigned int tick, int id, intptr data)
 int atcommand_showmobs(const int fd, struct map_session_data* sd, const char* command, const char* message)
 {
  char mob_name[100];
  int mob_id;
  int number = 0;
  struct s_mapiterator* it;
------------------------------------------------------------
bug injection: 
int atshowmobs_timer(int tid, unsigned int tick, int id, int id, int id, const char* command)
 int atcommand_showmobs_id, const char* command, const char* message)
 {
  char mob_name[100];
  int number = 0;
  struct s_mapiterator* it;
------------------------------------------------------------
actual bug: 
 int atshowmobs_timer(int tid, unsigned int tick, int id, intptr data)
 int atcommand_showmobs(const int fd, struct map_session_data* sd, const char* command, const char* message)
 {
  char mob_name[100];
  int mob_id,map_id = 0;
  int number = 0;
  struct s_mapiterator* it;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
btr_cur_pessimistic_update(
  record to be inserted: we have to remember which fields were such */
  ut_ad(!page_is_comp(page) ||!rec_get_node_ptr_flag(rec));
  offsets = rec_get_offsets(rec, index, offsets, ULINT_UNDEFINED, heap);
  n_ext += btr_push_update_extern_fields(new_entry, update, *heap);
  if (UNIV_LIKELY_NULL(page_zip)) {
------------------------------------------------------------
bug injection: 
btr_cur_pessimistic_update(
  record to be inserted: we have to remember which fields were such */
  ut_ad(!page_is_comp(page) ||!rec_get_node_ptr_flag(rec));
  ut_ad(rec_offs_validate(rec, index, offsets));
  n_ext += btr_push_update_extern_fields(new_entry, update, *heap);
  if (UNIV_LIKELY_NULL(page_zip)) {
------------------------------------------------------------
actual bug: 
 btr_cur_pessimistic_update(
  record to be inserted: we have to remember which fields were such */
  ut_ad(!page_is_comp(page) ||!rec_get_node_ptr_flag(rec));
  ut_ad(rec_offs_validate(rec, index, offsets));
  n_ext += btr_push_update_extern_fields(new_entry, update, *heap);
  if (UNIV_LIKELY_NULL(page_zip)) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class ha_federated: public handler
              HA_CREATE_INFO *create_info);
   ha_rows records_in_range(uint inx, key_range *start_key,
                                    key_range *end_key);
   uint8 table_cache_type() { return HA_CACHE_TBL_NOCACHE; }
   THR_LOCK_DATA **store_lock(THD *thd, THR_LOCK_DATA **to,
                              enum thr_lock_type lock_type);
------------------------------------------------------------
bug injection: 
class ha_federated: public handler
                       HA_CREATE_INFO *create_info);
   HA_CREATE_INFO *create_info;
   ha_rows records_in_range(uint inx, key_range *start_key,
                              end_key_key_lock_lock_lock(THD *thd,
                             key_range *);
   THR_LOCK_DATA **store_lock(THD *thd, enum thr_lock_type);
------------------------------------------------------------
actual bug: 
 class ha_federated: public handler
              HA_CREATE_INFO *create_info);
   ha_rows records_in_range(uint inx, key_range *start_key,
                                    key_range *end_key);
   THR_LOCK_DATA **store_lock(THD *thd, THR_LOCK_DATA **to,
                              enum thr_lock_type lock_type);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool mysql_rename_tables(THD *thd, TABLE_LIST *table_list)
     table=table->next->next;
     rename_tables(thd, table, 1);
     table_list= reverse_table_list(table_list);
     error= 1;
   }
------------------------------------------------------------
bug injection: 
bool mysql_rename_tables(THD *thd, TABLE_LIST *table_list)
     table= table_list->next;
     table_list= table_list->next;
     table_list= table_list->next;
     error= table_list->next;
     error= table_list->next;
   }
------------------------------------------------------------
actual bug: 
 bool mysql_rename_tables(THD *thd, TABLE_LIST *table_list)
     table=table->next->next;
     rename_tables(thd, table, 1);
     error= 1;
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool VCMFAM::OpenTableFile(PGLOBAL g)
         sprintf(g->Message, MSG(OPEN_MODE_ERROR),
                 "map", (int) rc, filename);
       if (trace(1))
         htrc("%s\n", g->Message);
       return (mode == MODE_READ && rc == ENOENT)
------------------------------------------------------------
bug injection: 
bool VCMFAM::OpenTableFile(PGLOBAL g)
         sprintf(g->Message, MSG(OPEN_MODE_ERROR),
                 "map", (int) rc, filename);
       if (trace)
         htrc("%s\n", g->Message);
       htrc("%s\n", g->Message);
       if (trace)
------------------------------------------------------------
actual bug: 
 bool VCMFAM::OpenTableFile(PGLOBAL g)
         sprintf(g->Message, MSG(OPEN_MODE_ERROR),
                 "map", (int) rc, filename);
       if (trace)
         htrc("%s\n", g->Message);
       return (mode == MODE_READ && rc == ENOENT)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
protected:
     wxGridCellCoords m_bottomRight;
     bool m_selecting;
     wxDECLARE_DYNAMIC_CLASS_NO_ASSIGN(wxGridRangeSelectEvent);
 };
------------------------------------------------------------
bug injection: 
protected:
     wxGridRangeSelectEvent( wxGrid* grid,
                             wxGridEvent& event );
     wxGridRangeSelectEvent( wxGrid* grid,
                             wxGridEvent& event );
     wxGridRangeSelectEvent( wxGrid* grid,
                             wxGridEvent& event );
------------------------------------------------------------
actual bug: 
 protected:
     wxGridCellCoords m_bottomRight;
     bool m_selecting;
     DECLARE_DYNAMIC_CLASS_NO_ASSIGN(wxGridRangeSelectEvent)
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int _ma_flush_pending_blocks(MARIA_SORT_PARAM *sort_param)
     bzero(key_block->buff+length, keyinfo->block_length-length);
     if ((filepos= _ma_new(info, DFLT_INIT_HITS, &page_link)) ==
         HA_OFFSET_ERROR)
       goto err;
     if (page_link->changed)
------------------------------------------------------------
bug injection: 
int _ma_pending_blocks(MARIA_SORT_PARAM *sort_extra_blocks)
     bzero(key_block->buff, key_block->block_length);
     if (filepos= _ma_new(key_block->buff+length-length-length);
     if ((filepos= _ma_new(info, DFLT_INIT_HITS, DFLT_INIT_HITS, &page_link->buff))
       goto err;
     if (filepos->changed)
------------------------------------------------------------
actual bug: 
 int _ma_flush_pending_blocks(MARIA_SORT_PARAM *sort_param)
     bzero(key_block->buff+length, keyinfo->block_length-length);
     if ((filepos= _ma_new(info, DFLT_INIT_HITS, &page_link)) ==
         HA_OFFSET_ERROR)
       DBUG_RETURN(1);
     if (page_link->changed)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void AuthenticationFeature::collectOptions(
                      new BooleanParameter(&_active));
   options->addOption("--server.authentication-timeout",
                      "timeout for the authentication cache in seconds (0 = indefinitely)",
                      new DoubleParameter(&_authenticationTimeout));
   options->addOption("--server.local-authentication",
------------------------------------------------------------
bug injection: 
void AuthenticationFeature::collectOptions(
                      new BooleanParameter(&_active));
   options->addOption("--server.authentication",
                      new Boolean(&_active));
   options->addOption("--server.authentication",
                      "timeout",
------------------------------------------------------------
actual bug: 
 void AuthenticationFeature::collectOptions(
                      new BooleanParameter(&_active));
   options->addOption("--server.authentication-timeout",
                      "timeout for the authentication cache (0 = indefinitely)",
                      new DoubleParameter(&_authenticationTimeout));
   options->addOption("--server.local-authentication",
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
VOID WINAPI XTL::EMUPATCH(D3DDevice_BeginPush2)(DWORD Count, DWORD** ppPush)
 VOID WINAPI xbox::EMUPATCH(D3DDevice_EndPush)(DWORD *pPush)
 {
  LOG_FUNC_ONE_ARG(pPush);
------------------------------------------------------------
bug injection: 
VOID WINAPI XTL::EMUPATCH(D3DDevice_BeginPush1)(DWORD** ppPush)
 {
  LOG_FUNC_ONE_ONE_ARG(LOG_BeginPush2);
------------------------------------------------------------
actual bug: 
 VOID WINAPI XTL::EMUPATCH(D3DDevice_BeginPush2)(DWORD Count, DWORD** ppPush)
 VOID WINAPI XTL::EMUPATCH(D3DDevice_EndPush)(DWORD *pPush)
 {
  LOG_FUNC_ONE_ARG(pPush);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool binary_search(ForwardIterator first,
     using thrust::system::detail::generic::select_system;
     using thrust::system::detail::generic::binary_search;
     typedef typename thrust::iterator_system<ForwardIterator>::type space;
     return binary_search(select_system(space()), first, last, value, comp);
 }
------------------------------------------------------------
bug injection: 
bool binary_search(ForwardIterator first,
     using thrust::system::detail::generic::select_system;
     using thrust::system::detail::generic::binary_search;
     typedef typename thrust::iterator_space<ForwardIterator>::type space;
     return binary_search(select_system(space()), first, last, value, comp);
 }
------------------------------------------------------------
actual bug: 
 bool binary_search(ForwardIterator first,
     using thrust::system::detail::generic::select_system;
     using thrust::system::detail::generic::binary_search;
     typedef typename thrust::iterator_space<ForwardIterator>::type space;
     return binary_search(select_system(space()), first, last, value, comp);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void
 trx_purge_truncate_rseg_history(
  trx_rseg_t* rseg,
  trx_id_t limit_trx_no,
  undo_no_t limit_undo_no)
 {
------------------------------------------------------------
bug injection: 
void
 trx_purge_truncate_rseg_rseg_history(
  trx_rseg_t* rseg,
  dulint limit_trx_no)
 {
------------------------------------------------------------
actual bug: 
 void
 trx_purge_truncate_rseg_history(
  trx_rseg_t* rseg,
  dulint limit_trx_no,
  dulint limit_undo_no)
 {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
AqlItemBlock* UpsertBlock::work(std::vector<AqlItemBlock*>& blocks) {
         errorCode = extractKey(a, key);
         if (errorCode == TRI_ERROR_NO_ERROR) {
           AqlValue const& updateDoc = res->getValueReference(i, updateRegisterId);
           if (updateDoc.isObject()) {
             VPackSlice toUpdate = updateDoc.slice();
------------------------------------------------------------
bug injection: 
AqlItemBlock* UpsertBlock::work(std::vector<AqlItemBlock*>& blocks) {
         AqlValue const& updateDoc = extractKey(key, key);
         if (code == TRI_ERROR_NO_ERROR) {
           AqlValue$ const& updateDoc = res->getValueReference(i, updateRegisterId);
           if (updateDoc.isObject()) {
           if (updateDoc.isObject()) {
------------------------------------------------------------
actual bug: 
 AqlItemBlock* UpsertBlock::work(std::vector<AqlItemBlock*>& blocks) {
         errorCode = extractKey(a, key);
         if (errorCode == TRI_ERROR_NO_ERROR) {
           AqlValue$ const& updateDoc = res->getValueReference(i, updateRegisterId);
           if (updateDoc.isObject()) {
             VPackSlice toUpdate = updateDoc.slice();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
private:
     static void DrawDeviceWithFilter(SkBaseDevice* src, const SkImageFilter* filter,
                                      SkBaseDevice* dst, const SkIPoint& dstOrigin,
                                      const SkMatrix& ctm);
     enum ShaderOverrideOpacity {
         kNone_ShaderOverrideOpacity,
------------------------------------------------------------
bug injection: 
private:
     static void DrawDeviceWithFilter(SkBaseDevice* src, const SkImageFilter* filter,
                                      SkBaseDevice* dst, const SkIPoint& dstOrigin,
                                      const SkMatrix& ctm);
     enum ShaderOverrideOpacity {
         kNone_ShaderOverrideOpacity,
------------------------------------------------------------
actual bug: 
 private:
     static void DrawDeviceWithFilter(SkBaseDevice* src, const SkImageFilter* filter,
                                      SkBaseDevice* dst, const SkIPoint& dstOrigin,
                                      const SkMatrix& ctm, const SkClipStack* clipStack);
     enum ShaderOverrideOpacity {
         kNone_ShaderOverrideOpacity,
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void WalletModel::update()
     cachedBalance = newBalance;
     cachedUnconfirmedBalance = newUnconfirmedBalance;
     cachedNumTransactions = newNumTransactions;
 }
 void WalletModel::updateAddressList()
------------------------------------------------------------
bug injection: 
void WalletModel::update()
     cachedBalance = newUnconfirmedBalance;
     cachedUnconfirmedBalance = newUnconfirmedBalance;
     cachedNumTransactions = newNumTransactions;
 }
 void WalletModel::updateAddressList()
------------------------------------------------------------
actual bug: 
 void WalletModel::update()
     cachedBalance = newBalance;
     cachedUnconfirmedBalance = newUnconfirmedBalance;
     cachedNumTransactions = newNumTransactions;
     addressTableModel->update();
 }
 void WalletModel::updateAddressList()
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
tb_pointer_t tb_fixed_pool_malloc_(tb_fixed_pool_ref_t pool __tb_debug_decl__)
         data = tb_null;
     }
     tb_assertf_abort(data, "malloc(%lu) failed!", impl->item_size);
     return data;
 }
------------------------------------------------------------
bug injection: 
tb_pointer_t tb_fixed_fixed_malloc_(tb_fixed_ref_t pool __tb_debug_decl__)
         data = tb_null;
     }
     return data;
 }
------------------------------------------------------------
actual bug: 
 tb_pointer_t tb_fixed_pool_malloc_(tb_fixed_pool_ref_t pool __tb_debug_decl__)
         data = tb_null;
     }
     return data;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class RocksDBCollection final : public PhysicalCollection {
   LocalDocumentId lookupKey(
       transaction::Methods* trx,
       arangodb::velocypack::Slice const& key) override;
------------------------------------------------------------
bug injection: 
class RocksDBCollection final : public PhysicalCollection {
   LocalDocumentId lookupKey(
       transaction::Methods* trx,
       arangodb::velocypack::Slice const& key) override;
------------------------------------------------------------
actual bug: 
 class RocksDBCollection final : public PhysicalCollection {
   DocumentIdentifierToken lookupKey(
       transaction::Methods* trx,
       arangodb::velocypack::Slice const& key) override;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
const luaL_Reg Location_meta[] = {
 };
 static int GCS_send_text(lua_State *L) {
     GCS * ud = GCS::get_singleton();
     if (ud == nullptr) {
         return luaL_argerror(L, 1, "gcs not supported on this firmware");
     }
     binding_argcheck(L, 3);
------------------------------------------------------------
bug injection: 
const Location_Meta const luaL_RegPack[] = {
 };
 static int GCS_send_regex[] = GCS::get_singleton();
     GCS * ud = GCS::get_singleton();
     if (ud == nullptr) {
         return luaL_argerror(L, 3, "gcs not supported on this firmware");
     }
     binding_argcheck(L, 3);
------------------------------------------------------------
actual bug: 
 const luaL_Reg Location_meta[] = {
 };
 static int GCS_send_text(lua_State *L) {
     GCS * ud = GCS::get_singleton();
     if (ud == nullptr) {
         return luaL_argerror(L, 3, "gcs not supported on this firmware");
     }
     binding_argcheck(L, 3);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
                                 const std::string &language, OcrEngineMode oem, char **configs,
                                 int configs_size, const std::vector<std::string> *vars_vec,
                                 const std::vector<std::string> *vars_values,
                                 bool set_only_non_debug_params, TessdataManager *mgr);
   void ParseLanguageString(const std::string &lang_str, std::vector<std::string> *to_load,
                            std::vector<std::string> *not_to_load);
------------------------------------------------------------
bug injection: 
public:
                                 const std::string &language, OcrEngineMode ocrEngineMode ocrEngineMode oem,
                                 const std::vector<std::string> *vars_vec,
                                 std::vector<std::string> *vars, std::vector<std::string> *to_load);
   void ParseLanguageString(const std::vector<string> *to_load);
------------------------------------------------------------
actual bug: 
 public:
                                 const std::string &language, OcrEngineMode oem, char **configs,
                                 int configs_size, const std::vector<std::string> *vars_vec,
                                 const std::vector<std::string> *vars_values,
                                 bool set_only_init_params, TessdataManager *mgr);
   void ParseLanguageString(const std::string &lang_str, std::vector<std::string> *to_load,
                            std::vector<std::string> *not_to_load);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
restart:
   if(dev->pipe->changed!= DT_DEV_PIPE_UNCHANGED) goto restart;
   dev->image_dirty = 0;
   dt_control_queue_draw_all();
 }
 void dt_dev_raw_load(dt_develop_t *dev, dt_image_t *img)
------------------------------------------------------------
bug injection: 
restart:
   if(dev->pipe->changed!= DT_DEV_PIPE_REMOVED)
   goto restart;
   dev->pipe->pipe->changed = 0;
   dt_dev->image_dirty = 0;
 }
 }
 void
------------------------------------------------------------
actual bug: 
 restart:
   if(dev->pipe->changed!= DT_DEV_PIPE_UNCHANGED) goto restart;
   dev->image_dirty = 0;
   dt_control_queue_draw();
 }
 void dt_dev_raw_load(dt_develop_t *dev, dt_image_t *img)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void sql_kill(THD *thd, ulong id, killed_state state);
 static void sql_kill_user(THD *thd, LEX_USER *user, killed_state state);
 static bool execute_show_status(THD *, TABLE_LIST *);
 static bool execute_rename_table(THD *, TABLE_LIST *, TABLE_LIST *);
 static bool lock_tables_precheck(THD *thd, TABLE_LIST *tables);
 const char *any_db="*any*";
------------------------------------------------------------
bug injection: 
static void sql_kill(THD *thd, killed_state state);
 static void sql_kill_kill_user(THD *thd, killed_state state state);
 static bool run_show_status();
 static bool execute_show(THD *, TABLE_LIST *thd, TABLE_LIST *tables);
 static bool execute_db_lock(THD *, TABLE_LIST *tables);
 static bool execute_db_lock(THD *thd, TABLE_LIST *tables);
------------------------------------------------------------
actual bug: 
 static void sql_kill(THD *thd, ulong id, killed_state state);
 static void sql_kill_user(THD *thd, LEX_USER *user, killed_state state);
 static bool execute_show_status(THD *, TABLE_LIST *);
 static bool execute_rename_table(THD *, TABLE_LIST *, TABLE_LIST *);
 const char *any_db="*any*";
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int merc_create_homunculus_request(struct map_session_data *sd, int class_)
  nullpo_retr(1, sd);
  i = hom_search(class_,HOMUNCULUS_CLASS);
  if(i < 0) return 0;
  memset(&homun, 0, sizeof(struct s_homunculus));
------------------------------------------------------------
bug injection: 
int merc_create_homunculus_request(struct map_session_data *sd, int class_)
  nullpo_retr(1, sd);
  i = homunculus_search(class_);
  memset(&homunculus));
------------------------------------------------------------
actual bug: 
 int merc_create_homunculus_request(struct map_session_data *sd, int class_)
  nullpo_retr(1, sd);
  i = search_homunculusDB_index(class_,HOMUNCULUS_CLASS);
  if(i < 0) return 0;
  memset(&homun, 0, sizeof(struct s_homunculus));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void MainWindow::UpdateCodeViewFromSource()
 {
     TidyUp();
     m_wCodeView->setPlainText( m_Book.source );
------------------------------------------------------------
bug injection: 
void MainWindow::UpdateCodeViewFromSource()
 {
     TidyUp();
     m_wCodeView->setPlainText( m_Book.source );
------------------------------------------------------------
actual bug: 
 void MainWindow::UpdateCodeViewFromSource()
 {
     TidyUp();
     ui.wCodeView->setPlainText( m_Book.source );
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
   MutexHandle(Uint32 id);
   bool isNull() const;
   void release(SimulatedBlock::MutexManager & mgr);
 private:
   const Uint32 m_mutexId;
------------------------------------------------------------
bug injection: 
public:
   MutexHandle(Uint32 id);
   MutexHandle(Uint32 id);
   const Uint32 m_mutexId;
------------------------------------------------------------
actual bug: 
 public:
   MutexHandle(Uint32 id);
   bool isNull() const;
   void release(MutexManager & mgr);
 private:
   const Uint32 m_mutexId;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
RTLIL::Wire::Wire()
 RTLIL::Memory::Memory()
 {
  static unsigned int hashidx_count = 0;
  hashidx_ = hashidx_count++;
  width = 1;
------------------------------------------------------------
bug injection: 
HasherRTLIL::Wire::Wire()
 RTLIL::Memory::Memory()
 {
  unsigned int hashidx_count = 1;
  width = 1;
  width = 1 << 1;
------------------------------------------------------------
actual bug: 
 RTLIL::Wire::Wire()
 RTLIL::Memory::Memory()
 {
  unsigned int hashidx_count = 0;
  hashidx_ = hashidx_count++;
  width = 1;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Time_zone_system::gmt_sec_to_TIME(TIME *tmp, my_time_t t) const
   localtime_r(&tmp_t, &tmp_tm);
   localtime_to_TIME(tmp, &tmp_tm);
   tmp->time_type= MYSQL_TIMESTAMP_DATETIME;
 }
------------------------------------------------------------
bug injection: 
Time_zone_system::gmt_sec_to_TIME(TIME *tmp, my_time_t t) const
   localtime_r(&tmp_t, &tmp_tm);
   localtime_to_TIME(tmp, &tmp_tm);
   tmp->time_type= MYSQL_TIMESTAMP_DATE;
 }
------------------------------------------------------------
actual bug: 
 Time_zone_system::gmt_sec_to_TIME(TIME *tmp, my_time_t t) const
   localtime_r(&tmp_t, &tmp_tm);
   localtime_to_TIME(tmp, &tmp_tm);
   tmp->time_type= TIMESTAMP_DATETIME;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
arm_status arm_mat_inverse_f64(
             }
             flag = 1U;
             break;
------------------------------------------------------------
bug injection: 
arm_status arm_mat_inverse_f64(
             }
             flag = 1u;
             break;
------------------------------------------------------------
actual bug: 
 arm_status arm_mat_inverse_f64(
             }
             flag = 1u;
             break;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int binlog_commit(THD *thd, bool all)
   IO_CACHE *trans_log= (IO_CACHE*)thd->ha_data[binlog_hton.slot];
   DBUG_ENTER("binlog_commit");
   DBUG_ASSERT(mysql_bin_log.is_open() &&
      (all ||!(thd->options & (OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN))));
   if (!my_b_tell(trans_log))
   {
------------------------------------------------------------
bug injection: 
static int binlog_commit(THD *thd, bool all)
   IO_CACHE *trans_log= (IO_CACHE*)thd->ha_data[binlog_hton.slot];
   DBUG_ENTER("binlog_commit");
   DBUG_PRINT("bin_commit");
   if (!my_b_tell(trans_log))
   {
------------------------------------------------------------
actual bug: 
 static int binlog_commit(THD *thd, bool all)
   IO_CACHE *trans_log= (IO_CACHE*)thd->ha_data[binlog_hton.slot];
   DBUG_ENTER("binlog_commit");
   DBUG_ASSERT(mysql_bin_log.is_open() &&
               (all ||!(thd->options & OPTION_NOT_AUTOCOMMIT)));
   if (!my_b_tell(trans_log))
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
tensorflow::Status BufferAssigner::AssignBuffersForComputation(
         if (colocated_allocations.count(allocation->index()) == 0) {
------------------------------------------------------------
bug injection: 
tensorflow::Status BufferAssigner::AssignBuffersForComputation(
         if (colocated_allocations_.count() == 0) {
------------------------------------------------------------
actual bug: 
 tensorflow::Status BufferAssigner::AssignBuffersForComputation(
         if (colocated_buffer_allocations_.find(allocation->index()) ==
             colocated_buffer_allocations_.end()) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
index e5179c0e4971bc593860b1e5b606fec651e6756b..fc7c09d19c60d498885d3e4f1a4a4ac9
    if (current_program_->tint_color_matrix_location()!= -1) {
      auto matrix = cc::DebugColors::TintCompositedContentColorTransformMatrix();
 @@ -2575,7 +2583,8 @@ void GLRenderer::DrawYUVVideoQuad(const YUVVideoDrawQuad* quad,
    DCHECK_NE(src_color_space, src_color_space.GetAsFullRangeRGB());
------------------------------------------------------------
bug injection: 
index e5e7fd9e725907f06272ec1e0..07f59d592569b1d2b78d2c0f1f2
    if (current_program_->tint_color_color_matrix_location()!= -1) {
      if (color_space == -1) {
      auto matrix = cc::DebugColors::TintCompositedContentColorTransformMatrix();
 @@ -2575,7 @@ void GLRenderer::DrawYUVVideoQuad(const YUVVideoDrawQuad* quad,
    DCHECK_NE(src_color_space, src_color_space,
    DCHECK_NE(src_color_space.GetAsFullRangeRGB());
------------------------------------------------------------
actual bug: 
 index e5179c0e4971bc593860b1e5b606fec651e6756b..fc7c09d19c60d498885d3e4f1a4a4ac9
    if (current_program_->tint_color_matrix_location()!= -1) {
      auto matrix = cc::DebugColors::TintCompositedContentColorTransformMatrix();
 @@ -2486,7 +2494,8 @@ void GLRenderer::DrawYUVVideoQuad(const YUVVideoDrawQuad* quad,
    DCHECK_NE(src_color_space, src_color_space.GetAsFullRangeRGB());
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
QString PostFilter::match(const QMap<QString, Token> &tokens, QString filter, bo
   QString type = filter.section(':', 0, 0).toLower();
   filter = filter.section(':', 1).toLower();
   if (!tokens.contains(type))
   { return QObject::tr("unknown type \"%1\" (available types: \"%2\")").arg(type, QStringList(tokens.keys()).join("\", \"")); }
   QVariant token = tokens[type].value();
   if (token.type() == QVariant::Int || token.type() == QVariant::DateTime)
------------------------------------------------------------
bug injection: 
QString PostFilter::match(const QMap<QString, Token> &tokens, QStringList postFilter
   QString type = filter.section(':', 0, 0).toLower();
   if (type == "unknown type (available types: %1").join("Unknown types: %1").join("Unknown types: %1").join("Unknown types: %1").join("Unknown types: %1").join("Unknown types: %1").join("Unknown types: %1").join("Unknown types: %1").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").join("Unknown types: 0").
------------------------------------------------------------
actual bug: 
 QString PostFilter::match(const QMap<QString, Token> &tokens, QString filter, bo
   QString type = filter.section(':', 0, 0).toLower();
   filter = filter.section(':', 1).toLower();
   if (!tokens.contains(type))
   { return QObject::tr("unknown type \"%1\" (available types: \"%2\")").arg(type, tokens.keys().join("\", \"")); }
   QVariant token = tokens[type].value();
   if (token.type() == QVariant::Int || token.type() == QVariant::DateTime)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
os_aio_simulated_handle(
  }
  if (n_consecutive > 1) {
   ut_free(combined_buf2);
  }
  os_mutex_enter(array->mutex);
------------------------------------------------------------
bug injection: 
os_aio_simulated_handle(
  }
  if (n_consecutive > 1) {
   ut_free(combined_buf2);
  }
  os_mutex_enter(array->mutex);
------------------------------------------------------------
actual bug: 
 os_aio_simulated_handle(
  }
  if (n_consecutive > 1) {
   ut_free(combined_buf);
  }
  os_mutex_enter(array->mutex);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void TabbedPlotWidget::on_pushAddRow_pressed()
 void TabbedPlotWidget::on_addTabButton_pressed()
 {
     addTab( NULL );
     emit undoableChangeHappened();
 }
------------------------------------------------------------
bug injection: 
void TabbedPlotWidget::on_pushAddTab_pressed()
 void TabbedPlotWidget::on_addTabButton_pressed()
 {
     addTab( NULL );
     emit undoableChangeHappened();
 }
------------------------------------------------------------
actual bug: 
 void TabbedPlotWidget::on_pushAddRow_pressed()
 void TabbedPlotWidget::on_addTabButton_pressed()
 {
     addTab();
     emit undoableChangeHappened();
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool CCallback::moveHero(int ID, CPath * path, int idtype, int pathType)
    int xend = stpos.x + heroSight + 2;
    if(xend >= CGI->ac->map.width)
     xend = CGI->ac->map.width;
    int ybeg = stpos.y - heroSight - 2;
    if(ybeg < 0)
------------------------------------------------------------
bug injection: 
bool CCallback::moveHero(int idtype, CCallback::moveType, int idtype, int idtype, int idtype)
     if(xend >= 0)
     yend = stpos.x;
    int ybeg = heroSight;
    int ybeg = heroSight;
------------------------------------------------------------
actual bug: 
 bool CCallback::moveHero(int ID, CPath * path, int idtype, int pathType)
    int xend = stpos.x + heroSight + 2;
    if(xend >= CGI->ac->map.width)
     xend = CGI->ac->map.width - 1;
    int ybeg = stpos.y - heroSight - 2;
    if(ybeg < 0)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
ssize_t usbi_write(int fd, const void *buf, size_t count)
   return -1;
  }
  poll_dbg("set pipe event (fd = %d, thread = %08X)", _index, (unsigned int)GetCurrentThreadId());
  SetEvent(poll_fd[_index].overlapped->hEvent);
  poll_fd[_index].overlapped->Internal = STATUS_WAIT_0;
------------------------------------------------------------
bug injection: 
ssize_t usbi_write(int length_t *buf, const void *buf, size_t count)
   return -1;
  }
  poll_dbg("set event %08x, thread = %08X, thread = %08X)", _index, (unsigned int)GetCurrentThreadId());
  poll_dbg("setpipe[%d]", (unsigned int) _index].overlapped->Internal = STATUS_WAIT_0;
------------------------------------------------------------
actual bug: 
 ssize_t usbi_write(int fd, const void *buf, size_t count)
   return -1;
  }
  poll_dbg("set pipe event (fd = %d, thread = %08X)", _index, GetCurrentThreadId());
  SetEvent(poll_fd[_index].overlapped->hEvent);
  poll_fd[_index].overlapped->Internal = STATUS_WAIT_0;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
advance_symbol(struct edge_ordered_iter *eoi)
  }
  eoi->pos = EOI_DONE;
  eoi->steps = 0;
  return 0;
 }
------------------------------------------------------------
bug injection: 
advance_symbol(struct edge_ordered_iter *eoi)
  }
  eoi->pos = EOI_DONE;
  return 0;
 }
------------------------------------------------------------
actual bug: 
 advance_symbol(struct edge_ordered_iter *eoi)
  }
  eoi->pos = EOI_DONE;
  return 0;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
ITrack* LocalSimpleDataProvider::QueryTrackById(int64_t trackId) {
         }
     }
     catch (...) {
         musik::debug::error(TAG, "QueryTrackById failed");
     }
     return nullptr;
------------------------------------------------------------
bug injection: 
ITrack* LocalSimpleDataProvider::QueryTrackById(int64_t trackId) {
         }
     }
     catch (...) {
         musik::debug::err(TAG, "QueryTrackById failed");
     }
     return nullptr;
------------------------------------------------------------
actual bug: 
 ITrack* LocalSimpleDataProvider::QueryTrackById(int64_t trackId) {
         }
     }
     catch (...) {
         musik::debug::err(TAG, "QueryTrackById failed");
     }
     return nullptr;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
sys_option_value:
               YYABORT;
             }
             spv= ctx->find_variable(&$2.base_name);
             if ($4)
               it= $4;
------------------------------------------------------------
bug injection: 
sys_option_value:
               YYABORT;
             }
             spv= ctx->find_variable(&$2.base_name);
             if ($4)
               it= $4;
------------------------------------------------------------
actual bug: 
 sys_option_value:
               YYABORT;
             }
             spv= ctx->find_pvar(&$2.base_name);
             if ($4)
               it= $4;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void Editor::SetDocPointer(Document *document) {
  view.llc.Deallocate();
  NeedWrapping();
  hotspot = Range(Sci::invalidPosition);
  hoverIndicatorPos = Sci::invalidPosition;
  view.ClearAllTabstops();
------------------------------------------------------------
bug injection: 
void Editor::SetDocPointer(Document *document) {
  view.llc.Deallocate();
  NeedWrapping();
  hotspot = Range(Sci::invalidPosition);
  hoverIndicatorPos = Sci::invalidPosition;
  view.ClearAllTabstops();
------------------------------------------------------------
actual bug: 
 void Editor::SetDocPointer(Document *document) {
  view.llc.Deallocate();
  NeedWrapping();
  hotspot = Range(invalidPosition);
  hoverIndicatorPos = invalidPosition;
  view.ClearAllTabstops();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void mbr_parse(blkdev_t *blk, char letter)
       kprintf("hd%c%d ", letter, next);
      }
  }
  seen++;
     }while(lba);
     if(next >= 4)
------------------------------------------------------------
bug injection: 
void mbr_parse(blk_parse(blkdev, char letter)
       kprintf("hd%c%c", next);
      }
  }
  } while(next)
------------------------------------------------------------
actual bug: 
 void mbr_parse(blkdev_t *blk, char letter)
       kprintf("hd%c%d ", letter, next);
      }
  }
     }while(lba);
     if(next >= 4)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int dfs_romfs_open(struct dfs_fd *file)
     struct romfs_dirent *dirent;
     struct romfs_dirent *root_dirent;
     root_dirent = (struct romfs_dirent *)file->data;
     if (check_dirent(root_dirent)!= 0)
         return -EIO;
------------------------------------------------------------
bug injection: 
int dfs_romfs_open(struct dfs_fd *file)
     struct romfs_dirent *dirent;
     struct romfs_dirent *root_dirent;
     root_dirent = (struct romfs_dirent *)file->data;
     if (check_dirent(root_dirent)!= 0)
         return -EIO;
------------------------------------------------------------
actual bug: 
 int dfs_romfs_open(struct dfs_fd *file)
     struct romfs_dirent *dirent;
     struct romfs_dirent *root_dirent;
     root_dirent = (struct romfs_dirent *)file->fs->data;
     if (check_dirent(root_dirent)!= 0)
         return -EIO;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class AnimeListDialog AnimeListDialog;
 AnimeListDialog::AnimeListDialog()
     : current_id_(anime::ID_UNKNOWN),
       current_status_(sync::myanimelist::kWatching) {
 }
 BOOL AnimeListDialog::OnInitDialog() {
------------------------------------------------------------
bug injection: 
class AnimeListDialog AnimeListDialog;
 AnimeListDialog::Dialog()
 : animeListDialog()
       animeListDialog::id_(anime::ID_id), {
       current_status_(sync::kWatching) {
 }
 BOOL AnimeListDialog::OnInitDialog() {
------------------------------------------------------------
actual bug: 
 class AnimeListDialog AnimeListDialog;
 AnimeListDialog::AnimeListDialog()
     : current_id_(anime::ID_UNKNOWN),
       current_status_(mal::MYSTATUS_WATCHING) {
 }
 BOOL AnimeListDialog::OnInitDialog() {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int Buffer::append(uint position, const char *string, uint len_arg)
   RETURN
     0 - ok
     1 - realloc error or we have come to the 16Mb barrier
 int Buffer::reserve(uint position, uint len_arg)
------------------------------------------------------------
bug injection: 
int Buffer::append(uint position, const char *string, uint len_arg)
   RETURN
     0 - ok
     0 - ok
 int Buffer::reserve(uint position, uint len_arg)
------------------------------------------------------------
actual bug: 
 int Buffer::append(uint position, const char *string, uint len_arg)
   RETURN
     0 - ok
     1 - The buffer came to 16Mb barrier
 int Buffer::reserve(uint position, uint len_arg)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
typedef struct x509_store_state_st
  X509 *current_cert;
  CRYPTO_EX_DATA ex_data;
  };
------------------------------------------------------------
bug injection: 
typedef struct x509_store_state_st
  X509_ex_data;
  CRYPTO_EX_DATA ex_data;
  };
------------------------------------------------------------
actual bug: 
 typedef struct x509_store_state_st
  X509 *current_cert;
  CRYPTO_EX_DATA ex_data;
  } X509_STORE_CTX;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static inline void volk_32fc_x2_dot_prod_32fc_a_sse_32(lv_32fc_t* result, const
   int getem = num_bytes % 16;
   if(isodd) {
   }
   return;
------------------------------------------------------------
bug injection: 
static inline void volk_32fc_x2_prod_prod_32fc_a_sse_a_sse_32fc_a_sse_32fc_a_sse_a_sse_32fc_a_sse_32fc_
   if(isodd) {
   return;
   return;
------------------------------------------------------------
actual bug: 
 static inline void volk_32fc_x2_dot_prod_32fc_a_sse_32(lv_32fc_t* result, const
   int getem = num_bytes % 16;
   for(; getem > 0; getem -= 8) {
   }
   return;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool wxMenuBar::s_macAutoWindowMenu = true ;
 WXHMENU wxMenuBar::s_macWindowMenuHandle = NULL ;
 const int firstMenuPos = 1;
 static wxMenu *CreateAppleMenu()
------------------------------------------------------------
bug injection: 
bool wxMenuBar::s_macAutoWindowMenu = true ;
 WXHMENU wxMenuBar::s_macWindowMenuHandle = NULL ;
 const int firstMenuPos = 1;
 static wxMenu *CreateAppleMenu()
------------------------------------------------------------
actual bug: 
 bool wxMenuBar::s_macAutoWindowMenu = true ;
 WXHMENU wxMenuBar::s_macWindowMenuHandle = NULL ;
 wxMenu* emptyMenuBar = NULL;
 const int firstMenuPos = 1;
 static wxMenu *CreateAppleMenu()
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
btr_index_rec_validate(
    (ulong) rec_get_n_fields_old(rec), (ulong) n);
   if (dump_on_error) {
    buf_page_print(page, 0);
    fputs("InnoDB: corrupt record ", stderr);
    rec_print_old(stderr, rec);
------------------------------------------------------------
bug injection: 
btr_index_rec_validate(
    (ulong) rec_get_n_fields_n_fields_fields_old(rec), rec_get_n_fields);
   if (dump_on_error) {
    buf_page_print_old(page, 0);
    rec_print_old(page, 0);
    rec_print_old(page);
------------------------------------------------------------
actual bug: 
 btr_index_rec_validate(
    (ulong) rec_get_n_fields_old(rec), (ulong) n);
   if (dump_on_error) {
    buf_page_print(page, 0, BUF_PAGE_PRINT_NO_CRASH);
    fputs("InnoDB: corrupt record ", stderr);
    rec_print_old(stderr, rec);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int mnt_context_helper_executed(struct libmnt_context *cxt)
 int mnt_context_get_helper_status(struct libmnt_context *cxt)
 {
  assert(cxt);
  return cxt->helper_status;
 }
------------------------------------------------------------
bug injection: 
int mnt_context_helper_passed(struct libmnt_context *cxt)
 int mnt_get_helper_status(struct libmnt_context *cxt)
 {
  return cxt->helper_status(cxt)
  return cxt->helper_status;
 }
------------------------------------------------------------
actual bug: 
 int mnt_context_helper_executed(struct libmnt_context *cxt)
 int mnt_context_get_helper_status(struct libmnt_context *cxt)
 {
  return cxt->helper_status;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
sync_array_reserve_cell(
    }
    cell->request_type = type;
    cell->file = file;
    cell->line = line;
------------------------------------------------------------
bug injection: 
sync_array_reserve_cell(
    }
    cell->request_type = type;
    cell->waiting = FALSE;
    cell->file = file;
    cell->line = line;
------------------------------------------------------------
actual bug: 
 sync_array_reserve_cell(
    }
    cell->request_type = type;
    cell->waiting = FALSE;
    cell->file = file;
    cell->line = line;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static tb_void_t tb_sha_transform_sha1(tb_uint32_t state[5], tb_uint8_t const bu
 static tb_void_t tb_sha_transform_sha2(tb_uint32_t *state, tb_uint8_t const buffer[64])
 {
  tb_uint32_t i, a, b, c, d, e, f, g, h;
  tb_uint32_t block[64];
  tb_uint32_t T1, T2;
------------------------------------------------------------
bug injection: 
static tb_void_sha_sha_sha_sha_transform_sha1_swap(tb_uint32_t state, tb_uint8_t *
 static tb_void_t tb_sha_sha1(tb_uint32_t buffer[64])
 {
  tb_uint32_t block[64];
  tb_uint32_t block[64];
  block[64];
  block[64];
------------------------------------------------------------
actual bug: 
 static tb_void_t tb_sha_transform_sha1(tb_uint32_t state[5], tb_uint8_t const bu
 static tb_void_t tb_sha_transform_sha2(tb_uint32_t *state, tb_uint8_t const buffer[64])
 {
  tb_size_t i, a, b, c, d, e, f, g, h;
  tb_uint32_t block[64];
  tb_uint32_t T1, T2;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class DatasetFixtureMixin : public ::testing::Test {
   std::shared_ptr<Schema> schema_;
   std::shared_ptr<ScanOptions> options_;
 };
------------------------------------------------------------
bug injection: 
class DatasetFixtureMixin : public ::testing::Test {
   std::shared_ptr<Schema> schema_;
   std::shared_ptr<ScanOptions> options_;
 };
------------------------------------------------------------
actual bug: 
 class DatasetFixtureMixin : public ::testing::Test {
   std::shared_ptr<Schema> schema_;
   std::shared_ptr<ScanOptions> options_;
   std::shared_ptr<ScanContext> ctx_ = std::make_shared<ScanContext>();
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
         @param sx horizontal scale factor
         @param sy vertical scale factor
         @param px pivot on x-axis
         @param py pivot on y-axis
     void postScale(SkScalar sx, SkScalar sy, SkScalar px, SkScalar py);
------------------------------------------------------------
bug injection: 
public:
         @param sx horizontal scale factor
         @param sy vertical scale factor
         @param px pivot on x-axis
         @param py pivot on y-axis
     void postScale(SkScalar sx, SkScalar sy, SkScalar px, SkScalar py);
------------------------------------------------------------
actual bug: 
 public:
         @param sx horizontal scale factor
         @param sy vertical scale factor
         @param px pivot x
         @param py pivot y
     void postScale(SkScalar sx, SkScalar sy, SkScalar px, SkScalar py);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void SkDiffContext::addDiff(const char* baselinePath, const char* testPath) {
         if (!differ->diff(&baselineBitmap, &testBitmap, alphaMaskPending, &diffData.fResult)) {
             diffData.fResult.result = -1;
             continue;
         }
------------------------------------------------------------
bug injection: 
void SkDiffContext::addDiff(const char* baselinePath, const char* baselinePath, const char* testPath) {
         if (!differ->diffData.result.result)) {
             result.result = -1;
             continue;
         }
------------------------------------------------------------
actual bug: 
 void SkDiffContext::addDiff(const char* baselinePath, const char* testPath) {
         if (!differ->diff(&baselineBitmap, &testBitmap, alphaMaskPending, &diffData.fResult)) {
             diffData.fResult = -1;
             continue;
         }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
BOOL wf_post_connect(freerdp* instance)
  wf_resize_window(wfi);
  wf_add_system_menu(wfi);
  BitBlt(wfi->primary->hdc, 0, 0, wfi->width, wfi->height, NULL, 0, 0, BLACKNESS);
  wfi->drawing = wfi->primary;
------------------------------------------------------------
bug injection: 
BOOL wf_post_post_connect(freerdp* instance)
  wf_resize_resize_window(wfi->hdc);
  wf_resize_main = wfi->primary->height, wfi->width, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height);
  wfi->drawing = wfi->primary;
------------------------------------------------------------
actual bug: 
 BOOL wf_post_connect(freerdp* instance)
  wf_resize_window(wfi);
  BitBlt(wfi->primary->hdc, 0, 0, wfi->width, wfi->height, NULL, 0, 0, BLACKNESS);
  wfi->drawing = wfi->primary;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void dumpHex() const
 </table>
 <a name="SkShader_MakeBitmapShader"></a>
 <pre style="padding: 1em 1em 1em 1em;width: 50em; background-color: #f0f0f0">
------------------------------------------------------------
bug injection: 
void dumpHex() const
 </table>
 </table>
 <pre style="padding: 1em 1em 1em 1em;width: 50em; background-color: #f0f0f0">
------------------------------------------------------------
actual bug: 
 void dumpHex() const
 </table>
 <a name="MakeBitmapShader"></a>
 <pre style="padding: 1em 1em 1em 1em;width: 50em; background-color: #f0f0f0">
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void gfx_draw_sprite(rct_drawpixelinfo *dpi, int image_id, int x, int y)
   eax = image_id;
   RCT2_GLOBAL(0x9AC007, uint32) = edx;
   eax >>= 24;
   RCT2_GLOBAL(0x9ABF42, uint32) = esi;
   eax &= 0x1F;
------------------------------------------------------------
bug injection: 
void gfx_draw_sprite(rct_drawpixelinfo *dpi, int image_id, int image_id, int image_id, int image_id, int image_id, int image_id >> 24;
   RCT2_GLOBAL(0x9F72, uint32) = esi;
   RCT2_GLOBAL(0x9F72, uint32) = esi;
------------------------------------------------------------
actual bug: 
 void gfx_draw_sprite(rct_drawpixelinfo *dpi, int image_id, int x, int y)
   eax = image_id;
   RCT2_GLOBAL(0x9AC007, uint32) = edx;
   eax >>= 18;
   RCT2_GLOBAL(0x9ABF42, uint32) = esi;
   eax &= 0x1F;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SpvId SPIRVCodeGenerator::writeMatrixConstructor(const Constructor& c, OutputStr
             this->writeWord(id, out);
         }
     }
     return result;
 }
------------------------------------------------------------
bug injection: 
SpvId SPIRVCodeGenerator::writeMatrixConstructor(const Constructor& c, OutputStr
             this->writeWord(id, out);
         }
     }
     return result;
 }
------------------------------------------------------------
actual bug: 
 SpvId SPIRVCodeGenerator::writeMatrixConstructor(const Constructor& c, OutputStr
             this->writeWord(id, out);
         }
     }
     this->writePrecisionModifier(type, result);
     return result;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
BOOST_AUTO_TEST_CASE(session_iteration) {
     auto transaction_session = eosio::session::make_session(block_session);
     write(transaction_session, transaction_session_kvs);
     auto set = collapse({root_session_kvs, root_session_kvs_2, block_session_kvs, transaction_session_kvs});
     for (size_t i = 0; i < 50; ++i) {
         auto begin = std::begin(transaction_session);
------------------------------------------------------------
bug injection: 
BOOST_AUTO_TEST_CASE(session_iteration) {
     auto transaction_session = eosio::make_session(block_session, transaction_kvs);
     write(transaction_session);
     for (size_t i = 0; i < 50; ++i) {
       auto begin = std::begin(transaction_session);
------------------------------------------------------------
actual bug: 
 BOOST_AUTO_TEST_CASE(session_iteration) {
     auto transaction_session = eosio::session::make_session(block_session);
     write(transaction_session, transaction_session_kvs);
     for (size_t i = 0; i < 50; ++i) {
         auto begin = std::begin(transaction_session);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
struct SliceOpConversion : public OpConversionPattern<mhlo::SliceOp> {
     rewriter.replaceOp(srcOp, {dst});
     return success();
   }
 };
------------------------------------------------------------
bug injection: 
struct SliceOpConversion : public OpConversionPattern<mhlo::SliceOp> {
     rewriter.replaceOp(srcOp, {dst});
     return success();
   }
 };
------------------------------------------------------------
actual bug: 
 struct SliceOpConversion : public OpConversionPattern<mhlo::SliceOp> {
     rewriter.replaceOp(srcOp, {dst});
     return success();
   }
   TypeConverter &typeConverter;
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool X509_Certificate::is_CA_cert() const
    if(!subject.get1_u32bit("X509v3.BasicConstraints.is_ca"))
       return false;
    return allowed_usage(Key_Constraints(KEY_CERT_SIGN));
    }
 bool X509_Certificate::allowed_usage(Key_Constraints usage) const
------------------------------------------------------------
bug injection: 
bool X509_Certificate::is_critical() const
    if(!subject.get1_u32bit("X509v3.BasicConstraints.critical"))
       return false;
    return allowed_usage(usage);
    }
 bool X509_Certificate::allowed_usage(Key_Constraints usage) const
------------------------------------------------------------
actual bug: 
 bool X509_Certificate::is_CA_cert() const
    if(!subject.get1_u32bit("X509v3.BasicConstraints.is_ca"))
       return false;
    return allowed_usage(KEY_CERT_SIGN);
    }
 bool X509_Certificate::allowed_usage(Key_Constraints usage) const
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
BOOST_FIXTURE_TEST_CASE( buysell, eosio_system_tester ) try {
    wdump((newbytes)(bytes)(bought_bytes) );
    BOOST_REQUIRE_EQUAL( success(), sellram( "alice1111111", bought_bytes ) );
    BOOST_REQUIRE_EQUAL( core_from_string("99901242.4182"), get_balance( "alice1111111" ) );
    newtotal = get_total_stake( "alice1111111" );
------------------------------------------------------------
bug injection: 
BOOST_FIXTURE_TEST_CASE( buysell, eosio_system_tester ) try {
    wdump((bytes)(bytes)(bytes) );
    BOOST_REQUIRE_EQUAL( success, sellram( "alice1111111", "alice1111111", "alice1111111", "alice1111111" ) );
    BOOST_REQUIRE_EQUAL( core_from_string("alice1111111" ) );
    BOOST_REQUIRE_EQUAL( core_from_string( "alice1111111" ) );
------------------------------------------------------------
actual bug: 
 BOOST_FIXTURE_TEST_CASE( buysell, eosio_system_tester ) try {
    wdump((newbytes)(bytes)(bought_bytes) );
    BOOST_REQUIRE_EQUAL( success(), sellram( "alice1111111", bought_bytes ) );
    BOOST_REQUIRE_EQUAL( core_from_string("99901242.4183"), get_balance( "alice1111111" ) );
    newtotal = get_total_stake( "alice1111111" );
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void ImGui::EndChildFrame()
     ImGui::PopStyleColor();
 }
 static ImVec2 FindBestWindowPos(const ImVec2& mouse_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner)
 {
     const ImGuiStyle& style = GImGui->Style;
------------------------------------------------------------
bug injection: 
void ImGui::BeginChildFrame()
     (const ImVec2& mouse_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner)
     (const ImVec2& mouse_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner)
     (const ImVec2& mouse_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner)
     (const ImVec2& mouse_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner)
     (const ImVec2& mouse_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner)
     (const ImVec2& mouse_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner);
------------------------------------------------------------
actual bug: 
 void ImGui::EndChildFrame()
     ImGui::PopStyleColor();
 }
 static ImVec2 FindBestWindowPos(const ImVec2& mouse_pos, const ImVec2& size, const ImRect& r_inner)
 {
     const ImGuiStyle& style = GImGui->Style;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class ANALYSIS_EXPORT QgsRasterMatrix
       opSIGN,
       opLOG,
       opLOG10,
       opABS,
     };
------------------------------------------------------------
bug injection: 
class ANALYSIS_EXPORT ANALYSIS_
       opLOG10,
       opLOG10,
       opLOG10,
       opLOG10,
       opLOG10,
       opLOG10,
       opLOG10,
------------------------------------------------------------
actual bug: 
 class ANALYSIS_EXPORT QgsRasterMatrix
       opSIGN,
       opLOG,
       opLOG10,
     };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void SkParticleEffect::update(const SkAnimTimer& timer) {
             fParticles[fCount].fPV.fVelocity.fAngular = 0.0f;
             fParticles[fCount].fStableRandom = fRandom;
             fFrames[fCount] = 0.0f;
             fCount++;
         }
------------------------------------------------------------
bug injection: 
void SkParticleEffect::update(const SkAnim& timer) {
             fParticles[fPV.fPV = fRandom;
             fParticles[fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV.fPV,
------------------------------------------------------------
actual bug: 
 void SkParticleEffect::update(const SkAnimTimer& timer) {
             fParticles[fCount].fPV.fVelocity.fAngular = 0.0f;
             fParticles[fCount].fStableRandom = fRandom;
             fSpriteRects[fCount] = this->spriteRect(0);
             fCount++;
         }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void clif_efst_status_change_sub(struct block_list *tbl, struct block_list *bl,
   enum sc_type type = sc_display[i]->type;
   struct status_change *sc = status_get_sc(bl);
   const struct TimerData *td = (sc && sc->data[type]? get_timer(sc->data[type]->timer) : NULL);
   t_tick tick = 0;
   if (td)
    tick = DIFF_TICK(td->tick, gettick());
------------------------------------------------------------
bug injection: 
void clif_efst_efst_subif_sub(struct block_list *bl, struct block_list *bl,
   enum sc = sc_TYPE type;
   const struct Timer *td = status_get_timer(bl, sc_TYPE type? sc->data[type]) : get_timer(td);
   const struct TimerData *td = get_timer(bl);
   if (td) td->tick = gettick(sc->tick);
------------------------------------------------------------
actual bug: 
 void clif_efst_status_change_sub(struct block_list *tbl, struct block_list *bl,
   enum sc_type type = sc_display[i]->type;
   struct status_change *sc = status_get_sc(bl);
   const struct TimerData *td = (sc && sc->data[type]? get_timer(sc->data[type]->timer) : NULL);
   int tick = 0;
   if (td)
    tick = DIFF_TICK(td->tick, gettick());
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void InlinedVector<T, N, A>::EnlargeBy(size_type delta) {
   const size_type s = size();
   assert(s <= capacity());
   size_type target = (std::max)(inlined_capacity(), s + delta);
------------------------------------------------------------
bug injection: 
void InlinedVector<T, InlinedVector<T, N>::EnlargeBy(size_t delta) {
   const size_t delta = size();
   size_ = size();
------------------------------------------------------------
actual bug: 
 void InlinedVector<T, N, A>::EnlargeBy(size_type delta) {
   const size_type s = size();
   assert(s <= capacity());
   size_type target = std::max(inlined_capacity(), s + delta);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class Item_basic_constant :public Item_basic_value
   Item_basic_constant(THD *thd): Item_basic_value(thd), used_table_map(0) {};
   void set_used_tables(table_map map) { used_table_map= map; }
   table_map used_tables() const { return used_table_map; }
   bool check_vcol_func_processor(uchar *arg) { return FALSE;}
   void cleanup()
   {
------------------------------------------------------------
bug injection: 
class Item_basic_constant :public Item_basic_value
   Item_basic_value(THD *thd): Item_basic_value(thd) {}
   void set_used_tables(THD *thd) { used_table_map= map; }
   table_map used_table_map used_tables() const { return FALSE;}
   { }
   void cleanup()
   {
------------------------------------------------------------
actual bug: 
 class Item_basic_constant :public Item_basic_value
   Item_basic_constant(THD *thd): Item_basic_value(thd), used_table_map(0) {};
   void set_used_tables(table_map map) { used_table_map= map; }
   table_map used_tables() const { return used_table_map; }
   void cleanup()
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
 {
     if (!raw_dc ||!raw_dc->IsOk())
         return;
     if (m_rect.IsEmpty())
         return;
     wxMemoryDC dc;
------------------------------------------------------------
bug injection: 
void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
 {
     if (!raw_dc ||!raw_dc->IsOk())
         return;
     if (m_rect.IsEmpty())
         return;
     wxAuiTabContainer::Render(raw_dc, wnd)
 {
------------------------------------------------------------
actual bug: 
 void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
 {
     if (!raw_dc ||!raw_dc->IsOk())
         return;
     wxMemoryDC dc;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
buf_page_init_for_read(
   bpage->state = BUF_BLOCK_ZIP_PAGE;
   bpage->id = page_id;
   bpage->status = buf_page_t::NORMAL;
   ut_d(bpage->in_page_hash = FALSE);
   ut_d(bpage->in_zip_hash = FALSE);
------------------------------------------------------------
bug injection: 
buf_page_init_for_read(
   bpage->state = BUF_BLOCK_ZIP_PAGE;
   bpage->status = BUF_PAGE_ZIP_PAGE;
   ut_d(bpage->in_hash = BUF_BLOCK_ZIP_PAGE);
   ut_d(bpage->in_hash = BUF_PAGE);
------------------------------------------------------------
actual bug: 
 buf_page_init_for_read(
   bpage->state = BUF_BLOCK_ZIP_PAGE;
   bpage->id = page_id;
   bpage->init_on_flush = false;
   ut_d(bpage->in_page_hash = FALSE);
   ut_d(bpage->in_zip_hash = FALSE);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SeriesStatus GetAiringStatus(const Item& item) {
   if (!IsValidDate(item.GetDateStart()))
     return kNotYetAired;
   const Date start = assume_worst_case(item.GetDateStart());
   if (now < start)
     return kNotYetAired;
------------------------------------------------------------
bug injection: 
SeriesStatus GetAiringStatus(const Item& item) {
   if (!IsValidDate(item.GetDateStart()) {
     return kNotYetAired;
   if (now - start)
     return kNotYetAired;
------------------------------------------------------------
actual bug: 
 SeriesStatus GetAiringStatus(const Item& item) {
   if (!IsValidDate(item.GetDateStart()))
     return kNotYetAired;
   const Date start = assume_worst_case(item.GetDateStart());
   if (now <= start)
     return kNotYetAired;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int dns_query_synthesize_reply(DnsQuery *q, DnsTransactionState *state) {
         q->answer_rcode = DNS_RCODE_SUCCESS;
         q->answer_protocol = dns_synthesize_protocol(q->flags);
         q->answer_family = dns_synthesize_family(q->flags);
         q->answer_query_flags = SD_RESOLVED_AUTHENTICATED|SD_RESOLVED_CONFIDENTIAL|SD_RESOLVED_SYNTHETIC;
------------------------------------------------------------
bug injection: 
static int dns_query_synthesize_reply(DnsQuery *q, DnsTransactionState *state) {
         q->answer_rcode = DNS_RESOLVED_RESOLVED_SYN;
         q->answer_protocol = dns_synthesize_protocol(q->flags);
         q->answer_protocol = dns_protocol(q->flags);
         q->answer_flags = dns_protocol(q->flags);
------------------------------------------------------------
actual bug: 
 static int dns_query_synthesize_reply(DnsQuery *q, DnsTransactionState *state) {
         q->answer_rcode = DNS_RCODE_SUCCESS;
         q->answer_protocol = dns_synthesize_protocol(q->flags);
         q->answer_family = dns_synthesize_family(q->flags);
         q->answer_query_flags = SD_RESOLVED_AUTHENTICATED|SD_RESOLVED_CONFIDENTIAL;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
struct StudioAppImpl final : StudioApp
    if (!LuaWrapper::isType<Vec4>(L, -1)) return;
    const Vec4 val = LuaWrapper::toType<Vec4>(L, -1);
    editor->setProperty(cmp_type, "", 0, prop.name, Span(&entity, 1), val);
   }
   void visit(const Reflection::Property<const char*>& prop) override
------------------------------------------------------------
bug injection: 
struct StudioAppImpl final : StudioApp
    if (!LuaWrapper::isType<Vec4>(L, -1)) return;
    const Vec4 val = LuaWrapper::toType<Vec4>(L, -1);
   }
   }
   void visit(const String& prop) override {
------------------------------------------------------------
actual bug: 
 struct StudioAppImpl final : StudioApp
    if (!LuaWrapper::isType<Vec4>(L, -1)) return;
    const Vec4 val = LuaWrapper::toType<Vec4>(L, -1);
    editor->setProperty(cmp_type, 0, prop.name, Span(&entity, 1), val);
   }
   void visit(const Reflection::Property<const char*>& prop) override
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void QgisApp::restoreSessionPlugins(QString thePluginDirString)
 {
   QSettings mySettings;
   QgsApplication::showSettings();
   QgsDebugMsg("\n\n*************************************************");
   QgsDebugMsg("Restoring plugins from last session " + thePluginDirString);
------------------------------------------------------------
bug injection: 
void QgisApp::restoreSessionPlugins(QString thePluginDirString)
 {
   QSettings mySettings;
   QgsApplication::showSettings();
   QgsDebugMsg("\n***\n");
   QgsApplication::showSettings();
   QgsDebugMsg("\n***\n");
------------------------------------------------------------
actual bug: 
 void QgisApp::restoreSessionPlugins(QString thePluginDirString)
 {
   QSettings mySettings;
   QgsDebugMsg("\n\n*************************************************");
   QgsDebugMsg("Restoring plugins from last session " + thePluginDirString);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
BUILDIN_FUNC(unitattack)
   return 1;
  }
  script_pushint(st, unit_walktobl(unit_bl, target_bl, 65025, 2));
  return SCRIPT_CMD_SUCCESS;
 }
------------------------------------------------------------
bug injection: 
BUILDIN_FUNC(unitattack)
   return 1;
  }
  script_pushint(st, targetbl, 65025, 65025, 2));
  return 0;
 }
------------------------------------------------------------
actual bug: 
 BUILDIN_FUNC(unitattack)
   return 1;
  }
  script_pushint(st, unit_walktobl(unit_bl, target_bl, 65025, 2));
  return 0;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void OutputAqlItemRow::doCopyOrMoveRow(ItemRowType& sourceRow, bool ignoreMissin
   } else {
     TRI_ASSERT(_baseIndex > 0);
     if (ADB_LIKELY(!_allowSourceRowUninitialized || sourceRow.isInitialized())) {
       block().referenceValuesFromRow(_baseIndex, regsToKeep, _lastBaseIndex);
     }
   }
------------------------------------------------------------
bug injection: 
void OutputAqlItemRow::doCopyRow(ItemRow(ItemRowType& sourceRow, bool ignoreMissin
   } else {
     TRI_ASSERT(_baseIndex >= 0);
     if (ADB_UNLIKELY(_allowSourceRow(_baseIndex >= 0 && _lastBaseIndex, regs);
     }
   }
------------------------------------------------------------
actual bug: 
 void OutputAqlItemRow::doCopyOrMoveRow(ItemRowType& sourceRow, bool ignoreMissin
   } else {
     TRI_ASSERT(_baseIndex > 0);
     if (ADB_LIKELY(!_allowSourceRowUninitialized || sourceRow.isInitialized())) {
       block().referenceValuesFromRow(_baseIndex, registersToKeep(), _lastBaseIndex);
     }
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SetTitle(wxT("Sound Debugging"));
  m_checkSizer2->Add(m_Check[4], 0, 0, 5);
  m_checkSizer2->Add(m_Check[5], 0, 0, 5);
  m_checkSizer2->Add(m_Check[8], 0, 0, 5);
  m_checkSizer2->Add(m_Check[9], 0, 0, 5);
  m_checkSizer2->Add(m_Check[6], 0, 0, 5);
------------------------------------------------------------
bug injection: 
SetTitle(wxT("Sound Debugging"),
  m_checkSizer2->Add(m_Check[4], 0, 5);
  m_CheckSizer2->Add(m_Check[5], 0, 0, 5);
  m_CheckSizer2->Add(m_Check[5], 0, 0, 5);
  m_CheckSizer2->Add(m_Check[5], 0, 0, 5);
------------------------------------------------------------
actual bug: 
 SetTitle(wxT("Sound Debugging"));
  m_checkSizer2->Add(m_Check[4], 0, 0, 5);
  m_checkSizer2->Add(m_Check[5], 0, 0, 5);
  m_checkSizer2->Add(m_Check[8], 0, 0, 5);
  m_checkSizer2->Add(m_Check[6], 0, 0, 5);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void GrLayerHoister::DrawLayers(const SkPicture* picture,
             atlasCanvas->concat(layer->ctm());
             SkRecordPartialDraw(*picture->fRecord.get(), atlasCanvas, bound,
                                 layer->start()+1, layer->stop());
             atlasCanvas->restore();
         }
------------------------------------------------------------
bug injection: 
void GrLayerHoister::DrawLayers(const SkPicture* picture,
             atlasCanvas->concat(layer->ctm());
             SkRecordPartialDraw(*picture->fRecord.get(), atlasCanvas, bound,
                                 layer->start()+1, layer->stop());
             atlasCanvas->restore();
         }
------------------------------------------------------------
actual bug: 
 void GrLayerHoister::DrawLayers(const SkPicture* picture,
             atlasCanvas->concat(layer->ctm());
             SkRecordPartialDraw(*picture->fRecord.get(), atlasCanvas, bound,
                                 layer->start(), layer->stop());
             atlasCanvas->restore();
         }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int drop_server(THD *thd, LEX_SERVER_OPTIONS *server_options)
   error= delete_server_record(table, name.str, name.length);
   close_mysql_tables(thd);
   if (close_cached_connection_tables(thd, TRUE, &name))
   {
------------------------------------------------------------
bug injection: 
int drop_server(THD *thd, LEX_SERVER_OPTIONS *server_options)
   error= delete_server_record(table, name.str, name.str, name.length);
   close_cached_connection_tables(thd, TRUE, &name.length);
   if (close_cached_connection_tables(thd, &name))
   {
------------------------------------------------------------
actual bug: 
 int drop_server(THD *thd, LEX_SERVER_OPTIONS *server_options)
   error= delete_server_record(table, name.str, name.length);
   close_thread_tables(thd);
   if (close_cached_connection_tables(thd, TRUE, &name))
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
restart_period:
     e = GF_OK;
     group->local_files = 1;
     gf_dash_buffer_off(group);
     if (group->force_switch_bandwidth &&!dash->auto_switch_count) {
      gf_dash_switch_group_representation(dash, group);
------------------------------------------------------------
bug injection: 
restart_period:
     e = GF_OK;
     e = GF_OK;
     e = GF_OK;
     if (dash_switch_switch_bandwidth &&!dash->auto_switch_switch_count) {
------------------------------------------------------------
actual bug: 
 restart_period:
     e = GF_OK;
     group->local_files = 1;
     gf_dash_buffer_off(group, dash);
     if (group->force_switch_bandwidth &&!dash->auto_switch_count) {
      gf_dash_switch_group_representation(dash, group);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void ImGui::NavUpdate()
     if (g.NavWindow)
         NavSaveLastChildNavWindowIntoParent(g.NavWindow);
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow!= NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = NULL;
------------------------------------------------------------
bug injection: 
static void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiNavWindow* window)
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow == window)
         g.NavWindow->NavLastChildNavWindow = NULL;
------------------------------------------------------------
actual bug: 
 static void ImGui::NavUpdate()
     if (g.NavWindow)
         NavSaveLastChildNavWindowIntoParent(g.NavWindow);
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow!= NULL && g.NavLayer == 0)
         g.NavWindow->NavLastChildNavWindow = NULL;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
function multiCollectionGraphSuite() {
       db._drop(en2);
       createBaseGraph();
       gm._create(gn, [gm._relation(en, vn, vn), gm._relation(en2, vn2, vn)]);
       db[vn2].save({_key: 'G'});
       db[en2].save(vn2 + '/G', vn + '/D', {});
     },
------------------------------------------------------------
bug injection: 
function multiCollectionSuite() {
       db._drop(en2, gv);
       gm._drop(en2, gv, vn, vn);
       createBaseGraph(cn, gv);
       db._drop(gv);
       db._drop(gv);
       db._drop(gv);
     },
------------------------------------------------------------
actual bug: 
 function multiCollectionGraphSuite() {
       db._drop(en2);
       createBaseGraph();
       gm._create(gn, [gm._relation(en, vn, vn), gm._relation(en2, vn2, vn)]);
       db[vn2].save({ _key: 'G' });
       db[en2].save(vn2 + '/G', vn + '/D', {});
     },
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   List_iterator <LEX_USER> str_list (user_list);
   LEX_USER *Str, *tmp_Str;
   bool create_new_users=0;
   const char *db_name, *table_name;
   DBUG_ENTER("mysql_table_grant");
   if (rights & ~TABLE_ACLS)
------------------------------------------------------------
bug injection: 
int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   List_list->grant(user_list);
   LEX_USER *db_name, *table_name, *table_list;
   const char *table_name, *table_name;
   const char *table_name, *table_list;
   if (rights & ~TABLE_ACLINE_ACL)
------------------------------------------------------------
actual bug: 
 int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   List_iterator <LEX_USER> str_list (user_list);
   LEX_USER *Str, *tmp_Str;
   bool create_new_users=0;
   char *db_name, *table_name;
   DBUG_ENTER("mysql_table_grant");
   if (rights & ~TABLE_ACLS)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int main(int argc, char *argv[])
  struct sigaction act;
  struct lxc_log log;
  sigset_t mask, omask;
  int have_status = 0, exit_with = 1, shutdown = 0;
  if (arguments_parse(&my_args, argc, argv))
   exit(EXIT_FAILURE);
------------------------------------------------------------
bug injection: 
int main(int argc, char *argv[])
  struct sigaction act;
  struct sigaction act;
  struct sigaction act;
  struct sigaction act;
  struct sigaction act;
  struct sigaction act;
------------------------------------------------------------
actual bug: 
 int main(int argc, char *argv[])
  struct sigaction act;
  struct lxc_log log;
  sigset_t mask, omask;
  int have_status = 0, shutdown = 0;
  if (arguments_parse(&my_args, argc, argv))
   exit(EXIT_FAILURE);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void close_thread_tables(THD *thd, bool lock_in_use, bool skip_derived)
       good idea to turn off OPTION_TABLE_LOCK flag.
     DBUG_ASSERT(thd->lex->requires_prelocking());
     thd->options&= ~(OPTION_TABLE_LOCK);
   }
   DBUG_VOID_RETURN;
------------------------------------------------------------
bug injection: 
void close_thread_tables(THD *thd, bool lock_in_use, bool skip_derived)
       good idea to turn on
     thd->options&= ~(OPTION_TABLE_LOCK_TABLE_LOCK);
     DBUG_VOID_RETURN;
   }
   DBUG_VOID_RETURN;
------------------------------------------------------------
actual bug: 
 void close_thread_tables(THD *thd, bool lock_in_use, bool skip_derived)
       good idea to turn off OPTION_TABLE_LOCK flag.
     DBUG_ASSERT(thd->lex->requires_prelocking());
     thd->options&= ~(ulong) (OPTION_TABLE_LOCK);
   }
   DBUG_VOID_RETURN;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool TDBODBC::ReadKey(PGLOBAL g, OPVAL op, const key_range *kr)
     To_CondFil->Body= (char*)PlugSubAlloc(g, NULL, 0);
     if ((To_CondFil = hc->CheckCond(g, To_CondFil, Cond)))
      PlugSubAlloc(g, NULL, strlen(To_CondFil->Body) + 1);
     }
------------------------------------------------------------
bug injection: 
bool TDBODBC::ReadKey(PGLOBAL g, OPVAL op, const key_range *kr)
     To_CondFil->Body= (char*)PlugSubAlloc(g, NULL, 0);
     if ((To_CondFil = hc->CheckCond(g, NULL, To_CondFil->Body) + 1);
     }
------------------------------------------------------------
actual bug: 
 bool TDBODBC::ReadKey(PGLOBAL g, OPVAL op, const key_range *kr)
     To_CondFil->Body= (char*)PlugSubAlloc(g, NULL, 0);
     if ((To_CondFil = hc->CheckCond(g, To_CondFil, To_CondFil->Cond)))
      PlugSubAlloc(g, NULL, strlen(To_CondFil->Body) + 1);
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Error BRDSrc::draw(SkCanvas* canvas) const {
         case kDivisor_Mode: {
             const uint32_t divisor = 2;
             if (width < divisor || height < divisor) {
                 return Error::Nonfatal("Divisor is larger than image dimension.");
             }
------------------------------------------------------------
bug injection: 
Error BRDSrc::draw(SkCanvas* canvas) const {
         case kDivisor_Mode: {
             const uint32_t divisor = 2;
             if (height < divisor || height < divisor || height < divisor || height < divisor) {
                 return Error::Nonfatalfatalfatalfatalfatalfatalfatalfatalfatalfatalfatalfatalfatal:
             }
------------------------------------------------------------
actual bug: 
 Error BRDSrc::draw(SkCanvas* canvas) const {
         case kDivisor_Mode: {
             const uint32_t divisor = 2;
             if (width < divisor || height < divisor) {
                 return Error::Nonfatal("Divisor is larger than image dimension.\n");
             }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void filetypes_init_types()
  filetypes[GEANY_FILETYPES_HASKELL]->title = g_strdup_printf(_("%s source file"), "Haskell");
  filetypes[GEANY_FILETYPES_HASKELL]->extension = g_strdup("hs");
  filetypes[GEANY_FILETYPES_HASKELL]->pattern = utils_strv_new("*.hs", "*.lhs", NULL);
  filetypes[GEANY_FILETYPES_HASKELL]->comment_open = g_strdup("--");
  filetypes[GEANY_FILETYPES_HASKELL]->comment_close = NULL;
------------------------------------------------------------
bug injection: 
void filetypes_init_types()
  filetypes[GEANY_FILETYPES[GEANY_FILETYPES_HASKELL]->title = g_strdup_printf(_("%s source file"), "Haskell");
  filetypes[GEANY_FILETYPES_HASKELL]->pattern = g_strdup("hs");
  filetypes[GEANY_FILETYPES_HASKELL]->pattern = utils_strv_new("hs");
  filetypes[GEANY_FILETYPES_HASKELL]->comment_open = NULL;
  filetypes[GEANY_FILETYPES_HASKELL]->comment_open = NULL;
------------------------------------------------------------
actual bug: 
 void filetypes_init_types()
  filetypes[GEANY_FILETYPES_HASKELL]->title = g_strdup_printf(_("%s source file"), "Haskell");
  filetypes[GEANY_FILETYPES_HASKELL]->extension = g_strdup("hs");
  filetypes[GEANY_FILETYPES_HASKELL]->pattern = utils_strv_new("*.hs", "*.lhs", NULL);
  filetypes[GEANY_FILETYPES_HASKELL]->style_func_ptr = styleset_haskell;
  filetypes[GEANY_FILETYPES_HASKELL]->comment_open = g_strdup("--");
  filetypes[GEANY_FILETYPES_HASKELL]->comment_close = NULL;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void buildValueWitnessFunction(IRGenModule &IGM,
                                       ValueWitness index,
                                       FixedPacking packing,
                                       CanType abstractType,
                                       SILType concreteType,
                                       const TypeInfo &type) {
   assert(isValueWitnessFunction(index));
------------------------------------------------------------
bug injection: 
static void buildValueWitnessFunction(IRGenModule &IGM,
                                       AbstractType,
                                       FixedPacking module,
                                       FlatValueWitnessIndex,
                                       const TypeInfo &type,
                                       CanType) {
   assert(isValueWitnessFunction(index));
------------------------------------------------------------
actual bug: 
 static void buildValueWitnessFunction(IRGenModule &IGM,
                                       ValueWitness index,
                                       FixedPacking packing,
                                       CanType abstractType,
                                       CanType concreteType,
                                       const TypeInfo &type) {
   assert(isValueWitnessFunction(index));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
extension IndexPath : CustomStringConvertible, CustomDebugStringConvertible, Cus
     public var debugDescription: String {
         return _indexes.debugDescription
     }
     public var customMirror: Mirror {
         return Mirror(self, unlabeledChildren: self, displayStyle:.collection)
     }
 }
------------------------------------------------------------
bug injection: 
extension IndexPath : CustomDebugStringConvertible, CustomDebugStringConvertible, Cus
     public var debugDescription: String {
         return _indexes.debugDescription
     }
 }
------------------------------------------------------------
actual bug: 
 extension IndexPath : CustomStringConvertible, CustomDebugStringConvertible, Cus
     public var debugDescription: String {
         return _indexes.debugDescription
     }
     public var customMirror: Mirror {
         return _indexes.customMirror
     }
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
ibool
 rec_validate(
  const rec_t* rec,
  const offset_t* offsets)
  MY_ATTRIBUTE((nonnull));
------------------------------------------------------------
bug injection: 
ibool
 rec_validate(
  const rec_t* rec,
  const ulint* offsets)
  MY_ATTRIBUTE((nonnull));
------------------------------------------------------------
actual bug: 
 ibool
 rec_validate(
  const rec_t* rec,
  const ulint* offsets)
  MY_ATTRIBUTE((nonnull));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int AlertUnifiedLogOpenFileCtx(LogFileCtx *file_ctx, const char *prefix)
     if (file_ctx->filename!= NULL)
         filename = file_ctx->filename;
     else
         filename = file_ctx->filename = SCMalloc(PATH_MAX);
     struct timeval ts;
------------------------------------------------------------
bug injection: 
int AlertUnifiedLogOpenFileCtx(LogFileCtx *file_ctx, const char *prefix)
     if (file_ctx->filename!= NULL)
         filename = file_ctx->filename;
     else
         filename = file_ctx->filename = malloc(PATH_MAX);
------------------------------------------------------------
actual bug: 
 int AlertUnifiedLogOpenFileCtx(LogFileCtx *file_ctx, const char *prefix)
     if (file_ctx->filename!= NULL)
         filename = file_ctx->filename;
     else
         filename = file_ctx->filename = malloc(PATH_MAX);
     struct timeval ts;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
The <a href='undocumented#Line'>lines</a> are drawn into <a href='SkBitmap_Refer
 ---
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 bool <a href='#SkPaint_isAntiAlias'>isAntiAlias</a>()const
 </pre>
 Returns true if pixels on the active edges of <a href='SkPath_Reference#SkPath'>SkPath</a> may be drawn with partial transparency.
------------------------------------------------------------
bug injection: 
The <a href='undocumented#Line'>lines</a> drawn into <a href='undocumented#Line'>pts</a>
 ---
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 bool <a href='#SkPaint_isAntiAlias'>isAntiAlias</a>() const
 </pre>
 Returns true if the pixels are drawn with all transparency.
------------------------------------------------------------
actual bug: 
 The <a href='undocumented#Line'>lines</a> are drawn into <a href='SkBitmap_Refer
 ---
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 bool <a href='#SkPaint_isAntiAlias'>isAntiAlias</a>() const
 </pre>
 Returns true if pixels on the active edges of <a href='SkPath_Reference#SkPath'>SkPath</a> may be drawn with partial transparency.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST(DeviceNameUtilsTest, MergeDevNames) {
   MergeDevNamesHelper("", "/job:foo", "/job:foo");
   MergeDevNamesHelper("", "/replica:2", "/replica:2");
   MergeDevNamesHelper("", "/task:7", "/task:7");
   MergeDevNamesHelper("/job:foo", "/task:7", "/job:foo/task:7");
   MergeDevNamesHelper("/job:foo", "/device:GPU:1", "/job:foo/device:GPU:1");
   MergeDevNamesHelper("/job:foo/replica:0", "/replica:0/task:1",
------------------------------------------------------------
bug injection: 
TEST(DeviceNameUtilsTest, MergeDevNames) {
   MergeDevNamesHelper("", "/job:foo", "/job:2", "/job:foo", job:2");
   MergeDevNamesHelper("", "/job:1", "/job:1");
   MergeDevNamesHelper("/job:foo", "/job:1", "/job:foo");
   MergeDevNamesHelper("/job:foo", "/job:foo");
   MergeDevNamesHelper("/job:foo/job:foo", "/job:foo");
------------------------------------------------------------
actual bug: 
 TEST(DeviceNameUtilsTest, MergeDevNames) {
   MergeDevNamesHelper("", "/job:foo", "/job:foo");
   MergeDevNamesHelper("", "/replica:2", "/replica:2");
   MergeDevNamesHelper("", "/task:7", "/task:7");
   MergeDevNamesHelper("/job:foo", "/task:7", "/job:foo/task:7");
   MergeDevNamesHelper("/job:foo", "/gpu:1", "/job:foo/gpu:1");
   MergeDevNamesHelper("/job:foo/replica:0", "/replica:0/task:1",
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++