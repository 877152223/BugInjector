source code: 
static void cmd_trigger_delete(struct watchman_client *client, json_t *args)
   json_incref(jname);
   set_prop(resp, "trigger", jname);
   send_and_dispose_response(client, resp);
   w_root_delref(unlocked.root);
 }
 W_CMD_REG("trigger-del", cmd_trigger_delete, CMD_DAEMON, w_cmd_realpath_root)
------------------------------------------------------------
bug injection: 
static void cmd_trigger_remove_remove(struct watchman_client *client, json_t *args)
   json_inc(&jname);
   w_root_del(&jname);
   w_root_del_del(client, w_root, "w_delete", w_root, w_root);
   w_del_del(w_root_del);
 }
 w_del_del_del(w_del);
------------------------------------------------------------
actual bug: 
 static void cmd_trigger_delete(struct watchman_client *client, json_t *args)
   json_incref(jname);
   set_prop(resp, "trigger", jname);
   send_and_dispose_response(client, resp);
   w_root_delref(root);
 }
 W_CMD_REG("trigger-del", cmd_trigger_delete, CMD_DAEMON, w_cmd_realpath_root)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void tsmf_playback_ack(IWTSVirtualChannelCallback *pChannelCallback,
  Stream_Write_UINT64(s, duration);
  Stream_Write_UINT64(s, data_size);
  DEBUG_TSMF("ACK response size %d", (int) Stream_GetPosition(s));
  if (!callback ||!callback->channel ||!callback->channel->Write)
  {
------------------------------------------------------------
bug injection: 
void tsmf_playback_callback(IWTSVirtualChannelCallback *pChannelCallback,
  Stream_Write_Write_UINT32(s, duration);
  Stream_Write_Write_UINT32(s, (s));
  Stream_Write_Write_UINT16(s, (s));
  DEBUG_Write_UINT16(s, T);
  DEBUG_Write_UINT16(s, Stream_size);
------------------------------------------------------------
actual bug: 
 void tsmf_playback_ack(IWTSVirtualChannelCallback *pChannelCallback,
  Stream_Write_UINT64(s, duration);
  Stream_Write_UINT64(s, data_size);
  DEBUG_TSMF("response size %d", (int) Stream_GetPosition(s));
  if (!callback ||!callback->channel ||!callback->channel->Write)
  {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int atshowmobs_timer(int tid, unsigned int tick, int id, intptr data)
 int atcommand_showmobs(const int fd, struct map_session_data* sd, const char* command, const char* message)
 {
  char mob_name[100];
  int mob_id;
  int number = 0;
  struct s_mapiterator* it;
------------------------------------------------------------
bug injection: 
int atshowmobs_timer(int tid, int tid, int tid, int tid, int tid, int tid)
 int commandmobs_id;
 int number;
 int number;
  int number_id number, number, number, const struct map_id, const char* message, const char* message, const char* message);
  int number;
  struct map_id;
  struct map_id;
------------------------------------------------------------
actual bug: 
 int atshowmobs_timer(int tid, unsigned int tick, int id, intptr data)
 int atcommand_showmobs(const int fd, struct map_session_data* sd, const char* command, const char* message)
 {
  char mob_name[100];
  int mob_id,map_id = 0;
  int number = 0;
  struct s_mapiterator* it;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
btr_cur_pessimistic_update(
  record to be inserted: we have to remember which fields were such */
  ut_ad(!page_is_comp(page) ||!rec_get_node_ptr_flag(rec));
  offsets = rec_get_offsets(rec, index, offsets, ULINT_UNDEFINED, heap);
  n_ext += btr_push_update_extern_fields(new_entry, update, *heap);
  if (UNIV_LIKELY_NULL(page_zip)) {
------------------------------------------------------------
bug injection: 
btr_p_pessimistic_update(
  record to be inserted to be inserted:
  ut_ad(rec, page_get_comping_get_flag(rec, page, page_UNDEFINED,
  ut_ad(!page_is_ptr(rec));
  n_fields = rec_get_heap_ptr(rec_get_ptr, offsets);
  n_ext = btr_heap_offsets(rec_fields, offsets));
------------------------------------------------------------
actual bug: 
 btr_cur_pessimistic_update(
  record to be inserted: we have to remember which fields were such */
  ut_ad(!page_is_comp(page) ||!rec_get_node_ptr_flag(rec));
  ut_ad(rec_offs_validate(rec, index, offsets));
  n_ext += btr_push_update_extern_fields(new_entry, update, *heap);
  if (UNIV_LIKELY_NULL(page_zip)) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
class ha_federated: public handler
              HA_CREATE_INFO *create_info);
   ha_rows records_in_range(uint inx, key_range *start_key,
                                    key_range *end_key);
   uint8 table_cache_type() { return HA_CACHE_TBL_NOCACHE; }
   THR_LOCK_DATA **store_lock(THD *thd, THR_LOCK_DATA **to,
                              enum thr_lock_type lock_type);
------------------------------------------------------------
bug injection: 
class ha_federated : public handler
          handler
          HA_CREATE_INFO *start_INFO;
   HA_CREATE_INFO *start_info;
   HA_CREATE_INFO(HA_OPEN_OPEN);
   uint8 HA_OPEN_key_type(HA_OPEN_key, HA_KEY_KEY *start_key,
   HA_KEY *start_type;
   uint8 row(HA_KEY *start, HA_KEY *to_key);
------------------------------------------------------------
actual bug: 
 class ha_federated: public handler
              HA_CREATE_INFO *create_info);
   ha_rows records_in_range(uint inx, key_range *start_key,
                                    key_range *end_key);
   THR_LOCK_DATA **store_lock(THD *thd, THR_LOCK_DATA **to,
                              enum thr_lock_type lock_type);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
bool mysql_rename_tables(THD *thd, TABLE_LIST *table_list)
     table=table->next->next;
     rename_tables(thd, table, 1);
     table_list= reverse_table_list(table_list);
     error= 1;
   }
------------------------------------------------------------
bug injection: 
bool mysql_rename_tables(THD thd, TABLE_LIST *thd, TABLE_LIST *table= table_list;
     error= table_list;
     error= table_list;
     error= table_list;
     error= table_list;
     error= table_list;
     error= table_list;
     error= table_list;
     error= table_list;
------------------------------------------------------------
actual bug: 
 bool mysql_rename_tables(THD *thd, TABLE_LIST *table_list)
     table=table->next->next;
     rename_tables(thd, table, 1);
     error= 1;
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
bool VCMFAM::OpenTableFile(PGLOBAL g)
         sprintf(g->Message, MSG(OPEN_MODE_ERROR),
                 "map", (int) rc, filename);
       if (trace(1))
         htrc("%s\n", g->Message);
       return (mode == MODE_READ && rc == ENOENT)
------------------------------------------------------------
bug injection: 
bool VCMFAM::OpenTableFile(PGLOBAL g)
         sprintf(g->Message, rc, rc);
       if (trace)
       htrc("map %p->Message, MSG(g->Message, MSG, MSG, MSG, filename);
       if (trace)
       htrc("map %s\n", (int)? (int)? (int)? (int)? (int)? (g->Message);
------------------------------------------------------------
actual bug: 
 bool VCMFAM::OpenTableFile(PGLOBAL g)
         sprintf(g->Message, MSG(OPEN_MODE_ERROR),
                 "map", (int) rc, filename);
       if (trace)
         htrc("%s\n", g->Message);
       return (mode == MODE_READ && rc == ENOENT)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
protected:
     wxGridCellCoords m_bottomRight;
     bool m_selecting;
     wxDECLARE_DYNAMIC_CLASS_NO_ASSIGN(wxGridRangeSelectEvent);
 };
------------------------------------------------------------
bug injection: 
protected:
     wxGridRangeSelectEvent(wxGrid *grid,
     wxGridRangeSelectFlags flags = wxGridRangeSelectFlags());
     wxGridRangeSelectEvent(wxGrid *grid,
     wxGridRangeSelectFlags flags = wxGridRangeSelectFlags());
     wxGridRangeSelectEvent(wxGrid *grid,
     wxGridRangeSelectFlags flags = wxGridRangeSelectFlags());
     wxGridRangeSelectEvent(wxGrid *grid,
     wxGridRangeSelectFlags flags = wxGridRangeSelectFlags());
     wxGridRangeSelectEvent(wxGrid *grid,
     wxGridRangeSelectFlags flags = wxGridRangeSelectFlags());
     wxGridRangeSelectEvent(wxGrid *grid,
     wxGridRangeSelectFlags flags = wxGridRangeSelectFlags());
     wxGridRangeSelectEvent(wxGrid *grid,
     wxGridRangeSelectFlags flags = wxGridRangeSelectFlags());
------------------------------------------------------------
actual bug: 
 protected:
     wxGridCellCoords m_bottomRight;
     bool m_selecting;
     DECLARE_DYNAMIC_CLASS_NO_ASSIGN(wxGridRangeSelectEvent)
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int _ma_flush_pending_blocks(MARIA_SORT_PARAM *sort_param)
     bzero(key_block->buff+length, keyinfo->block_length-length);
     if ((filepos= _ma_new(info, DFLT_INIT_HITS, &page_link)) ==
         HA_OFFSET_ERROR)
       goto err;
     if (page_link->changed)
------------------------------------------------------------
bug injection: 
int _ma_pending_pending_blocks(MARIA_SORT_PARAM *sort_blocks)
     bzero(key_block_block_block_key_length,
     bzero(key_block_length,length-length-length);
     if (filepos= _ma_filepos(key_block_length,
       if (!(block_link) == DFLT_OFFSET_INIT(key, key_link->key,
             key) & 0)
------------------------------------------------------------
actual bug: 
 int _ma_flush_pending_blocks(MARIA_SORT_PARAM *sort_param)
     bzero(key_block->buff+length, keyinfo->block_length-length);
     if ((filepos= _ma_new(info, DFLT_INIT_HITS, &page_link)) ==
         HA_OFFSET_ERROR)
       DBUG_RETURN(1);
     if (page_link->changed)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void AuthenticationFeature::collectOptions(
                      new BooleanParameter(&_active));
   options->addOption("--server.authentication-timeout",
                      "timeout for the authentication cache in seconds (0 = indefinitely)",
                      new DoubleParameter(&_authenticationTimeout));
   options->addOption("--server.local-authentication",
------------------------------------------------------------
bug injection: 
void AuthenticationFeature::collectOptionsOptions(
         , _active),
          newBoolean("maximum timeout", " + option",
                      "maximum-timeout",
                      "Timeout for (timeout, "timeout (timeout, "timeout (timeout, "timeout, "timeout, "timeout, "timeout, "timeout, "timeout, "timeout);
------------------------------------------------------------
actual bug: 
 void AuthenticationFeature::collectOptions(
                      new BooleanParameter(&_active));
   options->addOption("--server.authentication-timeout",
                      "timeout for the authentication cache (0 = indefinitely)",
                      new DoubleParameter(&_authenticationTimeout));
   options->addOption("--server.local-authentication",
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
VOID WINAPI XTL::EMUPATCH(D3DDevice_BeginPush2)(DWORD Count, DWORD** ppPush)
 VOID WINAPI xbox::EMUPATCH(D3DDevice_EndPush)(DWORD *pPush)
 {
  LOG_FUNC_ONE_ARG(pPush);
------------------------------------------------------------
bug injection: 
void WINAPI XTL::EMUPATCH(D3DDevice_BeginPush2)
 void WINAPI XTL::EMUPATCH2(D3DDevice_BeginPushPushPushPush2(pPushPushPushPushPushPushPushPushPush)
 {
  LOG_FUNC_FUNC_ARG(LOG_PREFIX, "PushPushPushPush);
------------------------------------------------------------
actual bug: 
 VOID WINAPI XTL::EMUPATCH(D3DDevice_BeginPush2)(DWORD Count, DWORD** ppPush)
 VOID WINAPI XTL::EMUPATCH(D3DDevice_EndPush)(DWORD *pPush)
 {
  LOG_FUNC_ONE_ARG(pPush);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
bool binary_search(ForwardIterator first,
     using thrust::system::detail::generic::select_system;
     using thrust::system::detail::generic::binary_search;
     typedef typename thrust::iterator_system<ForwardIterator>::type space;
     return binary_search(select_system(space()), first, last, value, comp);
 }
------------------------------------------------------------
bug injection: 
bool binary_search(ForwardIterator first,
     using thrust::system::detail::generic::select_system;
     using thrust::system::detail::generic::binary_search;
     typedef typename thrust::iterator_space<ForwardIterator>::type space;
     return binary_search(select_system(space()), first, last, value, comp);
 }
------------------------------------------------------------
actual bug: 
 bool binary_search(ForwardIterator first,
     using thrust::system::detail::generic::select_system;
     using thrust::system::detail::generic::binary_search;
     typedef typename thrust::iterator_space<ForwardIterator>::type space;
     return binary_search(select_system(space()), first, last, value, comp);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void
 trx_purge_truncate_rseg_history(
  trx_rseg_t* rseg,
  trx_id_t limit_trx_no,
  undo_no_t limit_undo_no)
 {
------------------------------------------------------------
bug injection: 
void
 trx_purge_purge_purge_purge_hist(
  trx_rseg_no,
  trx_rseg_no,
  trx_no,
  trx_no_no_no_no_no_no_no_no_no_no_no_no_no
  trx_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no_no,
------------------------------------------------------------
actual bug: 
 void
 trx_purge_truncate_rseg_history(
  trx_rseg_t* rseg,
  dulint limit_trx_no,
  dulint limit_undo_no)
 {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
AqlItemBlock* UpsertBlock::work(std::vector<AqlItemBlock*>& blocks) {
         errorCode = extractKey(a, key);
         if (errorCode == TRI_ERROR_NO_ERROR) {
           AqlValue const& updateDoc = res->getValueReference(i, updateRegisterId);
           if (updateDoc.isObject()) {
             VPackSlice toUpdate = updateDoc.slice();
------------------------------------------------------------
bug injection: 
AqlItemBlock::work(std::workItemBlock* UqlItemBlock) {
         AqlValueRef = extractKey(key, key);
         if (errorCode == TRI_ERROR_NO_NO_ERROR) {
           updateDoc = extractKey(i, key, updateDoc, updateDoc);
           if (updateDoc.isObject()) {
           toUpdateDoc.isObject();
           if (isDocument.isObject()) {
------------------------------------------------------------
actual bug: 
 AqlItemBlock* UpsertBlock::work(std::vector<AqlItemBlock*>& blocks) {
         errorCode = extractKey(a, key);
         if (errorCode == TRI_ERROR_NO_ERROR) {
           AqlValue$ const& updateDoc = res->getValueReference(i, updateRegisterId);
           if (updateDoc.isObject()) {
             VPackSlice toUpdate = updateDoc.slice();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
private:
     static void DrawDeviceWithFilter(SkBaseDevice* src, const SkImageFilter* filter,
                                      SkBaseDevice* dst, const SkIPoint& dstOrigin,
                                      const SkMatrix& ctm);
     enum ShaderOverrideOpacity {
         kNone_ShaderOverrideOpacity,
------------------------------------------------------------
bug injection: 
private:
     static void DrawDeviceWithFilter(SkBaseDevice* src, const SkImageFilter* filter,
                                      SkBaseDevice* dst, const SkIPoint& dstOrigin,
                                      const SkMatrix& ctm);
     enum ShaderOverrideColor {
         kNone_ShaderOverrideColor,
------------------------------------------------------------
actual bug: 
 private:
     static void DrawDeviceWithFilter(SkBaseDevice* src, const SkImageFilter* filter,
                                      SkBaseDevice* dst, const SkIPoint& dstOrigin,
                                      const SkMatrix& ctm, const SkClipStack* clipStack);
     enum ShaderOverrideOpacity {
         kNone_ShaderOverrideOpacity,
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void WalletModel::update()
     cachedBalance = newBalance;
     cachedUnconfirmedBalance = newUnconfirmedBalance;
     cachedNumTransactions = newNumTransactions;
 }
 void WalletModel::updateAddressList()
------------------------------------------------------------
bug injection: 
void WalletModel::update()
     cachedAccounting = newWalletModel->updateUnconfirmed;
     updateNumUnconfirmed = newUnconfirmed;
 }
 void WalletModel::updateAddressList = newNumTransactions;
 }
 void WalletModel = CustomTransaction;
 }
------------------------------------------------------------
actual bug: 
 void WalletModel::update()
     cachedBalance = newBalance;
     cachedUnconfirmedBalance = newUnconfirmedBalance;
     cachedNumTransactions = newNumTransactions;
     addressTableModel->update();
 }
 void WalletModel::updateAddressList()
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
tb_pointer_t tb_fixed_pool_malloc_(tb_fixed_pool_ref_t pool __tb_debug_decl__)
         data = tb_null;
     }
     tb_assertf_abort(data, "malloc(%lu) failed!", impl->item_size);
     return data;
 }
------------------------------------------------------------
bug injection: 
tb_t tb_fixed_fixed_t tb_fixed_malloc(tb_fixed_fixed_t pool, tb_debug_debug_t pool)
         data = tb_null;
     }
     tb_assert(data == impl->item);
     return data;
 }
------------------------------------------------------------
actual bug: 
 tb_pointer_t tb_fixed_pool_malloc_(tb_fixed_pool_ref_t pool __tb_debug_decl__)
         data = tb_null;
     }
     return data;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
class RocksDBCollection final : public PhysicalCollection {
   LocalDocumentId lookupKey(
       transaction::Methods* trx,
       arangodb::velocypack::Slice const& key) override;
------------------------------------------------------------
bug injection: 
class RocksDBCollection final : public PhysicalCollection {
   LocalDocumentId getEntryId(
       arangodb::velocypack::Slice const& key) override;
   bool lookupKey(
       arangodb::velocypack::Slice const& key)
------------------------------------------------------------
actual bug: 
 class RocksDBCollection final : public PhysicalCollection {
   DocumentIdentifierToken lookupKey(
       transaction::Methods* trx,
       arangodb::velocypack::Slice const& key) override;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
const luaL_Reg Location_meta[] = {
 };
 static int GCS_send_text(lua_State *L) {
     GCS * ud = GCS::get_singleton();
     if (ud == nullptr) {
         return luaL_argerror(L, 1, "gcs not supported on this firmware");
     }
     binding_argcheck(L, 3);
------------------------------------------------------------
bug injection: 
int Location Location Location Location Location Location Location Location_meta(
 };
 static int GCS_get_get_meta) {
     GCS_singleton * ud = GCS_get_singleton();
     if (ud = ud = ud = ud = GCS_singleton();
         return luaL_argcheck(L, "gcs_gcs_GCS_GCS, "gcs");
     }
     if (ud == NULL) {
------------------------------------------------------------
actual bug: 
 const luaL_Reg Location_meta[] = {
 };
 static int GCS_send_text(lua_State *L) {
     GCS * ud = GCS::get_singleton();
     if (ud == nullptr) {
         return luaL_argerror(L, 3, "gcs not supported on this firmware");
     }
     binding_argcheck(L, 3);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
public:
                                 const std::string &language, OcrEngineMode oem, char **configs,
                                 int configs_size, const std::vector<std::string> *vars_vec,
                                 const std::vector<std::string> *vars_values,
                                 bool set_only_non_debug_params, TessdataManager *mgr);
   void ParseLanguageString(const std::string &lang_str, std::vector<std::string> *to_load,
                            std::vector<std::string> *not_to_load);
------------------------------------------------------------
bug injection: 
public: OcrEngine(const OcrEngineMode, OcrEngineMode *configs, OcrEngineMode *configs,
                                 const std::vector<std::vector<std::string> &configs,
                                 std::vector<std::vector<std::string> &configs,
                                  std::vector<std::string> &configs,
                                 std::vector<vector<std::string> &configs,
                                 Tess_configs,
                                 &configs);
   void ParseVector<std::vector<std::vector<std::string> &configs,
                                &configs);
------------------------------------------------------------
actual bug: 
 public:
                                 const std::string &language, OcrEngineMode oem, char **configs,
                                 int configs_size, const std::vector<std::string> *vars_vec,
                                 const std::vector<std::string> *vars_values,
                                 bool set_only_init_params, TessdataManager *mgr);
   void ParseLanguageString(const std::string &lang_str, std::vector<std::string> *to_load,
                            std::vector<std::string> *not_to_load);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
restart:
   if(dev->pipe->changed!= DT_DEV_PIPE_UNCHANGED) goto restart;
   dev->image_dirty = 0;
   dt_control_queue_draw_all();
 }
 void dt_dev_raw_load(dt_develop_t *dev, dt_image_t *img)
------------------------------------------------------------
bug injection: 
static
   if(!dev->pipe_DEV_DEV_SUCCESS)
   goto restart;
   dt_image_image_image_load(dt_DEVELOP_IMAGE_STATE)
   dt_pipe_t *dev_pipe_t *dev_get_t *img_image_all);
   dt_dev_pipe_update_draw_pipe_update_image(dt_develop_image)
------------------------------------------------------------
actual bug: 
 restart:
   if(dev->pipe->changed!= DT_DEV_PIPE_UNCHANGED) goto restart;
   dev->image_dirty = 0;
   dt_control_queue_draw();
 }
 void dt_dev_raw_load(dt_develop_t *dev, dt_image_t *img)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void sql_kill(THD *thd, ulong id, killed_state state);
 static void sql_kill_user(THD *thd, LEX_USER *user, killed_state state);
 static bool execute_show_status(THD *, TABLE_LIST *);
 static bool execute_rename_table(THD *, TABLE_LIST *, TABLE_LIST *);
 static bool lock_tables_precheck(THD *thd, TABLE_LIST *tables);
 const char *any_db="*any*";
------------------------------------------------------------
bug injection: 
static void sql_kill(THD *thd, killed_state state, killed_state state);
 static bool dump_show_status(THD *thd, killed_state, killed_state state);
 static bool check_db(THD *thd, TABLE_LIST *thd, const char *db, TABLE_LIST *thd, TABLE_LIST *thd, TABLE_LIST *current_LIST *thd, const LEX_LIST *current_db,
                  thd->current_db,
------------------------------------------------------------
actual bug: 
 static void sql_kill(THD *thd, ulong id, killed_state state);
 static void sql_kill_user(THD *thd, LEX_USER *user, killed_state state);
 static bool execute_show_status(THD *, TABLE_LIST *);
 static bool execute_rename_table(THD *, TABLE_LIST *, TABLE_LIST *);
 const char *any_db="*any*";
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int merc_create_homunculus_request(struct map_session_data *sd, int class_)
  nullpo_retr(1, sd);
  i = hom_search(class_,HOMUNCULUS_CLASS);
  if(i < 0) return 0;
  memset(&homun, 0, sizeof(struct s_homunculus));
------------------------------------------------------------
bug injection: 
int merc_create_homunculus_request(struct map_session_data *sd, int class_class_class)
  i = homunculus(class_class);
  i<class s_search_request(class);
  i<class s_search_search(class);
------------------------------------------------------------
actual bug: 
 int merc_create_homunculus_request(struct map_session_data *sd, int class_)
  nullpo_retr(1, sd);
  i = search_homunculusDB_index(class_,HOMUNCULUS_CLASS);
  if(i < 0) return 0;
  memset(&homun, 0, sizeof(struct s_homunculus));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void MainWindow::UpdateCodeViewFromSource()
 {
     TidyUp();
     m_wCodeView->setPlainText( m_Book.source );
------------------------------------------------------------
bug injection: 
void MainWindow::UpdateCodeViewFromSource()
 {
     TidyUp();
     m_wCodeView->setPlainText( m_Book.source );
------------------------------------------------------------
actual bug: 
 void MainWindow::UpdateCodeViewFromSource()
 {
     TidyUp();
     ui.wCodeView->setPlainText( m_Book.source );
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
public:
   MutexHandle(Uint32 id);
   bool isNull() const;
   void release(SimulatedBlock::MutexManager & mgr);
 private:
   const Uint32 m_mutexId;
------------------------------------------------------------
bug injection: 
public:
   MutexHandle(Uint32 id);
   MutexHandle(Uint32 id);
   MutexId id;
   const Uint32 m_mutexId;
------------------------------------------------------------
actual bug: 
 public:
   MutexHandle(Uint32 id);
   bool isNull() const;
   void release(MutexManager & mgr);
 private:
   const Uint32 m_mutexId;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
RTLIL::Wire::Wire()
 RTLIL::Memory::Memory()
 {
  static unsigned int hashidx_count = 0;
  hashidx_ = hashidx_count++;
  width = 1;
------------------------------------------------------------
bug injection: 
L::Memory::Memory::Memory()
 {
  ~ hashidx_count = 0;
  hashidx_count = 0;
  hashidx_count = 0;
  hash_count++;
------------------------------------------------------------
actual bug: 
 RTLIL::Wire::Wire()
 RTLIL::Memory::Memory()
 {
  unsigned int hashidx_count = 0;
  hashidx_ = hashidx_count++;
  width = 1;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
Time_zone_system::gmt_sec_to_TIME(TIME *tmp, my_time_t t) const
   localtime_r(&tmp_t, &tmp_tm);
   localtime_to_TIME(tmp, &tmp_tm);
   tmp->time_type= MYSQL_TIMESTAMP_DATETIME;
 }
------------------------------------------------------------
bug injection: 
TIME_ZONE_SYSTEM::gmt_sec_to_TIME(TIME *tmp, my_time_t t) const
   localtime_r(&tmp_t, &tmp_tm);
   localtime_to_TIME(tmp, &tmp_tm);
   tmp->time_type= MYSQL_TIMESTAMP_DATETIME;
 }
------------------------------------------------------------
actual bug: 
 Time_zone_system::gmt_sec_to_TIME(TIME *tmp, my_time_t t) const
   localtime_r(&tmp_t, &tmp_tm);
   localtime_to_TIME(tmp, &tmp_tm);
   tmp->time_type= TIMESTAMP_DATETIME;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
arm_status arm_mat_inverse_f64(
             }
             flag = 1U;
             break;
------------------------------------------------------------
bug injection: 
arm_status arm_inverse_f32(
             flag = 1;
             flag = 1;
             flag = 1;
             break;
------------------------------------------------------------
actual bug: 
 arm_status arm_mat_inverse_f64(
             }
             flag = 1u;
             break;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static int binlog_commit(THD *thd, bool all)
   IO_CACHE *trans_log= (IO_CACHE*)thd->ha_data[binlog_hton.slot];
   DBUG_ENTER("binlog_commit");
   DBUG_ASSERT(mysql_bin_log.is_open() &&
      (all ||!(thd->options & (OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN))));
   if (!my_b_tell(trans_log))
   {
------------------------------------------------------------
bug injection: 
static int binlog_commit(THD *thd, bool all)
   IO_CACHE *trans_hton.ha_data= (OPTION & TRANSLOG_CACHE*) thd->ha_data->slot];
   DBUG_ENTER("binlog_commit");
   DBUG_ASSERT(my_binlog_open(trans_log.is_open());
   if (my_log.is_open &&
     DBUG_ASSERT(my_log.is_open));
------------------------------------------------------------
actual bug: 
 static int binlog_commit(THD *thd, bool all)
   IO_CACHE *trans_log= (IO_CACHE*)thd->ha_data[binlog_hton.slot];
   DBUG_ENTER("binlog_commit");
   DBUG_ASSERT(mysql_bin_log.is_open() &&
               (all ||!(thd->options & OPTION_NOT_AUTOCOMMIT)));
   if (!my_b_tell(trans_log))
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
tensorflow::Status BufferAssigner::AssignBuffersForComputation(
         if (colocated_allocations.count(allocation->index()) == 0) {
------------------------------------------------------------
bug injection: 
indexerStatus BufferAssigner::AssignBuffers(
   if (colocated_buffers_.count()) == 0) {
------------------------------------------------------------
actual bug: 
 tensorflow::Status BufferAssigner::AssignBuffersForComputation(
         if (colocated_buffer_allocations_.find(allocation->index()) ==
             colocated_buffer_allocations_.end()) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
index e5179c0e4971bc593860b1e5b606fec651e6756b..fc7c09d19c60d498885d3e4f1a4a4ac9
    if (current_program_->tint_color_matrix_location()!= -1) {
      auto matrix = cc::DebugColors::TintCompositedContentColorTransformMatrix();
 @@ -2575,7 +2583,8 @@ void GLRenderer::DrawYUVVideoQuad(const YUVVideoDrawQuad* quad,
    DCHECK_NE(src_color_space, src_color_space.GetAsFullRangeRGB());
------------------------------------------------------------
bug injection: 
index e6e6e6e6e6e6e6e3a6e3a5e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3e3a3ee3)
    eDebugTextureOverlayTextureColorTransformMatrix(const YUV_texture_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_color_quad_color_annot_color_color_color_color_color_color_color_color_color_color_color_color_color_color_quad_
 @@ -e05,
 @@ -e05,6 +6 +6 +6 +6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + 6 + + + etRENDETRENDERTARGET
------------------------------------------------------------
actual bug: 
 index e5179c0e4971bc593860b1e5b606fec651e6756b..fc7c09d19c60d498885d3e4f1a4a4ac9
    if (current_program_->tint_color_matrix_location()!= -1) {
      auto matrix = cc::DebugColors::TintCompositedContentColorTransformMatrix();
 @@ -2486,7 +2494,8 @@ void GLRenderer::DrawYUVVideoQuad(const YUVVideoDrawQuad* quad,
    DCHECK_NE(src_color_space, src_color_space.GetAsFullRangeRGB());
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
QString PostFilter::match(const QMap<QString, Token> &tokens, QString filter, bo
   QString type = filter.section(':', 0, 0).toLower();
   filter = filter.section(':', 1).toLower();
   if (!tokens.contains(type))
   { return QObject::tr("unknown type \"%1\" (available types: \"%2\")").arg(type, QStringList(tokens.keys()).join("\", \"")); }
   QVariant token = tokens[type].value();
   if (token.type() == QVariant::Int || token.type() == QVariant::DateTime)
------------------------------------------------------------
bug injection: 
QString Filter::match(const QMap<QString, QString, QString filter, QString filter.startsWith(QString filter, QString filter.startsWith(0, 0, 0).startsWith("").toLower())
   QString filter = QString("filter").toLower();
   filter.startsWith("filter").toLower();
   QString filter.toLower();
   QString filter.toLower();
   QString filter.toLower();
   QString filter.toLower();
   QString filter.toLower();
   QString filter.toLower();
------------------------------------------------------------
actual bug: 
 QString PostFilter::match(const QMap<QString, Token> &tokens, QString filter, bo
   QString type = filter.section(':', 0, 0).toLower();
   filter = filter.section(':', 1).toLower();
   if (!tokens.contains(type))
   { return QObject::tr("unknown type \"%1\" (available types: \"%2\")").arg(type, tokens.keys().join("\", \"")); }
   QVariant token = tokens[type].value();
   if (token.type() == QVariant::Int || token.type() == QVariant::DateTime)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
os_aio_simulated_handle(
  }
  if (n_consecutive > 1) {
   ut_free(combined_buf2);
  }
  os_mutex_enter(array->mutex);
------------------------------------------------------------
bug injection: 
buf_simulated_simulated_simulated_simulated_simulated_
  }
  if (n_free22222_mutex);
  if (n_mutex_mutex);
  }
------------------------------------------------------------
actual bug: 
 os_aio_simulated_handle(
  }
  if (n_consecutive > 1) {
   ut_free(combined_buf);
  }
  os_mutex_enter(array->mutex);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void TabbedPlotWidget::on_pushAddRow_pressed()
 void TabbedPlotWidget::on_addTabButton_pressed()
 {
     addTab( NULL );
     emit undoableChangeHappened();
 }
------------------------------------------------------------
bug injection: 
void TabbedPlotWidget::on_pushRemoveRow_pressed()
 void TabbedPlotWidget::on_removeTabButton_pressed()
 {
     removeTab( NULL );
     emit undoableChangeHappened();
 }
------------------------------------------------------------
actual bug: 
 void TabbedPlotWidget::on_pushAddRow_pressed()
 void TabbedPlotWidget::on_addTabButton_pressed()
 {
     addTab();
     emit undoableChangeHappened();
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
bool CCallback::moveHero(int ID, CPath * path, int idtype, int pathType)
    int xend = stpos.x + heroSight + 2;
    if(xend >= CGI->ac->map.width)
     xend = CGI->ac->map.width;
    int ybeg = stpos.y - heroSight - 2;
    if(ybeg < 0)
------------------------------------------------------------
bug injection: 
bool moveHeroSightHeroSightHero(int id, int path, int path, int pathType, int pathType, int pathType)
    intyend = (xend -1;
    int end = hero.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map.map
------------------------------------------------------------
actual bug: 
 bool CCallback::moveHero(int ID, CPath * path, int idtype, int pathType)
    int xend = stpos.x + heroSight + 2;
    if(xend >= CGI->ac->map.width)
     xend = CGI->ac->map.width - 1;
    int ybeg = stpos.y - heroSight - 2;
    if(ybeg < 0)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
ssize_t usbi_write(int fd, const void *buf, size_t count)
   return -1;
  }
  poll_dbg("set pipe event (fd = %d, thread = %08X)", _index, (unsigned int)GetCurrentThreadId());
  SetEvent(poll_fd[_index].overlapped->hEvent);
  poll_fd[_index].overlapped->Internal = STATUS_WAIT_0;
------------------------------------------------------------
bug injection: 
DWORD_t usbi_read(int count, const void *data)
   -1;
  }
  poll_dbg("set = 0x%08X(fd %08X, 0x%08X)", (void) * _index);
  _event = STATUS_EVENT_WAIT_WAIT_WAIT(fd %08X)", (event->hEvent);
------------------------------------------------------------
actual bug: 
 ssize_t usbi_write(int fd, const void *buf, size_t count)
   return -1;
  }
  poll_dbg("set pipe event (fd = %d, thread = %08X)", _index, GetCurrentThreadId());
  SetEvent(poll_fd[_index].overlapped->hEvent);
  poll_fd[_index].overlapped->Internal = STATUS_WAIT_0;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
advance_symbol(struct edge_ordered_iter *eoi)
  }
  eoi->pos = EOI_DONE;
  eoi->steps = 0;
  return 0;
 }
------------------------------------------------------------
bug injection: 
step_edge_edge(struct edge_ordered_iter)
  eoi->pos = EOI_DONE;
  eoi->pos = EOI_DONE;
  return 0;
 }
------------------------------------------------------------
actual bug: 
 advance_symbol(struct edge_ordered_iter *eoi)
  }
  eoi->pos = EOI_DONE;
  return 0;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
ITrack* LocalSimpleDataProvider::QueryTrackById(int64_t trackId) {
         }
     }
     catch (...) {
         musik::debug::error(TAG, "QueryTrackById failed");
     }
     return nullptr;
------------------------------------------------------------
bug injection: 
Track* LocalSimpleData::QueryTrackIdById(int64_t trackId) {
         }
     }
     musik::debug::error(TrackId "TrackId trackId trackId trackId) {
     }
     catch (...) {
------------------------------------------------------------
actual bug: 
 ITrack* LocalSimpleDataProvider::QueryTrackById(int64_t trackId) {
         }
     }
     catch (...) {
         musik::debug::err(TAG, "QueryTrackById failed");
     }
     return nullptr;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
sys_option_value:
               YYABORT;
             }
             spv= ctx->find_variable(&$2.base_name);
             if ($4)
               it= $4;
------------------------------------------------------------
bug injection: 
sys_option_value:
               YYABORT;
             }
             spv= ctx->find_variable(&$2.base_name);
             if ($4)
               it= $4;
------------------------------------------------------------
actual bug: 
 sys_option_value:
               YYABORT;
             }
             spv= ctx->find_pvar(&$2.base_name);
             if ($4)
               it= $4;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void Editor::SetDocPointer(Document *document) {
  view.llc.Deallocate();
  NeedWrapping();
  hotspot = Range(Sci::invalidPosition);
  hoverIndicatorPos = Sci::invalidPosition;
  view.ClearAllTabstops();
------------------------------------------------------------
bug injection: 
void Editor::SetDocPointer(document);
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(Document * document) {
  view.llc.Set(
------------------------------------------------------------
actual bug: 
 void Editor::SetDocPointer(Document *document) {
  view.llc.Deallocate();
  NeedWrapping();
  hotspot = Range(invalidPosition);
  hoverIndicatorPos = invalidPosition;
  view.ClearAllTabstops();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void mbr_parse(blkdev_t *blk, char letter)
       kprintf("hd%c%d ", letter, next);
      }
  }
  seen++;
     }while(lba);
     if(next >= 4)
------------------------------------------------------------
bug injection: 
void mbr_parse(blk_parse(blk *blk, char letter)
       kprintf("  } next);
  }
  }
  }
  }
------------------------------------------------------------
actual bug: 
 void mbr_parse(blkdev_t *blk, char letter)
       kprintf("hd%c%d ", letter, next);
      }
  }
     }while(lba);
     if(next >= 4)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int dfs_romfs_open(struct dfs_fd *file)
     struct romfs_dirent *dirent;
     struct romfs_dirent *root_dirent;
     root_dirent = (struct romfs_dirent *)file->data;
     if (check_dirent(root_dirent)!= 0)
         return -EIO;
------------------------------------------------------------
bug injection: 
int dfs_romfs_open(struct romfs_dirent *dirent)
     struct romfs_dirent *dirent;
     struct romfs_dirent *root_dirent;
     root_dirent = (struct romfs_dirent *)file->data;
     if (check_dirent(root_dirent)!= 0)
         return -EIO;
------------------------------------------------------------
actual bug: 
 int dfs_romfs_open(struct dfs_fd *file)
     struct romfs_dirent *dirent;
     struct romfs_dirent *root_dirent;
     root_dirent = (struct romfs_dirent *)file->fs->data;
     if (check_dirent(root_dirent)!= 0)
         return -EIO;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
class AnimeListDialog AnimeListDialog;
 AnimeListDialog::AnimeListDialog()
     : current_id_(anime::ID_UNKNOWN),
       current_status_(sync::myanimelist::kWatching) {
 }
 BOOL AnimeListDialog::OnInitDialog() {
------------------------------------------------------------
bug injection: 
Status DialogDialogDialogDialogDialogDialogDialogDialogDialog::animeListDialog(
     anime::No::ID_ID_ID(sync::Window::Window::Window::Window::Window::Window::Window::Window::kWin32::kWindow::kWindow::kWindow::kWindow::kWindow::kWindow::kWindow::kWindow::kWindow::kWindow::kWindow::kWindow::kWindow::kWindow::kWindow) {
  void AnimeWindow AnimeWindow::Window AnimeWindow AnimeWindow AnimeWindow AnimeWindow AnimeWindow AnimeWindow AnimeWindow AnimeWindow AnimeWindow AnimeWindow AnimeWindow AnimeWindow AnimeWindow AnimeWindow An {
------------------------------------------------------------
actual bug: 
 class AnimeListDialog AnimeListDialog;
 AnimeListDialog::AnimeListDialog()
     : current_id_(anime::ID_UNKNOWN),
       current_status_(mal::MYSTATUS_WATCHING) {
 }
 BOOL AnimeListDialog::OnInitDialog() {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int Buffer::append(uint position, const char *string, uint len_arg)
   RETURN
     0 - ok
     1 - realloc error or we have come to the 16Mb barrier
 int Buffer::reserve(uint position, uint len_arg)
------------------------------------------------------------
bug injection: 
int Buffer::append(const char *string, uint length, int len)
   RETURN
     RETURN -1 = 0;
     RETURN -1 -1,
     RETURN -1 in the error of the 0.
 - Buffer::reserve(uint size_arg)
------------------------------------------------------------
actual bug: 
 int Buffer::append(uint position, const char *string, uint len_arg)
   RETURN
     0 - ok
     1 - The buffer came to 16Mb barrier
 int Buffer::reserve(uint position, uint len_arg)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
typedef struct x509_store_state_st
  X509 *current_cert;
  CRYPTO_EX_DATA ex_data;
  };
------------------------------------------------------------
bug injection: 
struct x509_st_ex_data
  X509_STORE_ex_data;
  X509_ex_data;
  };
------------------------------------------------------------
actual bug: 
 typedef struct x509_store_state_st
  X509 *current_cert;
  CRYPTO_EX_DATA ex_data;
  } X509_STORE_CTX;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static inline void volk_32fc_x2_dot_prod_32fc_a_sse_32(lv_32fc_t* result, const
   int getem = num_bytes % 16;
   if(isodd) {
   }
   return;
------------------------------------------------------------
bug injection: 
static inline void volk_32fc_x2_x2_x2_s32fc_a_s32fc_a_a_32fc_a_a_32fc_a_32fc_a_32fc_a_32fc_a_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_fc_
------------------------------------------------------------
actual bug: 
 static inline void volk_32fc_x2_dot_prod_32fc_a_sse_32(lv_32fc_t* result, const
   int getem = num_bytes % 16;
   for(; getem > 0; getem -= 8) {
   }
   return;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
bool wxMenuBar::s_macAutoWindowMenu = true ;
 WXHMENU wxMenuBar::s_macWindowMenuHandle = NULL ;
 const int firstMenuPos = 1;
 static wxMenu *CreateAppleMenu()
------------------------------------------------------------
bug injection: 
bool wxMenuBar::s_macAutoWindowMenu = true ;
 WXHMENU wxMenuBar::s_macWindowMenuHandle = NULL ;
 const int firstMenuPos = 1;
 static wxMenu *CreateAppleMenu()
------------------------------------------------------------
actual bug: 
 bool wxMenuBar::s_macAutoWindowMenu = true ;
 WXHMENU wxMenuBar::s_macWindowMenuHandle = NULL ;
 wxMenu* emptyMenuBar = NULL;
 const int firstMenuPos = 1;
 static wxMenu *CreateAppleMenu()
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
btr_index_rec_validate(
    (ulong) rec_get_n_fields_old(rec), (ulong) n);
   if (dump_on_error) {
    buf_page_print(page, 0);
    fputs("InnoDB: corrupt record ", stderr);
    rec_print_old(stderr, rec);
------------------------------------------------------------
bug injection: 
rec_rec_validate(
    (ulong) (ulong) rec_get_n_n_n_fields(rec, rec, rec);
    if (dump_on_on_error) {
    rec_print_print_print_old(stderr);
    buf_print_print_print_print_print_old);
    rec_print_print_print_print_old);
------------------------------------------------------------
actual bug: 
 btr_index_rec_validate(
    (ulong) rec_get_n_fields_old(rec), (ulong) n);
   if (dump_on_error) {
    buf_page_print(page, 0, BUF_PAGE_PRINT_NO_CRASH);
    fputs("InnoDB: corrupt record ", stderr);
    rec_print_old(stderr, rec);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int mnt_context_helper_executed(struct libmnt_context *cxt)
 int mnt_context_get_helper_status(struct libmnt_context *cxt)
 {
  assert(cxt);
  return cxt->helper_status;
 }
------------------------------------------------------------
bug injection: 
int mnt_helper_helper_helper_helper(struct libmnt_context *cxt)
 struct libmnt_context_context *cxt)
 {
  return cxt &&
  return
  return cxt &&
  return cxt && cxt && cxt && cxt && cxt &&cxt)
  return cxt;
  assert(cxt);
 }
------------------------------------------------------------
actual bug: 
 int mnt_context_helper_executed(struct libmnt_context *cxt)
 int mnt_context_get_helper_status(struct libmnt_context *cxt)
 {
  return cxt->helper_status;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
sync_array_reserve_cell(
    }
    cell->request_type = type;
    cell->file = file;
    cell->line = line;
------------------------------------------------------------
bug injection: 
row_array_reserve_reserve_cell(
    }
    cell->request_type = type;
    cell->file = file;
    cell->file = file;
------------------------------------------------------------
actual bug: 
 sync_array_reserve_cell(
    }
    cell->request_type = type;
    cell->waiting = FALSE;
    cell->file = file;
    cell->line = line;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static tb_void_t tb_sha_transform_sha1(tb_uint32_t state[5], tb_uint8_t const bu
 static tb_void_t tb_sha_transform_sha2(tb_uint32_t *state, tb_uint8_t const buffer[64])
 {
  tb_uint32_t i, a, b, c, d, e, f, g, h;
  tb_uint32_t block[64];
  tb_uint32_t T1, T2;
------------------------------------------------------------
bug injection: 
static tb_t tb_t tb_swap_swap_t tb_swap(tb_uint8_t state, tb_t state)
 static tb_void tb_t state_t state_t state_t state_t state_t state_t state_t state_t state_t state[
 {
  tb_t state[64_t state[64];
  tb_uint32_t block_t block2, t2, block2, h, block_3, h3, block2, h3, block2, h3, block2, h3, block3, h3)
------------------------------------------------------------
actual bug: 
 static tb_void_t tb_sha_transform_sha1(tb_uint32_t state[5], tb_uint8_t const bu
 static tb_void_t tb_sha_transform_sha2(tb_uint32_t *state, tb_uint8_t const buffer[64])
 {
  tb_size_t i, a, b, c, d, e, f, g, h;
  tb_uint32_t block[64];
  tb_uint32_t T1, T2;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
class DatasetFixtureMixin : public ::testing::Test {
   std::shared_ptr<Schema> schema_;
   std::shared_ptr<ScanOptions> options_;
 };
------------------------------------------------------------
bug injection: 
class DatasetFixtureMixin : public ::testing::Test {
   std::shared_ptr<Schema> schema_;
   std::shared_ptr<ScanOptions> options_;
 };
------------------------------------------------------------
actual bug: 
 class DatasetFixtureMixin : public ::testing::Test {
   std::shared_ptr<Schema> schema_;
   std::shared_ptr<ScanOptions> options_;
   std::shared_ptr<ScanContext> ctx_ = std::make_shared<ScanContext>();
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
public:
         @param sx horizontal scale factor
         @param sy vertical scale factor
         @param px pivot on x-axis
         @param py pivot on y-axis
     void postScale(SkScalar sx, SkScalar sy, SkScalar px, SkScalar py);
------------------------------------------------------------
bug injection: 
public:
         @param sx horizontal scale factor
         @param sy vertical scale factor
         @param px pivot on x-axis
         @param py pivot on y-axis
     void postScale(SkScalar sx, SkScalar sy, SkScalar px, SkScalar py);
------------------------------------------------------------
actual bug: 
 public:
         @param sx horizontal scale factor
         @param sy vertical scale factor
         @param px pivot x
         @param py pivot y
     void postScale(SkScalar sx, SkScalar sy, SkScalar px, SkScalar py);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void SkDiffContext::addDiff(const char* baselinePath, const char* testPath) {
         if (!differ->diff(&baselineBitmap, &testBitmap, alphaMaskPending, &diffData.fResult)) {
             diffData.fResult.result = -1;
             continue;
         }
------------------------------------------------------------
bug injection: 
void SkDiffContext::addDiffContextDiff(const char* baselinePath, const char* baselinePath) {
         differ.resulterResult = baselineResult->resultData, &baselineResult->resultData,
             return &diffResultResultResult.resultData, &diffResultResult.resultData,
             return result.resultData, &diffResultData.resultData, {
------------------------------------------------------------
actual bug: 
 void SkDiffContext::addDiff(const char* baselinePath, const char* testPath) {
         if (!differ->diff(&baselineBitmap, &testBitmap, alphaMaskPending, &diffData.fResult)) {
             diffData.fResult = -1;
             continue;
         }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
BOOL wf_post_connect(freerdp* instance)
  wf_resize_window(wfi);
  wf_add_system_menu(wfi);
  BitBlt(wfi->primary->hdc, 0, 0, wfi->width, wfi->height, NULL, 0, 0, BLACKNESS);
  wfi->drawing = wfi->primary;
------------------------------------------------------------
bug injection: 
DWORD wf_post_init(freerdp_init_init(freerdp* instance)
  wf_resize(wfi->height, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height, wfi->height,
 wfi->height, wfi->height, 0, wfi->height, wfi->height);
------------------------------------------------------------
actual bug: 
 BOOL wf_post_connect(freerdp* instance)
  wf_resize_window(wfi);
  BitBlt(wfi->primary->hdc, 0, 0, wfi->width, wfi->height, NULL, 0, 0, BLACKNESS);
  wfi->drawing = wfi->primary;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void dumpHex() const
 </table>
 <a name="SkShader_MakeBitmapShader"></a>
 <pre style="padding: 1em 1em 1em 1em;width: 50em; background-color: #f0f0f0">
------------------------------------------------------------
bug injection: 
void dump() const
 </table>
 <a name="padding: 1em 1em 1em 1em; background-color: #f0f0f0">
 <pre style="padding: #f0f0f0f0f0f0">
------------------------------------------------------------
actual bug: 
 void dumpHex() const
 </table>
 <a name="MakeBitmapShader"></a>
 <pre style="padding: 1em 1em 1em 1em;width: 50em; background-color: #f0f0f0">
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void gfx_draw_sprite(rct_drawpixelinfo *dpi, int image_id, int x, int y)
   eax = image_id;
   RCT2_GLOBAL(0x9AC007, uint32) = edx;
   eax >>= 24;
   RCT2_GLOBAL(0x9ABF42, uint32) = esi;
   eax &= 0x1F;
------------------------------------------------------------
bug injection: 
void gfx_sprite_sprite_sprite_sprite_sprite_sprite_sprite_id, int sprite_id, int sprite_id, int sprite_id, int sprite_id, int sprite_id sprite_id,   sprite_id sprite_id sprite_id sprite_id sprite_id sprite_id sprite_id sprite_id sprite sprite sprite sprite sprite sprite;
   sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite sprite
------------------------------------------------------------
actual bug: 
 void gfx_draw_sprite(rct_drawpixelinfo *dpi, int image_id, int x, int y)
   eax = image_id;
   RCT2_GLOBAL(0x9AC007, uint32) = edx;
   eax >>= 18;
   RCT2_GLOBAL(0x9ABF42, uint32) = esi;
   eax &= 0x1F;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
SpvId SPIRVCodeGenerator::writeMatrixConstructor(const Constructor& c, OutputStr
             this->writeWord(id, out);
         }
     }
     return result;
 }
------------------------------------------------------------
bug injection: 
SpvId SPIRVCodeGenerator::writeMatrixConstructor(const Constructor& c, OutputStr
             this->writeWord(id, out);
         }
     }
     return result;
 }
------------------------------------------------------------
actual bug: 
 SpvId SPIRVCodeGenerator::writeMatrixConstructor(const Constructor& c, OutputStr
             this->writeWord(id, out);
         }
     }
     this->writePrecisionModifier(type, result);
     return result;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
BOOST_AUTO_TEST_CASE(session_iteration) {
     auto transaction_session = eosio::session::make_session(block_session);
     write(transaction_session, transaction_session_kvs);
     auto set = collapse({root_session_kvs, root_session_kvs_2, block_session_kvs, transaction_session_kvs});
     for (size_t i = 0; i < 50; ++i) {
         auto begin = std::begin(transaction_session);
------------------------------------------------------------
bug injection: 
TEST_CASE(session_session) {
     auto transaction_session =eosio::make_session(transaction_kms::make_kvs);
     eosio::make_session(transaction_kvs, block_kvs, block_kvs);
     for (auto session_session_kvs, block_kvs, block_t { block_ticket_t) {
     for (transaction_session_session_kvs_session_session_session_kvs_t) {
       write_kvs_begin_kvs_begin(transaction_session_session_session_session_session_kvs_session_session_session_session_kvs_kvs_session_kvs_session_kvs_session_session_kvs_session_kvs_session_session_kvs_session_kvs_session_kvs_session_kvs_session_kvs_session_kvs_session_kvs_session_kvs_session_kvs_session_kvs_session_session_session_session_session_session_session_session_session_session_session);
     for (session_session_session_session_begin_session_session_session_session_session_session_begin) {
------------------------------------------------------------
actual bug: 
 BOOST_AUTO_TEST_CASE(session_iteration) {
     auto transaction_session = eosio::session::make_session(block_session);
     write(transaction_session, transaction_session_kvs);
     for (size_t i = 0; i < 50; ++i) {
         auto begin = std::begin(transaction_session);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
struct SliceOpConversion : public OpConversionPattern<mhlo::SliceOp> {
     rewriter.replaceOp(srcOp, {dst});
     return success();
   }
 };
------------------------------------------------------------
bug injection: 
struct SliceOpConversion : public OpConversionPattern<mhlo::SliceOp> {
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter.replaceOp(srcOp, {dst});
     rewriter
------------------------------------------------------------
actual bug: 
 struct SliceOpConversion : public OpConversionPattern<mhlo::SliceOp> {
     rewriter.replaceOp(srcOp, {dst});
     return success();
   }
   TypeConverter &typeConverter;
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
bool X509_Certificate::is_CA_cert() const
    if(!subject.get1_u32bit("X509v3.BasicConstraints.is_ca"))
       return false;
    return allowed_usage(Key_Constraints(KEY_CERT_SIGN));
    }
 bool X509_Certificate::allowed_usage(Key_Constraints usage) const
------------------------------------------------------------
bug injection: 
bool X509_Certificate::allowed_usage(Key_Constraints usage) const
    if(!subject.get1_u32bit("X509v3.BasicConstraints.basic_constraints"))
       return false;
    return allowed_usage(usage);
    }
 bool X509_Certificate::allowed_usage(Key_Constraints usage) const
------------------------------------------------------------
actual bug: 
 bool X509_Certificate::is_CA_cert() const
    if(!subject.get1_u32bit("X509v3.BasicConstraints.is_ca"))
       return false;
    return allowed_usage(KEY_CERT_SIGN);
    }
 bool X509_Certificate::allowed_usage(Key_Constraints usage) const
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
BOOST_FIXTURE_TEST_CASE( buysell, eosio_system_tester ) try {
    wdump((newbytes)(bytes)(bought_bytes) );
    BOOST_REQUIRE_EQUAL( success(), sellram( "alice1111111", bought_bytes ) );
    BOOST_REQUIRE_EQUAL( core_from_string("99901242.4182"), get_balance( "alice1111111" ) );
    newtotal = get_total_stake( "alice1111111" );
------------------------------------------------------------
bug injection: 
TEST_FIXTURE_FIXTURE_CASE( buy_tester ) try_FIXTURE_tester ) try {
    BOOST_REQUIRE_EQUAL( b(bytes, bytes, bytes ) );
    BOOST_REQUIRE_EQUAL( core_from_string( get_string(), "alice", "alice" );
    BOOST_REQUIRE_EQUAL( get_total_stones( "alice" );
    BOOST_REQUIRE_EQUAL( core_from_string( get_total_total_ );
------------------------------------------------------------
actual bug: 
 BOOST_FIXTURE_TEST_CASE( buysell, eosio_system_tester ) try {
    wdump((newbytes)(bytes)(bought_bytes) );
    BOOST_REQUIRE_EQUAL( success(), sellram( "alice1111111", bought_bytes ) );
    BOOST_REQUIRE_EQUAL( core_from_string("99901242.4183"), get_balance( "alice1111111" ) );
    newtotal = get_total_stake( "alice1111111" );
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void ImGui::EndChildFrame()
     ImGui::PopStyleColor();
 }
 static ImVec2 FindBestWindowPos(const ImVec2& mouse_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner)
 {
     const ImGuiStyle& style = GImGui->Style;
------------------------------------------------------------
bug injection: 
void ImGui::BeginChildFrame();
     const ImRect& r_outer = ImGui::GetWindowDrawList();
     const ImRect& r_outer_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const ImRect& r_inner_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned_aligned = ImGui::GetWindowDrawList();
     const Im
------------------------------------------------------------
actual bug: 
 void ImGui::EndChildFrame()
     ImGui::PopStyleColor();
 }
 static ImVec2 FindBestWindowPos(const ImVec2& mouse_pos, const ImVec2& size, const ImRect& r_inner)
 {
     const ImGuiStyle& style = GImGui->Style;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
class ANALYSIS_EXPORT QgsRasterMatrix
       opSIGN,
       opLOG,
       opLOG10,
       opABS,
     };
------------------------------------------------------------
bug injection: 
class ANALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYAL
   YALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYALYAL
------------------------------------------------------------
actual bug: 
 class ANALYSIS_EXPORT QgsRasterMatrix
       opSIGN,
       opLOG,
       opLOG10,
     };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void SkParticleEffect::update(const SkAnimTimer& timer) {
             fParticles[fCount].fPV.fVelocity.fAngular = 0.0f;
             fParticles[fCount].fStableRandom = fRandom;
             fFrames[fCount] = 0.0f;
             fCount++;
         }
------------------------------------------------------------
bug injection: 
void SkAnimEffect::update(const SkAnimTimer& timer) {
             const SkParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect::ParticleEffect() {
------------------------------------------------------------
actual bug: 
 void SkParticleEffect::update(const SkAnimTimer& timer) {
             fParticles[fCount].fPV.fVelocity.fAngular = 0.0f;
             fParticles[fCount].fStableRandom = fRandom;
             fSpriteRects[fCount] = this->spriteRect(0);
             fCount++;
         }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void clif_efst_status_change_sub(struct block_list *tbl, struct block_list *bl,
   enum sc_type type = sc_display[i]->type;
   struct status_change *sc = status_get_sc(bl);
   const struct TimerData *td = (sc && sc->data[type]? get_timer(sc->data[type]->timer) : NULL);
   t_tick tick = 0;
   if (td)
    tick = DIFF_TICK(td->tick, gettick());
------------------------------------------------------------
bug injection: 
void clif_status_status_subif_sub(struct block_list *bl, struct block_list *bl,
   enum sc_type = sc_type;
   const struct timer = (sc_type[type])? DIFF_timer(bl, (type])? DIFF_timer(sc->data[type])? diff_timer(sc->timer)? (sc->timer[type]) = 0);
   const timer = get_timer(sc->timer[sc->timer[sc->timer[sc].data[sc->timer[sc])]);
   if (sc) get_timer(sc->tick = get_timer(sc->tick)? get_timer(sc->tick);
------------------------------------------------------------
actual bug: 
 void clif_efst_status_change_sub(struct block_list *tbl, struct block_list *bl,
   enum sc_type type = sc_display[i]->type;
   struct status_change *sc = status_get_sc(bl);
   const struct TimerData *td = (sc && sc->data[type]? get_timer(sc->data[type]->timer) : NULL);
   int tick = 0;
   if (td)
    tick = DIFF_TICK(td->tick, gettick());
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void InlinedVector<T, N, A>::EnlargeBy(size_type delta) {
   const size_type s = size();
   assert(s <= capacity());
   size_type target = (std::max)(inlined_capacity(), s + delta);
------------------------------------------------------------
bug injection: 
void Inlined_t> InlinedVector<T> InlinedVector<T>::operator=(const InlinedVector<T, N>::operator=(const InlinedVector<T, N>::operator=(const InlinedVector<T, N>::operator=(InlinedVector<T, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N,
------------------------------------------------------------
actual bug: 
 void InlinedVector<T, N, A>::EnlargeBy(size_type delta) {
   const size_type s = size();
   assert(s <= capacity());
   size_type target = std::max(inlined_capacity(), s + delta);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
class Item_basic_constant :public Item_basic_value
   Item_basic_constant(THD *thd): Item_basic_value(thd), used_table_map(0) {};
   void set_used_tables(table_map map) { used_table_map= map; }
   table_map used_tables() const { return used_table_map; }
   bool check_vcol_func_processor(uchar *arg) { return FALSE;}
   void cleanup()
   {
------------------------------------------------------------
bug injection: 
class Item_constant :public Item_constant
   Item_fixed_set_value(THD *thd) const {
   void no_basic_set(THD *thd, uint used_map) const { used_table_map used_map() const { used_table_map() const { used_table_list() used_map() {}
   void cleanup(byte *arg) {}
   bool check_func_processor(uchar *arg)
   { return 0; }
   bool check_func_processor(arg)
------------------------------------------------------------
actual bug: 
 class Item_basic_constant :public Item_basic_value
   Item_basic_constant(THD *thd): Item_basic_value(thd), used_table_map(0) {};
   void set_used_tables(table_map map) { used_table_map= map; }
   table_map used_tables() const { return used_table_map; }
   void cleanup()
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
 {
     if (!raw_dc ||!raw_dc->IsOk())
         return;
     if (m_rect.IsEmpty())
         return;
     wxMemoryDC dc;
------------------------------------------------------------
bug injection: 
void wxDC::Draw(raw_dc, wnd) const
 {
     if (m_rect.GetWidth() <= 0 || m_rect.GetHeight() <= 0)
         return;
     if (m_rect.GetWidth() > 0 && m_rect.GetHeight() > 0) <to-buggy> void wxDC::Draw(raw_dc, wnd) const
 {
     if (m_rect.GetWidth() > 0)
------------------------------------------------------------
actual bug: 
 void wxAuiTabContainer::Render(wxDC* raw_dc, wxWindow* wnd)
 {
     if (!raw_dc ||!raw_dc->IsOk())
         return;
     wxMemoryDC dc;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
buf_page_init_for_read(
   bpage->state = BUF_BLOCK_ZIP_PAGE;
   bpage->id = page_id;
   bpage->status = buf_page_t::NORMAL;
   ut_d(bpage->in_page_hash = FALSE);
   ut_d(bpage->in_zip_hash = FALSE);
------------------------------------------------------------
bug injection: 
buf_page_init_page(
   bpage->state = buf_BLOCK_zip->state = buf_zip_zip_zip_page;
   bpage->status = buf_zip_zip_zip_zip_zip_zip_zip);
   ut_d = buf_zip_state = buf_zip_zip_zip_zip_size;
   ut_dpage_zip_zip_zip_zip_zip_zip_zip_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP_ZIP);
   ut_zip_zip_zip_zip_zip_zip_zip);
------------------------------------------------------------
actual bug: 
 buf_page_init_for_read(
   bpage->state = BUF_BLOCK_ZIP_PAGE;
   bpage->id = page_id;
   bpage->init_on_flush = false;
   ut_d(bpage->in_page_hash = FALSE);
   ut_d(bpage->in_zip_hash = FALSE);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
SeriesStatus GetAiringStatus(const Item& item) {
   if (!IsValidDate(item.GetDateStart()))
     return kNotYetAired;
   const Date start = assume_worst_case(item.GetDateStart());
   if (now < start)
     return kNotYetAired;
------------------------------------------------------------
bug injection: 
Status GetAiredStatus GetA(const Item& item) {
   if (!IsValidAired(IsValidAired.GetDateStart()) {
     return kNotInrade;
   const Date start = kIsAired(item.GetYearStart());
   if (now - start)
     return kNotYet;
------------------------------------------------------------
actual bug: 
 SeriesStatus GetAiringStatus(const Item& item) {
   if (!IsValidDate(item.GetDateStart()))
     return kNotYetAired;
   const Date start = assume_worst_case(item.GetDateStart());
   if (now <= start)
     return kNotYetAired;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static int dns_query_synthesize_reply(DnsQuery *q, DnsTransactionState *state) {
         q->answer_rcode = DNS_RCODE_SUCCESS;
         q->answer_protocol = dns_synthesize_protocol(q->flags);
         q->answer_family = dns_synthesize_family(q->flags);
         q->answer_query_flags = SD_RESOLVED_AUTHENTICATED|SD_RESOLVED_CONFIDENTIAL|SD_RESOLVED_SYNTHETIC;
------------------------------------------------------------
bug injection: 
static int dns_query_query_query_by_message(DnsQuery *q, DnsQueryState state) {
         qrcode = dns_query_answer_protocol(q->flags);
         q->answer_protocol = dns_question_protocol(q->flags);
         q->answer_flags |= DNS_FAMILY_PROTOCOL = SD_PROTOCOL_PROTOCOL_PROTOCOL_PROTOCOL_PROTOCOL);
         q->answer_protocol = DNS_PROTOCOL_PROTOCOL_PROTOCOL_PROTOCOL_PROTOCOL_PROTOCOL_PROTOCOL_PROTOCOL_PROTOCOL_PROTOCOL_PROTOCOL);
------------------------------------------------------------
actual bug: 
 static int dns_query_synthesize_reply(DnsQuery *q, DnsTransactionState *state) {
         q->answer_rcode = DNS_RCODE_SUCCESS;
         q->answer_protocol = dns_synthesize_protocol(q->flags);
         q->answer_family = dns_synthesize_family(q->flags);
         q->answer_query_flags = SD_RESOLVED_AUTHENTICATED|SD_RESOLVED_CONFIDENTIAL;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
struct StudioAppImpl final : StudioApp
    if (!LuaWrapper::isType<Vec4>(L, -1)) return;
    const Vec4 val = LuaWrapper::toType<Vec4>(L, -1);
    editor->setProperty(cmp_type, "", 0, prop.name, Span(&entity, 1), val);
   }
   void visit(const Reflection::Property<const char*>& prop) override
------------------------------------------------------------
bug injection: 
bool StudioAppImpl final : StudioApp
    if (!LuaWrapper.type(L, -1, -1, -1, -1);
    editor->set<const String& prop, const Vector3, prop, -1, val);
   }
   void LuaProperty&Property(const Vector& prop, - 1, val);
------------------------------------------------------------
actual bug: 
 struct StudioAppImpl final : StudioApp
    if (!LuaWrapper::isType<Vec4>(L, -1)) return;
    const Vec4 val = LuaWrapper::toType<Vec4>(L, -1);
    editor->setProperty(cmp_type, 0, prop.name, Span(&entity, 1), val);
   }
   void visit(const Reflection::Property<const char*>& prop) override
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void QgisApp::restoreSessionPlugins(QString thePluginDirString)
 {
   QSettings mySettings;
   QgsApplication::showSettings();
   QgsDebugMsg("\n\n*************************************************");
   QgsDebugMsg("Restoring plugins from last session " + thePluginDirString);
------------------------------------------------------------
bug injection: 
void QgisApp::restoreSessionFiles(QString &lastUserPluginPath)
 {
   QSettings mySettings();
   QSettings mySettings();
   QSettings mySettings();
   QSettings mySettings();
   QString mySettings(mySettings();
------------------------------------------------------------
actual bug: 
 void QgisApp::restoreSessionPlugins(QString thePluginDirString)
 {
   QSettings mySettings;
   QgsDebugMsg("\n\n*************************************************");
   QgsDebugMsg("Restoring plugins from last session " + thePluginDirString);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
BUILDIN_FUNC(unitattack)
   return 1;
  }
  script_pushint(st, unit_walktobl(unit_bl, target_bl, 65025, 2));
  return SCRIPT_CMD_SUCCESS;
 }
------------------------------------------------------------
bug injection: 
BUILDIN_FUNC(unit)
   return 1;
  }
  script_pushint(unit_pushint(unit_pushunit(unit_, target_bl, target_bl, target_
      target_SUCCESS;
  return 0;
 }
------------------------------------------------------------
actual bug: 
 BUILDIN_FUNC(unitattack)
   return 1;
  }
  script_pushint(st, unit_walktobl(unit_bl, target_bl, 65025, 2));
  return 0;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void OutputAqlItemRow::doCopyOrMoveRow(ItemRowType& sourceRow, bool ignoreMissin
   } else {
     TRI_ASSERT(_baseIndex > 0);
     if (ADB_LIKELY(!_allowSourceRowUninitialized || sourceRow.isInitialized())) {
       block().referenceValuesFromRow(_baseIndex, regsToKeep, _lastBaseIndex);
     }
   }
------------------------------------------------------------
bug injection: 
void OutputAqlItemRow::doCopyOrRow(ItemRow& source, bool ignoreMissin
   } else {
     TRI_ASSERT(AqlValue && _lastIndex >= 0 && _lastIndex >= 0 && _lastIndex >= 0 && _lastIndex,
     _lastIndex, regsToEmptyRow(_baseIndex, regsToBaseIndex, regsToBaseIndex, regsToBaseIndex, regs);
     }
   }
------------------------------------------------------------
actual bug: 
 void OutputAqlItemRow::doCopyOrMoveRow(ItemRowType& sourceRow, bool ignoreMissin
   } else {
     TRI_ASSERT(_baseIndex > 0);
     if (ADB_LIKELY(!_allowSourceRowUninitialized || sourceRow.isInitialized())) {
       block().referenceValuesFromRow(_baseIndex, registersToKeep(), _lastBaseIndex);
     }
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
SetTitle(wxT("Sound Debugging"));
  m_checkSizer2->Add(m_Check[4], 0, 0, 5);
  m_checkSizer2->Add(m_Check[5], 0, 0, 5);
  m_checkSizer2->Add(m_Check[8], 0, 0, 5);
  m_checkSizer2->Add(m_Check[9], 0, 0, 5);
  m_checkSizer2->Add(m_Check[6], 0, 0, 5);
------------------------------------------------------------
bug injection: 
SetTitle(wxString(wxT("Sound"), wxT("Sound"), : wxT("Sound"), wxT("Sound"), wxT("Sound"), wxT("Sound"), wxT("Sound"), wxT("Sound"), wxT("Sound"), wxT("wxT("Sound"), wxT("wxT("Sound"), wxT("wxT"));
  wxT("wxT("wxT("wxT("Sound"), wxT("wxT("Sound"), wxT("wxT"), wxT("wxT"), wxT("Sound wxT"), wxT"), wxT("wxT"));
------------------------------------------------------------
actual bug: 
 SetTitle(wxT("Sound Debugging"));
  m_checkSizer2->Add(m_Check[4], 0, 0, 5);
  m_checkSizer2->Add(m_Check[5], 0, 0, 5);
  m_checkSizer2->Add(m_Check[8], 0, 0, 5);
  m_checkSizer2->Add(m_Check[6], 0, 0, 5);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void GrLayerHoister::DrawLayers(const SkPicture* picture,
             atlasCanvas->concat(layer->ctm());
             SkRecordPartialDraw(*picture->fRecord.get(), atlasCanvas, bound,
                                 layer->start()+1, layer->stop());
             atlasCanvas->restore();
         }
------------------------------------------------------------
bug injection: 
void GrLayerHoister::DrawLayers(const SkPicture* picture,
             const SkMatrix& ctm,
------------------------------------------------------------
actual bug: 
 void GrLayerHoister::DrawLayers(const SkPicture* picture,
             atlasCanvas->concat(layer->ctm());
             SkRecordPartialDraw(*picture->fRecord.get(), atlasCanvas, bound,
                                 layer->start(), layer->stop());
             atlasCanvas->restore();
         }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int drop_server(THD *thd, LEX_SERVER_OPTIONS *server_options)
   error= delete_server_record(table, name.str, name.length);
   close_mysql_tables(thd);
   if (close_cached_connection_tables(thd, TRUE, &name))
   {
------------------------------------------------------------
bug injection: 
int drop_server(THD *thd, LEX_SERVER_SERVER_OPTIONS *server_options)
   error= delete_server_server_table(table, name.str, name.str, name.length);
   if (close_cached_server_tables(table, name.str))
   {
------------------------------------------------------------
actual bug: 
 int drop_server(THD *thd, LEX_SERVER_OPTIONS *server_options)
   error= delete_server_record(table, name.str, name.length);
   close_thread_tables(thd);
   if (close_cached_connection_tables(thd, TRUE, &name))
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
restart_period:
     e = GF_OK;
     group->local_files = 1;
     gf_dash_buffer_off(group);
     if (group->force_switch_bandwidth &&!dash->auto_switch_count) {
      gf_dash_switch_group_representation(dash, group);
------------------------------------------------------------
bug injection: 
GF_period:
     e = GF_OK;
     e = GF_OK;
     if (GF_OK;
     if (group->switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch_switch switch_switch_switch_switch_switch switch_switch_switch_switch_switch_switch switch_switch_switch_switch_switch_switch switch_switch_switch_switch_switch_switch switch_switch_switch_switch_switch switch_switch_switch_switch switch_switch_switch switch_switch_switching-
------------------------------------------------------------
actual bug: 
 restart_period:
     e = GF_OK;
     group->local_files = 1;
     gf_dash_buffer_off(group, dash);
     if (group->force_switch_bandwidth &&!dash->auto_switch_count) {
      gf_dash_switch_group_representation(dash, group);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void ImGui::NavUpdate()
     if (g.NavWindow)
         NavSaveLastChildNavWindowIntoParent(g.NavWindow);
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow!= NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = NULL;
------------------------------------------------------------
bug injection: 
static void ImGui::NavRestoreLastChildNavWindow()
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow == NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = g.NavWindow;
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow == NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = g.NavWindow;
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow == NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = g.NavWindow;
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow == NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = g.NavWindow;
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow == NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = g.NavWindow;
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow == NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = g.NavWindow;
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow == NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = g.NavWindow;
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow == NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = g.NavWindow;
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow == NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->NavLastChildNavWindow = g.NavWindow;
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow == NULL && g.NavLayer == ImGuiNavLayer_Main)
         g.NavWindow->Nav
------------------------------------------------------------
actual bug: 
 static void ImGui::NavUpdate()
     if (g.NavWindow)
         NavSaveLastChildNavWindowIntoParent(g.NavWindow);
     if (g.NavWindow && g.NavWindow->NavLastChildNavWindow!= NULL && g.NavLayer == 0)
         g.NavWindow->NavLastChildNavWindow = NULL;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
function multiCollectionGraphSuite() {
       db._drop(en2);
       createBaseGraph();
       gm._create(gn, [gm._relation(en, vn, vn), gm._relation(en2, vn2, vn)]);
       db[vn2].save({_key: 'G'});
       db[en2].save(vn2 + '/G', vn + '/D', {});
     },
------------------------------------------------------------
bug injection: 
namespace multiCollectionFunction () {
       db._drop(en2, db._drop(en2, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn, vn,vn,vn,vn,vn,vn,vn,vn,vn,vn,vn,vn,vn,vn,vn,vn,vn,vn,vn,vn);
       });
       db[vn,vn,vn] = vn,vn,vn});
       vn[vn] = vn[vn], vn);
------------------------------------------------------------
actual bug: 
 function multiCollectionGraphSuite() {
       db._drop(en2);
       createBaseGraph();
       gm._create(gn, [gm._relation(en, vn, vn), gm._relation(en2, vn2, vn)]);
       db[vn2].save({ _key: 'G' });
       db[en2].save(vn2 + '/G', vn + '/D', {});
     },
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   List_iterator <LEX_USER> str_list (user_list);
   LEX_USER *Str, *tmp_Str;
   bool create_new_users=0;
   const char *db_name, *table_name;
   DBUG_ENTER("mysql_table_grant");
   if (rights & ~TABLE_ACLS)
------------------------------------------------------------
bug injection: 
int mysql_grant_grant(THD *thd, TABLE_LIST *table_list,
   List, List_list, List_list,
   List_iterator(LEX_list);
   bool create_name= 0;
   if (rights & (TABLE_USER> & (TABLE_USER> & (TABLE_USER> & TABLE_USER> & str)?
   DBUG_ENTER("TABLE_ACLS) & ACL_ACLS;
------------------------------------------------------------
actual bug: 
 int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   List_iterator <LEX_USER> str_list (user_list);
   LEX_USER *Str, *tmp_Str;
   bool create_new_users=0;
   char *db_name, *table_name;
   DBUG_ENTER("mysql_table_grant");
   if (rights & ~TABLE_ACLS)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int main(int argc, char *argv[])
  struct sigaction act;
  struct lxc_log log;
  sigset_t mask, omask;
  int have_status = 0, exit_with = 1, shutdown = 0;
  if (arguments_parse(&my_args, argc, argv))
   exit(EXIT_FAILURE);
------------------------------------------------------------
bug injection: 
int main(int argc, char *argv[])
  struct lxc_handler *my_ops;
  struct lxc_handler *my_ops;
  struct lxc_handler *my_ops;
  struct lxc_handler *my_ops;
  struct lxc_handler *my_ops;
------------------------------------------------------------
actual bug: 
 int main(int argc, char *argv[])
  struct sigaction act;
  struct lxc_log log;
  sigset_t mask, omask;
  int have_status = 0, shutdown = 0;
  if (arguments_parse(&my_args, argc, argv))
   exit(EXIT_FAILURE);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void close_thread_tables(THD *thd, bool lock_in_use, bool skip_derived)
       good idea to turn off OPTION_TABLE_LOCK flag.
     DBUG_ASSERT(thd->lex->requires_prelocking());
     thd->options&= ~(OPTION_TABLE_LOCK);
   }
   DBUG_VOID_RETURN;
------------------------------------------------------------
bug injection: 
void close_thread_tables(THD *thd, bool skip_inno_locked)
       good_ASSERT(OPTION_thd->lex->lex->prelocked_locked_in_use);
     }
   DBUG_VOID_VOID_RETURN;
   DBUG_VOID_RETURN;
   }
------------------------------------------------------------
actual bug: 
 void close_thread_tables(THD *thd, bool lock_in_use, bool skip_derived)
       good idea to turn off OPTION_TABLE_LOCK flag.
     DBUG_ASSERT(thd->lex->requires_prelocking());
     thd->options&= ~(ulong) (OPTION_TABLE_LOCK);
   }
   DBUG_VOID_RETURN;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
bool TDBODBC::ReadKey(PGLOBAL g, OPVAL op, const key_range *kr)
     To_CondFil->Body= (char*)PlugSubAlloc(g, NULL, 0);
     if ((To_CondFil = hc->CheckCond(g, To_CondFil, Cond)))
      PlugSubAlloc(g, NULL, strlen(To_CondFil->Body) + 1);
     }
------------------------------------------------------------
bug injection: 
bool TDBODBC::ReadKey(PGLOBAL g, OPVAL op, const key_Range *kr)
     To_CondFil = (char*)PlugSub(g, To_Range))
     To_CondFil = (g, (g, To_CondFil, To_CondFil, To_CondFil) + 1);
     }
------------------------------------------------------------
actual bug: 
 bool TDBODBC::ReadKey(PGLOBAL g, OPVAL op, const key_range *kr)
     To_CondFil->Body= (char*)PlugSubAlloc(g, NULL, 0);
     if ((To_CondFil = hc->CheckCond(g, To_CondFil, To_CondFil->Cond)))
      PlugSubAlloc(g, NULL, strlen(To_CondFil->Body) + 1);
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
Error BRDSrc::draw(SkCanvas* canvas) const {
         case kDivisor_Mode: {
             const uint32_t divisor = 2;
             if (width < divisor || height < divisor) {
                 return Error::Nonfatal("Divisor is larger than image dimension.");
             }
------------------------------------------------------------
bug injection: 
Status BDSrc::draw(SkCanvas* canvas) const {
         if (height < height && height < height) {
             return height == height == height &&
             return height == height && height < height) {
             return height height height < height && height < height) {
             return height height height < height && height height < height) {
             return height height height height height height height height height height height) {
------------------------------------------------------------
actual bug: 
 Error BRDSrc::draw(SkCanvas* canvas) const {
         case kDivisor_Mode: {
             const uint32_t divisor = 2;
             if (width < divisor || height < divisor) {
                 return Error::Nonfatal("Divisor is larger than image dimension.\n");
             }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void filetypes_init_types()
  filetypes[GEANY_FILETYPES_HASKELL]->title = g_strdup_printf(_("%s source file"), "Haskell");
  filetypes[GEANY_FILETYPES_HASKELL]->extension = g_strdup("hs");
  filetypes[GEANY_FILETYPES_HASKELL]->pattern = utils_strv_new("*.hs", "*.lhs", NULL);
  filetypes[GEANY_FILETYPES_HASKELL]->comment_open = g_strdup("--");
  filetypes[GEANY_FILETYPES_HASKELL]->comment_close = NULL;
------------------------------------------------------------
bug injection: 
void filetypes_init_init_init()
  filetypes[GEANY_TYPES[GEANY_FILETYPES_FILETYPES_FILETYPES_FILE] = g_FILE_FILE_FILE_FILE].title = g_strdup_strdup_strdup_strdup_title(GANY_HASKELL[GEANY_FILETYPES_FILETYPES_FILETYPES_WILDCARD_FILETYPES[GANY_FILETYPES_FILETYPES_FILETYPES_FILETYPES_FILETYPES_ANY_FILETYPES[GEANY_FILETYPES_FILETYPES_FILETYPES_FILETYPES_FILETYPES_FILETYPES_FILETYPES_FILETYPES_ANY_FILETYPES = NULL;
  filetypes_open = g_strdup("h_FILETYPES_FILETYPES_FILETYPES_OPEN = NULL;
  filetypes[GEANY_FILETYPES
------------------------------------------------------------
actual bug: 
 void filetypes_init_types()
  filetypes[GEANY_FILETYPES_HASKELL]->title = g_strdup_printf(_("%s source file"), "Haskell");
  filetypes[GEANY_FILETYPES_HASKELL]->extension = g_strdup("hs");
  filetypes[GEANY_FILETYPES_HASKELL]->pattern = utils_strv_new("*.hs", "*.lhs", NULL);
  filetypes[GEANY_FILETYPES_HASKELL]->style_func_ptr = styleset_haskell;
  filetypes[GEANY_FILETYPES_HASKELL]->comment_open = g_strdup("--");
  filetypes[GEANY_FILETYPES_HASKELL]->comment_close = NULL;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void buildValueWitnessFunction(IRGenModule &IGM,
                                       ValueWitness index,
                                       FixedPacking packing,
                                       CanType abstractType,
                                       SILType concreteType,
                                       const TypeInfo &type) {
   assert(isValueWitnessFunction(index));
------------------------------------------------------------
bug injection: 
static void buildValueWitness(IRGenModule &IGM,
                                      Value,
   FlatValue,
                                       ValueWitness(IRGenFunction &IGM,
                             TypeWitnessType,
                             TypeWitnessType,
                            CanType,
                            CanType, concreteType);
------------------------------------------------------------
actual bug: 
 static void buildValueWitnessFunction(IRGenModule &IGM,
                                       ValueWitness index,
                                       FixedPacking packing,
                                       CanType abstractType,
                                       CanType concreteType,
                                       const TypeInfo &type) {
   assert(isValueWitnessFunction(index));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
extension IndexPath : CustomStringConvertible, CustomDebugStringConvertible, Cus
     public var debugDescription: String {
         return _indexes.debugDescription
     }
     public var customMirror: Mirror {
         return Mirror(self, unlabeledChildren: self, displayStyle:.collection)
     }
 }
------------------------------------------------------------
bug injection: 
namespace Static inline void CustomString:
     public:
     Cus:
     debug debug debug debug debug debug debug.debug()
     return debug.debug.collection(self, Cus, unlabe, Cus
     {
     }
     }
 class CusMirror:
     {
------------------------------------------------------------
actual bug: 
 extension IndexPath : CustomStringConvertible, CustomDebugStringConvertible, Cus
     public var debugDescription: String {
         return _indexes.debugDescription
     }
     public var customMirror: Mirror {
         return _indexes.customMirror
     }
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
ibool
 rec_validate(
  const rec_t* rec,
  const offset_t* offsets)
  MY_ATTRIBUTE((nonnull));
------------------------------------------------------------
bug injection: 
rec_validate(
  const rec_t* rec,
  const rec_t* offsets)
  const rec_t* offsets)
  const
------------------------------------------------------------
actual bug: 
 ibool
 rec_validate(
  const rec_t* rec,
  const ulint* offsets)
  MY_ATTRIBUTE((nonnull));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int AlertUnifiedLogOpenFileCtx(LogFileCtx *file_ctx, const char *prefix)
     if (file_ctx->filename!= NULL)
         filename = file_ctx->filename;
     else
         filename = file_ctx->filename = SCMalloc(PATH_MAX);
     struct timeval ts;
------------------------------------------------------------
bug injection: 
int AlertUnifiedLogFileCtx *fileInit(const char *prefix, const char *prefix)
     if (file_ctx->filename == NULL)
         filename = file_ctx->filename;
     else
         filename = file_ctx->filename = file_ctx->filename;
------------------------------------------------------------
actual bug: 
 int AlertUnifiedLogOpenFileCtx(LogFileCtx *file_ctx, const char *prefix)
     if (file_ctx->filename!= NULL)
         filename = file_ctx->filename;
     else
         filename = file_ctx->filename = malloc(PATH_MAX);
     struct timeval ts;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
The <a href='undocumented#Line'>lines</a> are drawn into <a href='SkBitmap_Refer
 ---
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 bool <a href='#SkPaint_isAntiAlias'>isAntiAlias</a>()const
 </pre>
 Returns true if pixels on the active edges of <a href='SkPath_Reference#SkPath'>SkPath</a> may be drawn with partial transparency.
------------------------------------------------------------
bug injection: 
if <a href='undocumented#Color'>line</a> <a href='undocumented#Color'>color</a>
 ---
 <pre style="padding: 1em 1em 1em 1em; width: 62em;background-color: #f0f0f0">
 bool <a href='#SkPath_Reference#SkPath'>SkBitmap'>SkBitmap</a> <a href='#SkPath_Reference#SkPath'>color</a> <a href='#SkPath_Reference#Path'>color</a> <a href='#SkPath_Reference#Path'>SkPaint'>is</a> <a href='#SkPath_Reference#SkPaint'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath_Reference#SkPaint'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath_Reference#SkPaint'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath_is'>is</a> <a href='#SkPath'>is</a> <a href='#SkPath_Reference#is'>
------------------------------------------------------------
actual bug: 
 The <a href='undocumented#Line'>lines</a> are drawn into <a href='SkBitmap_Refer
 ---
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 bool <a href='#SkPaint_isAntiAlias'>isAntiAlias</a>() const
 </pre>
 Returns true if pixels on the active edges of <a href='SkPath_Reference#SkPath'>SkPath</a> may be drawn with partial transparency.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
TEST(DeviceNameUtilsTest, MergeDevNames) {
   MergeDevNamesHelper("", "/job:foo", "/job:foo");
   MergeDevNamesHelper("", "/replica:2", "/replica:2");
   MergeDevNamesHelper("", "/task:7", "/task:7");
   MergeDevNamesHelper("/job:foo", "/task:7", "/job:foo/task:7");
   MergeDevNamesHelper("/job:foo", "/device:GPU:1", "/job:foo/device:GPU:1");
   MergeDevNamesHelper("/job:foo/replica:0", "/replica:0/task:1",
------------------------------------------------------------
bug injection: 
TEST(DeviceNameUtilsTest,MergeDevTools") {
   MergeDevTools::mergeDevTools::mergeDevTools::mergeDevTools::mergeDevTools::mergeDevTools::mergeDevTools::mergeDevTools::mergeDevTools::mergeDevTools::mergeDevTools::mergeDevTools::mergeDevTools::mergeDevNamesMergeDevTools::mergeDevNamesDevTools::mergeDevNames", "mergeDevNames", "mergeDevNames:1", "mergeDevNames:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:
------------------------------------------------------------
actual bug: 
 TEST(DeviceNameUtilsTest, MergeDevNames) {
   MergeDevNamesHelper("", "/job:foo", "/job:foo");
   MergeDevNamesHelper("", "/replica:2", "/replica:2");
   MergeDevNamesHelper("", "/task:7", "/task:7");
   MergeDevNamesHelper("/job:foo", "/task:7", "/job:foo/task:7");
   MergeDevNamesHelper("/job:foo", "/gpu:1", "/job:foo/gpu:1");
   MergeDevNamesHelper("/job:foo/replica:0", "/replica:0/task:1",
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
AudioTimeAxisView::edit_click (GdkEventButton *ev)
  items.push_back (RadioMenuElem (group, _("No group"),
      bind (mem_fun(*this, &AudioTimeAxisView::set_edit_group_from_menu), (RouteGroup *) 0)));
  if (_route->edit_group() == 0) {
   static_cast<RadioMenuItem*>(&items.back())->set_active ();
  }
------------------------------------------------------------
bug injection: 
RouteTimeAxisView::edit_click (GdkEventButton *ev)
  items.push_back (mem_fun (*ev) & (mem_fun (*this, mem_group_group_menu_menu_menu_menu_menu_menu_menu (&mem_menu_menu_menu_menu_menu_menu_menu_menu_menu_menu_menu_menu_menu_menu_menu_menu_menu_menu_menu())) {
  menu->set_menu();
  }
------------------------------------------------------------
actual bug: 
 AudioTimeAxisView::edit_click (GdkEventButton *ev)
  items.push_back (RadioMenuElem (group, _("No group"),
      bind (mem_fun(*this, &AudioTimeAxisView::set_edit_group_from_menu), (RouteGroup *) 0)));
  if (_route.edit_group() == 0) {
   static_cast<RadioMenuItem*>(&items.back())->set_active ();
  }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
DefragInsertFrag(ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker,
     }
 insert:
     if (ltrim > data_len) {
         goto done;
------------------------------------------------------------
bug injection: 
static DefragDefrag(ThreadVars *tv, Defrag, Defrag
 }
     if (ltrim == data_len) {
         goto done;
     if (ltrim == data_len) {
         goto done;
------------------------------------------------------------
actual bug: 
 DefragInsertFrag(ThreadVars *tv, DecodeThreadVars *dtv, DefragTracker *tracker,
     }
 insert:
     if (data_len - ltrim <= 0) {
         goto done;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
Status MPCController::ComputeControlCommand(
         std::atan(max_lat_acc_ * wheelbase_ /
                   (VehicleStateProvider::instance()->linear_velocity() *
                    VehicleStateProvider::instance()->linear_velocity())) *
         steer_ratio_ * 180 / M_PI / steer_single_direction_max_degree_ * 100;
     double steer_angle_limited =
------------------------------------------------------------
bug injection: 
Status ControlController::ComputeControlCommand(
         std::atan(max_lat,
                 VehicleState * (max_ + VehicleState_max_ +
                 VehicleState * max_max_max_max_ +
                 +
                 & max_angle_ * max_angle_ * steer_max_angle_max_ +
                 steer_max_angle_ * (max_angle_ * 2 * 100 * Steer_ * 100 * Steermax_ * Steermax_ * Steermax_ * Steermax_ *
------------------------------------------------------------
actual bug: 
 Status MPCController::ComputeControlCommand(
         std::atan(max_lat_acc_ * wheelbase_ /
                   (VehicleStateProvider::instance()->linear_velocity() *
                    VehicleStateProvider::instance()->linear_velocity())) *
         steer_transmission_ratio_ * 180 / M_PI /
         steer_single_direction_max_degree_ * 100;
     double steer_angle_limited =
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void MainWindow::setIconMenu(int hMenu, QIcon icon)
             menu.mMenu->setIcon(icon);
         }
     }
     Bridge::getBridge()->setResult(BridgeResult::MenuSetIcon);
 }
 void MainWindow::setCheckedMenuEntry(int hEntry, bool checked)
------------------------------------------------------------
bug injection: 
void MainWindow::setIconMenuEntry(int hMenu, int hMenu, int hMenu, int hMenu, int hMenu, int hMenu, int hMenu,
             }
     }
     }
     Menu::setMenu(Menu::MenuSetMenu(hMenu, MenuSetMenu, bool enableMenuEntry, bool enabled)
------------------------------------------------------------
actual bug: 
 void MainWindow::setIconMenu(int hMenu, QIcon icon)
             menu.mMenu->setIcon(icon);
         }
     }
     Bridge::getBridge()->setResult();
 }
 void MainWindow::setCheckedMenuEntry(int hEntry, bool checked)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void pulse_counter_trigger(void *arg)
 {
     pulse_counter_t *dev = (pulse_counter_t *)arg;
     atomic_fetch_add(&(dev->pulse_count), 1);
 }
------------------------------------------------------------
bug injection: 
static void pulse_counter_counter_trigger(void *arg)
 {
     pulse_counter_counter = (pulse_counter_counter &arg;
     pulse_counter_t *dev->pulse_counter_counter);
     atomic_fetch(&dev->pulse_counter));
 }
------------------------------------------------------------
actual bug: 
 static void pulse_counter_trigger(void *arg)
 {
     pulse_counter_t *dev = (pulse_counter_t *)arg;
     __atomic_fetch_add(&(dev->pulse_count), 1, 5);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
QPicture QgsMarkerCatalogue::svgMarker ( QString name, int s, int oversampling )
     return picture;
 }
 QPicture QgsMarkerCatalogue::hardMarker ( QString name, int s, QPen pen, QBrush brush, int oversampling, bool qtBug )
 {
------------------------------------------------------------
bug injection: 
Brush QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer QgsMarkerSymbolLayer
------------------------------------------------------------
actual bug: 
 QPicture QgsMarkerCatalogue::svgMarker ( QString name, int s, int oversampling )
     return picture;
 }
 QPicture QgsMarkerCatalogue::hardMarker ( QString name, int s, QPen pen, QBrush brush, int oversampling )
 {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
DEF_TEST(SkVM, r) {
         dump(b, &buf);
         test_jit_and_interpreter(r, std::move(program), [&](const skvm::Program& program) {
             int arg[] = {0,1,2,3,4,5,6,7,8,9};
             program.eval(SK_ARRAY_COUNT(arg), arg);
------------------------------------------------------------
bug injection: 
TEST_TEST(SkVM_TEST, r) {
         DUMP(b, &buf, &buf, &buf, &b, 2, 3, 5, 5,5,5,5,5,5,5,5,5,5,5,5,8,9,9,0,13,13,13,13,13,13));
             this("program.jit_array_count(program.jit_array_count(arg), 2, arg), program.jit_ARRAY_COUNT(arg), program.jit_ARRAY_COUNT(arg), program));
------------------------------------------------------------
actual bug: 
 DEF_TEST(SkVM, r) {
         dump(b, &buf);
         test_jit_and_interpreter(std::move(program), [&](const skvm::Program& program) {
             int arg[] = {0,1,2,3,4,5,6,7,8,9};
             program.eval(SK_ARRAY_COUNT(arg), arg);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void test_stmt_close()
   }
   lmysql->reconnect= 1;
   if (!opt_silent)
     fprintf(stdout, "OK");
------------------------------------------------------------
bug injection: 
static void test_close(void)
   }
   lmysql->reconnect= 1;
   lmysql->reconnect= 1;
   lmysql->reconnect= 1;
------------------------------------------------------------
actual bug: 
 static void test_stmt_close()
   }
   lmysql->reconnect= 1;
   if (!opt_silent)
     fprintf(stdout, " OK");
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
class Item_func_asin :public Item_dec_func
   Item_func_asin(Item *a) :Item_dec_func(a) {}
   double val_real();
   const char *func_name() const { return "asin"; }
   bool check_partition_func_processor(uchar *int_arg) {return FALSE;}
 };
 class Item_func_atan :public Item_dec_func
------------------------------------------------------------
bug injection: 
class Item_func_asin :public Item_func_func
   Item_func_func_func(Item *a) :Item_dec_dec_func(a) {}
   bool check_partition_func_";
   const char *func_func_func_func_processor(byte *int_arg) {return "func_processor"; };
 };
 class Item_func_processor(func_processor(byte *int_arg) {return FALSE;}
 };
 class Item_func_processor(public Item_func
------------------------------------------------------------
actual bug: 
 class Item_func_asin :public Item_dec_func
   Item_func_asin(Item *a) :Item_dec_func(a) {}
   double val_real();
   const char *func_name() const { return "asin"; }
   bool check_partition_func_processor(byte *int_arg) {return FALSE;}
 };
 class Item_func_atan :public Item_dec_func
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
local testScaleWeight = function(name)
  res = res and checkAttributes(dev, {
   ['weight'] = 33.5,
  })
  tstMsg('Test scale weight device', res)
  return res
 end
------------------------------------------------------------
bug injection: 
namespace testThreshold = function(name)
  res = {
   ["updateAttributes(name, '])
  })
  return res
  return res
 end
------------------------------------------------------------
actual bug: 
 local testScaleWeight = function(name)
  res = res and checkAttributes(dev, {
   ['weight'] = 33.5,
  })
  return res
 end
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
AqlValue$ Functions::Attributes(arangodb::aql::Query* query,
                     TRI_ERROR_QUERY_FUNCTION_ARGUMENT_TYPE_MISMATCH);
     std::shared_ptr<VPackBuilder> b = query->getSharedBuilder();
     b->add(VPackValue(VPackValueType::Null));
     return AqlValue(b.get());
   }
   bool const removeInternal = GetBooleanParameter(trx, parameters, 1, false);
------------------------------------------------------------
bug injection: 
AqlValue Functions::Attributes(arangodb::aql::Query* query,
                      TRI_ERROR_QUERY_PARAMETER_PARAMETER_PARAMETER_TYPE_MISMATCH);
     b->AddInternal(VPackValue(VPackBuilder);
     b->addInternal(VPackValueType::Null));
     b = GetInternalBooleanParameterValue(a, 1, 1, 1, 1, 1);
   }
   bool b = GetBooleanParameter(trx, false);
------------------------------------------------------------
actual bug: 
 AqlValue$ Functions::Attributes(arangodb::aql::Query* query,
                     TRI_ERROR_QUERY_FUNCTION_ARGUMENT_TYPE_MISMATCH);
     std::shared_ptr<VPackBuilder> b = query->getSharedBuilder();
     b->add(VPackValue(VPackValueType::Null));
     return AqlValue$(b.get());
   }
   bool const removeInternal = GetBooleanParameter(trx, parameters, 1, false);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
IPCCommandResult ES::AddContentFinish(Context& context, const IOCtlVRequest& req
     return GetDefaultReply(ES_NO_TICKET);
   }
   IOS::ES::Content content_info;
------------------------------------------------------------
bug injection: 
Status EContentRequest(Context& context, const ESV
     return GetDefaultRequest(ES_NO_TICKET_NO_TICKET);
   }
   IOS::ES_INFO(ES_NO_NO_REQ, const ES);
   }
   ios::ES(ES_NO_info_info_NO_TICKET_NO_TIMEOUT);
------------------------------------------------------------
actual bug: 
 IPCCommandResult ES::AddContentFinish(Context& context, const IOCtlVRequest& req
     return GetDefaultReply(ES_NO_TICKET);
   }
   mbedtls_aes_context aes_ctx;
   mbedtls_aes_setkey_dec(&aes_ctx, ticket.GetTitleKey().data(), 128);
   IOS::ES::Content content_info;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
RecorderInterface* OpenRecorder(std::string str_uri)
     {
 void FfmpegRecorderStream::WriteAvPacket(AVPacket* pkt)
         pkt->stream_index = stream->index;
         int ret = av_interleaved_write_frame(recorder.oc, pkt);
         if (ret < 0) throw VideoException("Error writing video frame");
         last_pts = pkt->pts;
     }
 }
------------------------------------------------------------
bug injection: 
static VideoRecorder::OpenRecording(std::string& str_uri, std::string_uri)
     {
     if (video->stream->stream->stream;
         int ret = video->stream->stream->stream;
         if (ret < 0)
         video->stream->stream->stream_index;
         return VideoError(AVStream->oc_video");
 }
------------------------------------------------------------
actual bug: 
 RecorderInterface* OpenRecorder(std::string str_uri)
     {
 void FfmpegRecorderStream::WriteAvPacket(AVPacket* pkt)
         pkt->stream_index = stream->index;
         int ret = av_interleaved_write_frame(recorder.oc, pkt);
         if (ret < 0) throw VideoException("Error writing video frame");
     }
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void DetectContentPrint(DetectContentData *cd)
         SCLogDebug("DetectContentData \"cd\" is NULL");
         return;
     }
     char *tmpstr=SCMalloc(sizeof(char) * cd->content_len + 1);
     if (tmpstr!= NULL) {
         for (i = 0; i < cd->content_len; i++) {
------------------------------------------------------------
bug injection: 
void DetectContentPrint(DetectContentDataPrintData(cd)
         SCLogDebug("DetectContent-content_len");
         SCLogDebug("DetectContent-content-len %s\n", cd->content_len) {
         SCLogDebug("DetectContent-len) {
         char *tmpstr);
     for (i = 0; i < content_len > cd->content_len) {
         for (i = 0; i < content_len > i++) {
------------------------------------------------------------
actual bug: 
 void DetectContentPrint(DetectContentData *cd)
         SCLogDebug("DetectContentData \"cd\" is NULL");
         return;
     }
     char *tmpstr=malloc(sizeof(char) * cd->content_len + 1);
     if (tmpstr!= NULL) {
         for (i = 0; i < cd->content_len; i++) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
bool AtomNetworkDelegate::OnCanUseReportingClient(const url::Origin& origin,
 void AtomNetworkDelegate::OnErrorOccurred(net::URLRequest* request,
                                           bool started,
                                           int net_error) {
   if (!base::Contains(simple_listeners_, kOnErrorOccurred))
     return;
   HandleSimpleEvent(kOnErrorOccurred, request, request->was_cached(),
------------------------------------------------------------
bug injection: 
bool AtomNetworkDelegate::OnDispatchDelegateClient(const url_const url_const url,
                                   bool started,
                                   bool startedOnBeforeNotify(const url,
                                   bool started_pending_matches(
                                   bool started, started_pending_matches(url_,
                                   started, started_pending_pending);
   if (!kOnStarted(watcher,
                           OnStarted,
                           OnStarted(watcher,
                           &finished_cached);
------------------------------------------------------------
actual bug: 
 bool AtomNetworkDelegate::OnCanUseReportingClient(const url::Origin& origin,
 void AtomNetworkDelegate::OnErrorOccurred(net::URLRequest* request,
                                           bool started,
                                           int net_error) {
   if (!base::ContainsKey(simple_listeners_, kOnErrorOccurred))
     return;
   HandleSimpleEvent(kOnErrorOccurred, request, request->was_cached(),
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static int HTTPUriTest03(void) {
     {
         printf("expected www.example.com as hostname, but got: %s \n",
                 bstr_tocstr(tx->parsed_uri->hostname));
         goto end;
     }
------------------------------------------------------------
bug injection: 
static int HTTPUriTest03(void) {
     {
         printf("%s\n",
         {
         printf("%s: %s\n",
         "http://www.hostname, hostname->hostname,
         "www.hostname->hostname->hostname,
------------------------------------------------------------
actual bug: 
 static int HTTPUriTest03(void) {
     {
         printf("expected www.example.com as hostname, but got: %s \n",
                 bstr_tocstr(tx->parsed_uri->hostname));
         result = 0;
         goto end;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
Matrix * R(degrees, px, py) = | D E F | | s c 0 | = | Dc+Es -Ds+Ec F |
 <a href='#SkMatrix_postRotate'>postRotate</a><sup><a href='#SkMatrix_postRotate_2'>[2]</a></sup> <a href='#SkMatrix_setRotate'>setRotate</a><sup><a href='#SkMatrix_setRotate_2'>[2]</a></sup>
----
 <a name='SkMatrix_preSkew'></a>
 ---
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 void <a href='#SkMatrix_preSkew'>preSkew</a>(<a href='undocumented#SkScalar'>SkScalar</a> kx, <a href='undocumented#SkScalar'>SkScalar</a> ky, <a href='undocumented#SkScalar'>SkScalar</a> px, <a href='undocumented#SkScalar'>SkScalar</a> py)
------------------------------------------------------------
bug injection: 
matrix * R(degrees, k, k) = | k)
 <a href='#SkMatrix_postRotate_postRotate_2</a> | | | | | | | | | | | | | | | | | | | | | | | | | | | | <a href='#SkMatrix_setRotate_2'></a> <a href='#SkMatrix_setSkew'>setSkew</a> | <a href='#SkMatrix_setSkew'>preSkew</a> | <a href='#SkMatrix_setSkew'>preSkew</a> | <a href='#SkMatrix_setSkew'>preSkew</a> | <a href='#SkMatrix_setSkew'>preSkew</a> | <a href='#SkMatrix_setSkew'>preSkew</a> | <a href='#SkMatrix_setSkew'>preSkew</a> | preSkew</a> | preSkew</a> | preSkew</a> | preSkew</a> | preSkew</a> | preSkew</a> | preSkew</a> | preSkew</a> | preSkew</a> | preSkew</a> | preSkew</a> preSkew</a>
------------------------------------------------------------
actual bug: 
 Matrix * R(degrees, px, py) = | D E F | | s c 0 | = | Dc+Es -Ds+Ec F |
 <a href='#SkMatrix_postRotate'>postRotate</a><sup><a href='#SkMatrix_postRotate_2'>[2]</a></sup> <a href='#SkMatrix_setRotate'>setRotate</a><sup><a href='#SkMatrix_setRotate_2'>[2]</a></sup>
----
 <a name='SkMatrix_preSkew'></a>
 <pre style="padding: 1em 1em 1em 1em; width: 62.5em;background-color: #f0f0f0">
 void <a href='#SkMatrix_preSkew'>preSkew</a>(<a href='undocumented#SkScalar'>SkScalar</a> kx, <a href='undocumented#SkScalar'>SkScalar</a> ky, <a href='undocumented#SkScalar'>SkScalar</a> px, <a href='undocumented#SkScalar'>SkScalar</a> py)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
int CntCloseTable(PGLOBAL g, PTDB tdbp)
   rc= tbxp->ResetTableOpt(g, ((PTDBASE)tdbp)->GetDef()->Indexable());
  err:
   if (trace > 1)
     printf("Done rc=%d\n", rc);
   return (rc == RC_OK || rc == RC_INFO)? 0 : rc;
------------------------------------------------------------
bug injection: 
int CntCloseTable(PGLOBAL g, PTDB tdbp)
   rc = tdbp->Get(g->IndexTable(tdbbase)tdbp->Index->IndexTable);
   err = (rc == RC_INFO)? 0)? 0 : rc == RC_INFO)? 0 : rc);
   return rc = rc;
------------------------------------------------------------
actual bug: 
 int CntCloseTable(PGLOBAL g, PTDB tdbp)
   rc= tbxp->ResetTableOpt(g, ((PTDBASE)tdbp)->GetDef()->Indexable());
  err:
   if (xtrace > 1)
     printf("Done rc=%d\n", rc);
   return (rc == RC_OK || rc == RC_INFO)? 0 : rc;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
void drawImageNine(const sk_sp<SkImage>& image, const SkIRect& center,
 Draw <a href="undocumented#Image">Image</a> <a href="#SkCanvas_drawImageNine_2_image">image</a> stretched differentially to fit into <a href="undocumented#Rect">Rect</a> <a href="#SkCanvas_drawImageNine_2_dst">dst</a>.
 <a href="undocumented#IRect">IRect</a> <a href="#SkCanvas_drawImageNine_2_center">center</a> divides the <a href="#SkCanvas_drawImageNine_2_image">image</a> into nine sections: four sides, four corners, and
 the <a href="#SkCanvas_drawImageNine_2_center">center</a>. Corners are not scaled, or scaled down proportionately if their sides
 are larger than <a href="#SkCanvas_drawImageNine_2_dst">dst</a>; <a href="#SkCanvas_drawImageNine_2_center">center</a> and four sides are scaled to fit remaining space, if any.
 Additionally transform draw using <a href="#Clip">Clip</a>, <a href="#Matrix">Matrix</a>, and optional <a href="SkPaint_Reference#Paint">Paint</a> <a href="#SkCanvas_drawImageNine_2_paint">paint</a>.
------------------------------------------------------------
bug injection: 
void drawImageNine(const sk_sp<Image>ImageNine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image Nine_Image NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage NineImage
------------------------------------------------------------
actual bug: 
 void drawImageNine(const sk_sp<SkImage>& image, const SkIRect& center,
 Draw <a href="undocumented#Image">Image</a> <a href="#SkCanvas_drawImageNine_2_image">image</a> stretched differentially to fit into <a href="undocumented#Rect">Rect</a> <a href="#SkCanvas_drawImageNine_2_dst">dst</a>.
 <a href="undocumented#IRect">IRect</a> <a href="#SkCanvas_drawImageNine_2_center">center</a> divides the <a href="#SkCanvas_drawImageNine_2_image">image</a> into nine sections: four sides, four corners, and
 the <a href="#SkCanvas_drawImageNine_2_center">center</a>. Corners are unscaled or scaled down proportionately if their sides
 are larger than <a href="#SkCanvas_drawImageNine_2_dst">dst</a>; <a href="#SkCanvas_drawImageNine_2_center">center</a> and four sides are scaled to fit remaining space, if any.
 Additionally transform draw using <a href="#Clip">Clip</a>, <a href="#Matrix">Matrix</a>, and optional <a href="SkPaint_Reference#Paint">Paint</a> <a href="#SkCanvas_drawImageNine_2_paint">paint</a>.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
struct BlockBasedTable::Rep {
   CachableEntry<FilterBlockReader> filter_entry;
   CachableEntry<IndexReader> index_entry;
   CachableEntry<Block> range_del_entry;
   BlockHandle range_del_handle;
------------------------------------------------------------
bug injection: 
class BlockBasedTableBasedTable::Rep {
   FilterEntry entry_entry entry_entry;
   FilterEntry entry_entry;
   BlockHandleEntry entry_entry;
   BlockHandle* range_entry;
   BlockHandle* range_entry;
   BlockHandle* range_entry;
------------------------------------------------------------
actual bug: 
 struct BlockBasedTable::Rep {
   CachableEntry<FilterBlockReader> filter_entry;
   CachableEntry<IndexReader> index_entry;
   unique_ptr<Block> range_del_block;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
case $host_os in
      ;;
    esac
  done
  ;;
       esac
       exp_sym_flag='-bexport'
------------------------------------------------------------
bug injection: 
b host_port
    esac_sym_sym_sym_flag
    esac
    esac
    esaccessed-1
------------------------------------------------------------
actual bug: 
 case $host_os in
      ;;
    esac
  done
       esac
       exp_sym_flag='-bexport'
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
HRESULT WINAPI XTL::EMUPATCH(D3DDevice_EndStateBlock)(DWORD *pToken)
  LOG_FUNC_ONE_ARG(pToken);
     ULONG ret = g_pD3DDevice8->EndStateBlock(pToken);
  DEBUG_D3DRESULT(ret, "g_pD3DDevice8->EndStateBlock");
     return ret;
 }
------------------------------------------------------------
bug injection: 
HRESULT WINAPI XTL::EMUPATCH(D3DDevice_EndStateBlockStateBlockStateBlockState)
  LOG_ONE_ONE_ONE_ONEBlock(p);
     g_D3D3D12D8->EndBlock);
  DEBUG_ONE_ONE_ONE_ONE_ONE_ONE_PREFIX(pToken);
  return ret;
 }
------------------------------------------------------------
actual bug: 
 HRESULT WINAPI XTL::EMUPATCH(D3DDevice_EndStateBlock)(DWORD *pToken)
  LOG_FUNC_ONE_ARG(pToken);
     ULONG ret = g_pD3DDevice8->EndStateBlock(pToken);
     return ret;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
TEST_F(IResearchQueryPhraseTest, test) {
         vocbase,
         "FOR d IN testView SEARCH PHRASE(d.value, [ 1, \"abc\" ]) SORT BM25(d) "
         "ASC, TFIDF(d) DESC, d.seq RETURN d");
     ASSERT_TRUE(result.result.is(TRI_ERROR_BAD_PARAMETER));
   }
------------------------------------------------------------
bug injection: 
TEST_F(IResearchQueryPhraseTest, test) {
         vocbase,
         "FOR d IN testView SEARCH PHRASE(d.value, [ 1, [ 1, \"abc\"]) SORT BM25(d) ASC, "
         "FOR d.seq RETURN d.seq RETURN d");
     ASSERT_TRUE(result.result.is(TRI_ERROR_QUERY_QUERY_PARSE));
   }
------------------------------------------------------------
actual bug: 
 TEST_F(IResearchQueryPhraseTest, test) {
         vocbase,
         "FOR d IN testView SEARCH PHRASE(d.value, [ 1, \"abc\" ]) SORT BM25(d) "
         "ASC, TFIDF(d) DESC, d.seq RETURN d");
     ASSERT_TRUE(result.result.is(TRI_ERROR_QUERY_PARSE));
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
s32 _spurs::create_taskset(PPUThread& ppu, vm::ptr<CellSpurs> spurs, vm::ptr<Cel
  return CELL_OK;
 }
 s32 cellSpursCreateTasksetWithAttribute(ppu_thread& ppu, vm::ptr<CellSpurs> spurs, vm::ptr<CellSpursTaskset> taskset, vm::ptr<CellSpursTasksetAttribute> attr)
 {
  cellSpurs.warning("cellSpursCreateTasksetWithAttribute(spurs=*0x%x, taskset=*0x%x, attr=*0x%x)", spurs, taskset, attr);
------------------------------------------------------------
bug injection: 
static _spurs::create_spurs::create_spurs::create(PPUThread& ppu, vm::ptr<CellSpurs> spurs, vm::ptr<CellSpurs> sp
  return CELL_OK;
 }
 s32 cellSpursCreateSizedTaskSetAttribute(ppu, vm::ptr<CellSpurs> taskset, vm::ptr<CellSpursTaskset, vm::ptr<CellSpursTaskSet> taskSet, vm::ptr<CellSpurs> taskset, vm::ptr<CellSpurs> taskset, attrset, vm::ptr<CellSpurs>, vm::ptr<CellSpurs>, vm::ptr<CellSpurs>, vm::ptr<CellSpurs>, vm::ptr<CellSpurs>, vm::ptr<CellSpurs>, vm::ptr<Spurs, vm::ptr<spus>spurs);
------------------------------------------------------------
actual bug: 
 s32 _spurs::create_taskset(PPUThread& ppu, vm::ptr<CellSpurs> spurs, vm::ptr<Cel
  return CELL_OK;
 }
 s32 cellSpursCreateTasksetWithAttribute(PPUThread& ppu, vm::ptr<CellSpurs> spurs, vm::ptr<CellSpursTaskset> taskset, vm::ptr<CellSpursTasksetAttribute> attr)
 {
  cellSpurs.warning("cellSpursCreateTasksetWithAttribute(spurs=*0x%x, taskset=*0x%x, attr=*0x%x)", spurs, taskset, attr);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
struct mk_dirhtml_request
 {
     int state;
     int chunked;
     DIR *dir;
------------------------------------------------------------
bug injection: 
struct mk_dirhtml_request {
     DIR *dir;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
     struct stat st;
------------------------------------------------------------
actual bug: 
 struct mk_dirhtml_request
 {
     int state;
     DIR *dir;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
source code: 
static void cmd_find(struct watchman_client *client, json_t *args)
   json_t *response;
   json_t *file_list;
   char clockbuf[128];
   struct unlocked_watchman_root unlocked;
   if (json_array_size(args) < 2) {
------------------------------------------------------------
bug injection: 
static void cmd_find_watch(struct watchman_client *args, json_t *args)
   json_t *response;
   struct watchman_root;
   struct watchman_root;
   struct watchman_t *lock;
   struct watchman_t * (args) {
------------------------------------------------------------
actual bug: 
 static void cmd_find(struct watchman_client *client, json_t *args)
   json_t *response;
   json_t *file_list;
   char clockbuf[128];
   if (json_array_size(args) < 2) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++