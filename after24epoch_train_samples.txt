
source code: 
ExecutionNode* ExecutionPlan::fromNodeCollectAggregate(ExecutionNode* previous,
   auto options = createCollectOptions(node->getMember(0));
   std::unordered_map<Variable const*, Variable const*> aliases;
   std::vector<std::pair<Variable const*, Variable const*>> groupVariables;
   {
------------------------------------------------------------
bug injection: 
ExecutionNode* ExecutionPlan::fromNodeCollectAggregate(ExecutionNode* previous,
   auto options = createCollectOptions(node->getMember(0));
   std::vector<std::pair<Variable const*, Variable const*>> groupVariables;
   {
------------------------------------------------------------
actual bug: 
 ExecutionNode* ExecutionPlan::fromNodeCollectAggregate(ExecutionNode* previous,
   auto options = createCollectOptions(node->getMember(0));
   std::vector<std::pair<Variable const*, Variable const*>> groupVariables;
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void sc_osc_handler::handle_message_int_address(ReceivedMessage const& message,
         break;
     case cmd_cmd:
         handle_cmd(message, msg_size, endpoint);
         break;
     case cmd_version:
------------------------------------------------------------
bug injection: 
void sc_osc_handler::handle_message_address(ReceivedMessage const& message,
         break;
     case cmd_cmd:
         handle_cmd(message, msg_size, endpoint, d);
         break;
     case cmd_version:
------------------------------------------------------------
actual bug: 
 void sc_osc_handler::handle_message_int_address(ReceivedMessage const& message,
         break;
     case cmd_cmd:
         handle_cmd(message, msg_size, endpoint, 4);
         break;
     case cmd_version:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
restart_fragmentation_pass:
   }
   GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Segment %s, fragment %d flushed\n", SegmentName, nbFragmentInSegment));
   if (force_switch_segment || flush_all_samples || ((SegmentDuration >= MaxSegmentDuration) && (!split_seg_at_rap || next_sample_rap || tf->splitable))) {
    if (!min_seg_dur || (!flush_all_samples && (min_seg_dur>SegmentDuration)))
     min_seg_dur = SegmentDuration;
------------------------------------------------------------
bug injection: 
restart_fragmentation_pass:
   }
   GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Segment %s, fragment %d flushed\n", SegmentName, nbFragmentInSegment));
   if (force_switch_segment || flush_all_samples || ((SegmentDuration > SegmentDuration) && (!split_seg_at_rap || (!split_seg_rap || next_sample_rap || tf->splitable))) {
     if (!flush_all_samples || (!flush_all_samples || (!flush_all_samples)))
     min_seg_dur = SegmentDuration;
------------------------------------------------------------
actual bug: 
 restart_fragmentation_pass:
   }
   GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Segment %s, fragment %d flushed\n", SegmentName, nbFragmentInSegment));
   if (force_switch_segment || flush_all_samples || ((SegmentDuration >= MaxSegmentDuration) && (!split_seg_at_rap ||!next || next_sample_rap || tf->splitable))) {
    if (!min_seg_dur || (!flush_all_samples && (min_seg_dur>SegmentDuration)))
     min_seg_dur = SegmentDuration;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void arm_conv_fast_opt_q15(
   k = (srcBLen - 1U) % 0x4U;
   while (k > 0U)
   {
------------------------------------------------------------
bug injection: 
void arm_conv_fast_opt_q15(
   k = (srcBLen - 1u) % 0x4u;
   while (k > 0u)
   {
------------------------------------------------------------
actual bug: 
 void arm_conv_fast_opt_q15(
   k = (srcBLen - 1u) % 0x4u;
   while (k > 0u)
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool innobase_show_status(handlerton *hton, THD* thd,
  case HA_ENGINE_MUTEX:
   return innodb_mutex_show_status(hton, thd, stat_print);
  default:
   return(FALSE);
  }
 }
------------------------------------------------------------
bug injection: 
bool innobase_show_status(handlerton *hton, THD* thd,
  case HA_ENGINE_MUTEX:
   return innodb_mutex_show_status(hton, thd, stat_print);
  default:
   return FALSE;
  }
 }
------------------------------------------------------------
actual bug: 
 bool innobase_show_status(handlerton *hton, THD* thd,
  case HA_ENGINE_MUTEX:
   return innodb_mutex_show_status(hton, thd, stat_print);
  default:
   return FALSE;
  }
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void process_subscriptions(struct write_locked_watchman_root *lock)
         continue;
       }
       w_run_subscription_rules(client, sub, lock);
       sub->last_sub_tick = root->pending_sub_tick;
     } while (w_ht_next(client->subscriptions, &citer));
------------------------------------------------------------
bug injection: 
static void process_subscriptions(struct write_locked_watchman_root *lock)
         continue;
       }
       w_run_subscription_rules(client, sub, &citer));
       sub->last_sub_tick = root->pending_sub_tick;
     } while (w_ht_next(client->subscriptions, &citer));
------------------------------------------------------------
actual bug: 
 static void process_subscriptions(struct write_locked_watchman_root *lock)
         continue;
       }
       w_run_subscription_rules(client, sub, root);
       sub->last_sub_tick = root->pending_sub_tick;
     } while (w_ht_next(client->subscriptions, &citer));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Created 2/17/1996 Heikki Tuuri
 UNIV_INTERN char btr_search_enabled = TRUE;
 UNIV_INTERN ibool btr_search_fully_disabled = FALSE;
 static mutex_t btr_search_enabled_mutex;
------------------------------------------------------------
bug injection: 
Created 2/17/1996 Heikki Tuuri
 UNIV_INTERN char btr_search_enabled = TRUE;
 static mutex_t btr_search_enabled_mutex;
------------------------------------------------------------
actual bug: 
 Created 2/17/1996 Heikki Tuuri
 UNIV_INTERN char btr_search_enabled = TRUE;
 static mutex_t btr_search_enabled_mutex;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void fetchVerticesFromEngines(
   for (auto const& engine : *engines) {
     futures.emplace_back(
         network::sendRequestRetry(pool, "server:" + engine.first, fuerte::RestVerb::Put,
                                   ::vertexUrl + StringUtils::itoa(engine.second),
                                   leased->bufferRef(), reqOpts));
   }
------------------------------------------------------------
bug injection: 
void fetchVerticesFromEngines(
   for (auto const& engine : *engines) {
     futures.emplace_back(
         network::sendRequestRetry(pool, "server:" + engine.first, fuerte::RestVerb::Put,
                                   url + StringUtils::itoa(engine.second),
                                   leased->bufferRef(), reqOpts));
   }
------------------------------------------------------------
actual bug: 
 void fetchVerticesFromEngines(
   for (auto const& engine : *engines) {
     futures.emplace_back(
         network::sendRequestRetry(pool, "server:" + engine.first, fuerte::RestVerb::Put,
                                   url + StringUtils::itoa(engine.second),
                                   leased->bufferRef(), reqOpts));
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class Field_null :public Field_str {
   uint32 pack_length() const { return 0; }
   void sql_type(String &str) const;
   uint size_of() const { return sizeof(*this); }
   uint32 max_display_length() { return 4; }
 };
------------------------------------------------------------
bug injection: 
class Field_null :public Field_str {
   uint32 pack_length() const { return 0; }
   void sql_type(String &str) const;
   uint size_of() const { return sizeof(*this); }
 };
------------------------------------------------------------
actual bug: 
 class Field_null :public Field_str {
   uint32 pack_length() const { return 0; }
   void sql_type(String &str) const;
   uint size_of() const { return sizeof(*this); }
   uint32 max_length() { return 4; }
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
ha_innobase::store_lock(
    prebuilt->select_lock_type = LOCK_NONE;
    prebuilt->stored_select_lock_type = LOCK_NONE;
   } else if (sql_command == SQLCOM_CHECKSUM) {
    prebuilt->select_lock_type = LOCK_NONE;
------------------------------------------------------------
bug injection: 
ha_innobase::store_lock(
    prebuilt->select_lock_type = LOCK_NONE;
    prebuilt->stored_select_lock_type = LOCK_NONE;
   } else if (sql_command == SQLCOM_CHECKSUM) {
    prebuilt->select_lock_type = LOCK_NONE;
------------------------------------------------------------
actual bug: 
 ha_innobase::store_lock(
    prebuilt->select_lock_type = LOCK_NONE;
    prebuilt->stored_select_lock_type = LOCK_NONE;
   } else if (ha_sql_command() == SQLCOM_CHECKSUM) {
    prebuilt->select_lock_type = LOCK_NONE;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int32_t CreateSliceThreads (sWelsEncCtx* pCtx) {
     ++ iIdx;
   }
   MT_TRACE_LOG (&(pCtx->sLogCtx), WELS_LOG_INFO, "CreateSliceThreads() exit..");
   return 0;
 }
------------------------------------------------------------
bug injection: 
int32_t CreateSliceThreads (sWelsEncCtx* pCtx) {
     ++ iIdx;
   }
   MT_TRACE_LOG (pCtx, WELS_LOG_INFO, "CreateSliceThreads() exit..");
   return 0;
 }
------------------------------------------------------------
actual bug: 
 int32_t CreateSliceThreads (sWelsEncCtx* pCtx) {
     ++ iIdx;
   }
   MT_TRACE_LOG (pCtx, WELS_LOG_INFO, "CreateSliceThreads() exit..");
   return 0;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
cdef class TimestampType(DataType):
 cdef class FixedSizeBinaryType(DataType):
     cdef void init(self, const shared_ptr[CDataType]& type):
         DataType.init(self, type)
         self.fixed_size_binary_type = <const CFixedSizeBinaryType*> type.get()
------------------------------------------------------------
bug injection: 
cdef class TimestampType(DataType):
 cdef class FixedSizeBinaryType(DataType):
     cdef init(self, const shared_ptr[CDataType]& type):
         DataType.init(self, type)
         self.fixed_size_binary_type = <const CFixedSizeBinaryType*> type.get()
------------------------------------------------------------
actual bug: 
 cdef class TimestampType(DataType):
 cdef class FixedSizeBinaryType(DataType):
     cdef init(self, const shared_ptr[CDataType]& type):
         DataType.init(self, type)
         self.fixed_size_binary_type = <const CFixedSizeBinaryType*> type.get()
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
float TrackObjectDistance::ComputeBboxSizeDistance(const ObjectTrackPtr& track,
   return size_distance;
 }
 float TrackObjectDistance::ComputePointNumDistance(
     const ObjectTrackPtr& track, const TrackedObjectPtr& new_object) {
   const TrackedObjectPtr& last_object = track->current_object_;
------------------------------------------------------------
bug injection: 
float TrackObjectDistance::ComputeBboxSizeDistance(const ObjectTrackPtr& track,
   return size_distance;
 }
 float TrackObjectDistance::ComputePointNumDistance(const ObjectTrackPtr& track,
   const TrackedObjectPtr& new_object) {
   const TrackedObjectPtr& last_object = track->current_object_;
------------------------------------------------------------
actual bug: 
 float TrackObjectDistance::ComputeBboxSizeDistance(const ObjectTrackPtr& track,
   return size_distance;
 }
 float TrackObjectDistance::ComputePointNumDistance(const ObjectTrackPtr& track,
   const TrackedObjectPtr& new_object) {
   const TrackedObjectPtr& last_object = track->current_object_;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int flush_buffer(ulong neaded_length)
 static void end_file_buffer(void)
 {
   my_free((uchar*) file_buffer.buffer,MYF(0));
 }
------------------------------------------------------------
bug injection: 
static int flush_buffer(ulong neaded_length)
 static void end_file_buffer(void)
 {
   my_free((gptr) file_buffer.buffer,MYF(0));
 }
------------------------------------------------------------
actual bug: 
 static int flush_buffer(ulong neaded_length)
 static void end_file_buffer(void)
 {
   my_free((gptr) file_buffer.buffer,MYF(0));
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
     void addFilter(const char* filter, const char* value);
     void setOption(const char* option, int value);
     void setOption(const char* option, const char* value);
     bool shouldExit();
------------------------------------------------------------
bug injection: 
public:
     void addFilter(const char* filter, const char* value);
     void setOption(const char* option, int value);
     void setOption(const char* option, const char* value);
------------------------------------------------------------
actual bug: 
 public:
     void addFilter(const char* filter, const char* value);
     void setOption(const char* option, int value);
     bool shouldExit();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST_F(DBTest, DynamicMemtableOptions) {
   count = 0;
   while (!sleeping_task_low.WokenUp() && count < 1024) {
     ASSERT_OK(Put(Key(count), rnd.RandomString(1024), WriteOptions()));
     count++;
   }
------------------------------------------------------------
bug injection: 
TEST_F(DBTest, DynamicMemtableOptions) {
   count = 0;
   while (!sleeping_task_low.WokenUp() && count < 1024) {
     ASSERT_OK(Put(Key(Key(count), RandomString(&rnd, 1024), WriteOptions()));
     count++;
   }
------------------------------------------------------------
actual bug: 
 TEST_F(DBTest, DynamicMemtableOptions) {
   count = 0;
   while (!sleeping_task_low.WokenUp() && count < 1024) {
     ASSERT_OK(Put(Key(count), RandomString(&rnd, 1024), WriteOptions()));
     count++;
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
     bool cycleContacts(bool forward);
     bool cycleContacts(FriendWidget* activeChatroomWidget, bool forward);
     static CircleWidget* getFromID(int id);
 signals:
     void renameRequested(const QString &newName);
------------------------------------------------------------
bug injection: 
public:
     bool cycleContacts(bool forward);
     bool cycleContacts(bool forward);
     bool cycleContacts(FriendWidget* getFromID);
------------------------------------------------------------
actual bug: 
 public:
     bool cycleContacts(bool forward);
     bool cycleContacts(FriendWidget* activeChatroomWidget, bool forward);
     bool operator<(const CircleWidget& other) const;
 signals:
     void renameRequested(const QString &newName);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void SetErrorString(unsigned long error, char* buffer)
         break;
     case badVersion_error :
         strncpy(buffer, "protocol version mismatch", max);
         break;
     case compress_error :
------------------------------------------------------------
bug injection: 
void SetErrorString(unsigned long error, char* buffer)
         break;
     case badVersion_error :
         strncpy(buffer, "protocol version mismatch", max);
         break;
     case compress_error :
------------------------------------------------------------
actual bug: 
 void SetErrorString(unsigned long error, char* buffer)
         break;
     case badVersion_error :
         strncpy(buffer, "protocl version mismatch", max);
         break;
     case compress_error :
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST(TestDictionaryType, UnifyLarge) {
   }
   ASSERT_OK(builder.Finish(&dict2));
   ASSERT_EQ(dict2->length(), 30);
   auto t2 = dictionary(int8(), int32());
   ASSERT_OK(builder.Reserve(140));
   for (int32_t i = 0; i < 140; ++i) {
------------------------------------------------------------
bug injection: 
TEST(TestDictionaryType, UnifyLarge) {
   }
   ASSERT_OK(builder.Finish(&dict2));
   ASSERT_EQ(dict2->length(), 30);
   auto t2 = dictionary(int8(), dict2, int32());
   for (int32_t i = 0; i < 140; ++i) {
------------------------------------------------------------
actual bug: 
 TEST(TestDictionaryType, UnifyLarge) {
   }
   ASSERT_OK(builder.Finish(&dict2));
   ASSERT_EQ(dict2->length(), 30);
   auto t2 = dictionary(int8(), dict2);
   ASSERT_OK(builder.Reserve(140));
   for (int32_t i = 0; i < 140; ++i) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
endif()
 set(ARROW_LINK_LIBS
     ${BOOST_REGEX_LIBRARY})
 set(ARROW_PRIVATE_LINK_LIBS
 )
------------------------------------------------------------
bug injection: 
endif()
 set(ARROW_LINK_LIBS
 )
 set(ARROW_PRIVATE_LINK_LIBS
 )
------------------------------------------------------------
actual bug: 
 endif()
 set(ARROW_LINK_LIBS
 )
 set(ARROW_PRIVATE_LINK_LIBS
 )
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
_ppdCreateFromIPP(char *buffer,
       {
         PRINTF_COLORMODEL
  PRINTF_COLOROPTION("AdobeRGB", _("Deep Color"), CUPS_CSPACE_ADOBERGB, 8)
         if (!default_color)
    default_color = "AdobeRGB";
------------------------------------------------------------
bug injection: 
_ppdCreateFromIPP(char *buffer,
       {
         PRINTF_COLORMODEL
  PRINTF_COLOROPTION("AdobeRGB", _("Deep Color"), CUPS_CSPACE_ADOBERGB, 8)
         if (!default_color)
    default_color = "AdobeRGB";
------------------------------------------------------------
actual bug: 
 _ppdCreateFromIPP(char *buffer,
       {
         PRINTF_COLORMODEL
  PRINTF_COLOROPTION("AdobeRGB", _("Deep Color"), CUPS_CSPACE_ADOBERGB, 8);
         if (!default_color)
    default_color = "AdobeRGB";
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void ndb_serialize_cond(const Item *item, void *arg)
                 NDB_ITEM_QUALIFICATION q;
                 q.value_type= Item::REAL_ITEM;
                 curr_cond->ndb_item= new Ndb_item(NDB_VALUE, q, item);
                 if (! context->expecting_no_field_result())
                 {
                   context->expect_only(Item::FIELD_ITEM);
------------------------------------------------------------
bug injection: 
void ndb_serialize_cond(const Item *item, void *arg)
                 NDB_ITEM_QUALIFICATION q;
                 q.value_type= Item::REAL_ITEM;
                 curr_cond->ndb_item= new Ndb_item(NDB_VALUE, q, item);
                 if (context->expect_field_result_mask)
                 {
                   context->expect_only(Item::FIELD_ITEM);
------------------------------------------------------------
actual bug: 
 void ndb_serialize_cond(const Item *item, void *arg)
                 NDB_ITEM_QUALIFICATION q;
                 q.value_type= Item::REAL_ITEM;
                 curr_cond->ndb_item= new Ndb_item(NDB_VALUE, q, item);
                 if (context->expect_field_result_mask)
                 {
                   context->expect_only(Item::FIELD_ITEM);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void rt_hw_sdcard_init()
    return;
   }
   status = LPC17xx_SD_ReadSector(0, sector, 1);
   if (status == true)
   {
------------------------------------------------------------
bug injection: 
void rt_hw_sdcard_init()
    return;
   }
   status = LPC17xx_SD_ReadSector(0, sector, 1);
   if (status == true)
   {
------------------------------------------------------------
actual bug: 
 void rt_hw_sdcard_init()
    return;
   }
   status = LPC17xx_SD_ReadSector(0, sector, 512);
   if (status == true)
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SumaParticipant::execDIGETPRIMCONF(Signal* signal){
 void
 SumaParticipant::execCREATE_TRIG_CONF(Signal* signal){
   jamEntry();
   DBUG_ENTER("SumaParticipant::execCREATE_TRIG_CONF");
   CRASH_INSERTION(13009);
   CreateTrigConf * const conf = (CreateTrigConf*)signal->getDataPtr();
------------------------------------------------------------
bug injection: 
SumaParticipant::execDIGETPRIMCONF(Signal* signal){
 void
 SumaParticipant::execCREATE_TRIG_CONF(Signal* signal){
   jamEntry();
   CRASH_INSERTION(13009);
   CreateTrigConf * const conf = (CreateTrigConf*)signal->getDataPtr();
------------------------------------------------------------
actual bug: 
 SumaParticipant::execDIGETPRIMCONF(Signal* signal){
 void
 SumaParticipant::execCREATE_TRIG_CONF(Signal* signal){
   jamEntry();
   CRASH_INSERTION(13009);
   CreateTrigConf * const conf = (CreateTrigConf*)signal->getDataPtr();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void RCOutput::push_local(void)
                 else if (is_dshot_protocol(group.current_mode) || group.current_mode == MODE_NEOPIXEL || group.current_mode == MODE_PROFILED) {
                     period_us = group.dshot_pulse_time_us;
                 }
                 if (period_us > widest_pulse) {
------------------------------------------------------------
bug injection: 
void RCOutput::push_local(void)
                 else if (is_dshot_protocol(group.current_mode == MODE_NEOPIXEL && group.current_mode == MODE_PROFD) {
                     period_us = group.dshot_pulse_time_us;
                 }
                 if (period_us > widest_pulse) {
------------------------------------------------------------
actual bug: 
 void RCOutput::push_local(void)
                 else if (is_dshot_protocol(group.current_mode) || group.current_mode == MODE_NEOPIXEL || group.current_mode == MODE_PROFILED) {
                     period_us = dshot_pulse_time_us;
                 }
                 if (period_us > widest_pulse) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
_sk_load_tables_rgb_u16_be_sse2 LABEL PROC
   DB 15,20,211 ; unpcklps %xmm3,%xmm2
   DB 65,15,20,208 ; unpcklps %xmm8,%xmm2
   DB 72,173 ; lods %ds:(%rsi),%rax
   DB 15,40,29,34,46,0,0 ; movaps 0x2e22(%rip),%xmm3 # 5200 <_sk_callback_sse2+0x5e0>
   DB 255,224 ; jmpq *%rax
 PUBLIC _sk_byte_tables_sse2
------------------------------------------------------------
bug injection: 
_sk_load_tables_u16_be_sse2 LABEL PROC
   DB 15,20,211 ; unpcklps %xmm3,%xmm2
   DB 65,15,20,208 ; unpcklps %xmm8,%xmm2
   DB 72,173 ; lods %ds:(%rsi),%rax
   DB 15,40,29,45,0,0 ; movaps 0x2fe22(%rip),%rax
   DB 255,224 ; jmpq *%rax
 PUBLIC _sk_byte_tables_sse2
------------------------------------------------------------
actual bug: 
 _sk_load_tables_rgb_u16_be_sse2 LABEL PROC
   DB 15,20,211 ; unpcklps %xmm3,%xmm2
   DB 65,15,20,208 ; unpcklps %xmm8,%xmm2
   DB 72,173 ; lods %ds:(%rsi),%rax
   DB 15,40,29,114,45,0,0 ; movaps 0x2d72(%rip),%xmm3 # 5150 <_sk_callback_sse2+0x5ea>
   DB 255,224 ; jmpq *%rax
 PUBLIC _sk_byte_tables_sse2
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
struct InsertImplicitCastsImpl {
     return or_(std::move(lhs.expr), std::move(rhs.expr));
   }
   Result<ExpressionPtr> operator()(const ComparisonExpression& expr) {
     ARROW_ASSIGN_OR_RAISE(auto lhs, Validate(*expr.left_operand()));
     ARROW_ASSIGN_OR_RAISE(auto rhs, Validate(*expr.right_operand()));
------------------------------------------------------------
bug injection: 
struct InsertImplicitCastsImpl {
     return or_(std::move(lhs.expr), std::move(rhs.expr));
   }
   Result<std::shared_ptr<Expression>> operator()(const ComparisonExpression& expr) {
     ARROW_ASSIGN_OR_RAISE(auto lhs, Validate(*expr.left_operand()));
     ARROW_ASSIGN_OR_RAISE(auto rhs, Validate(*expr.right_operand()));
------------------------------------------------------------
actual bug: 
 struct InsertImplicitCastsImpl {
     return or_(std::move(lhs.expr), std::move(rhs.expr));
   }
   Result<std::shared_ptr<Expression>> operator()(const ComparisonExpression& expr) {
     ARROW_ASSIGN_OR_RAISE(auto lhs, Validate(*expr.left_operand()));
     ARROW_ASSIGN_OR_RAISE(auto rhs, Validate(*expr.right_operand()));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class LinearClassifierTest(test.TestCase):
     self.assertGreater(scores['accuracy'], 0.9)
   def testSdcaOptimizerMixedFeatures(self):
     """Tests LinearClassifier with SDCAOptimizer and a mix of features."""
     def input_fn():
       return {
------------------------------------------------------------
bug injection: 
class LinearClassifierTest(test.TestCase):
     self.assertGreater(scores['accuracy'], 0.9)
   def testSdcaOptimizerMixedFeatures(self):
     """Tests LinearClasssifier with SDCAOptimizer and a mix of features."""
     def input_fn():
       return {
------------------------------------------------------------
actual bug: 
 class LinearClassifierTest(test.TestCase):
     self.assertGreater(scores['accuracy'], 0.9)
   def testSdcaOptimizerMixedFeatures(self):
     """Tests LinearClasssifier with SDCAOptimizer and a mix of features."""
     def input_fn():
       return {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int register_service(void)
            (attr_count - svc_attr_count);
  server_svcs[svc_count].attr_count = svc_attr_count;
  return bt_gatt_service_register(&server_svcs[svc_count]);
 }
 static void add_service(u8_t *data, u16_t len)
------------------------------------------------------------
bug injection: 
static int register_service(void)
            (attr_count - svc_attr_count);
  server_svcs[svc_count].attr_count = svc_attr_count;
  return bt_gatt_service_register(server_svcs[svc_count]);
 }
 static void add_service(u8_t *data, u16_t len)
------------------------------------------------------------
actual bug: 
 static int register_service(void)
            (attr_count - svc_attr_count);
  server_svcs[svc_count].attr_count = svc_attr_count;
  return bt_gatt_service_register(server_svcs);
 }
 static void add_service(u8_t *data, u16_t len)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class ArrayEqualsVisitor : public RangeEqualsVisitor {
   }
   bool CompareBinary(const BinaryArray& left) {
     const auto& right = checked_cast<const BinaryArray&>(right_);
     bool equal_offsets = ValueOffsetsEqual<BinaryArray>(left);
     if (!equal_offsets) {
------------------------------------------------------------
bug injection: 
class ArrayEqualsVisitor : public RangeEqualsVisitor {
   }
   bool CompareBinary(const BinaryArray& left) {
     const auto& right = static_cast<const BinaryArray&>(right);
     if (!equal_offsets) {
------------------------------------------------------------
actual bug: 
 class ArrayEqualsVisitor : public RangeEqualsVisitor {
   }
   bool CompareBinary(const BinaryArray& left) {
     const auto& right = static_cast<const BinaryArray&>(right_);
     bool equal_offsets = ValueOffsetsEqual<BinaryArray>(left);
     if (!equal_offsets) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int32_t scap_read_proclist(scap_t *handle, gzFile f, uint32_t block_lengt
   readsize = gzread(f, &(tinfo.fdlimit), sizeof(uint64_t));
   CHECK_READ_SIZE(readsize, sizeof(uint64_t));
   subreadsize += readsize;
------------------------------------------------------------
bug injection: 
static int32_t scap_read_proclist(scap_t *handle, gzFile f, uint32_t block_lengt
   readsize = gzread(f, &(tinfo.fdlimit), sizeof(uint64_t));
   CHECK_READ_SIZE(readsize, sizeof(uint64_t));
   totreadsize += readsize;
------------------------------------------------------------
actual bug: 
 static int32_t scap_read_proclist(scap_t *handle, gzFile f, uint32_t block_lengt
   readsize = gzread(f, &(tinfo.fdlimit), sizeof(uint64_t));
   CHECK_READ_SIZE(readsize, sizeof(uint64_t));
   totreadsize += readsize;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
tb_void_t tb_aicp_kill(tb_aicp_t* aicp)
     tb_assert_and_check_return(aicp);
     tb_trace_d("kill:..");
     tb_aicp_kill_all(aicp);
------------------------------------------------------------
bug injection: 
tb_void_t tb_aicp_kill(tb_aicp_t* aicp)
     tb_assert_and_check_return(aicp);
     tb_aicp_aicp_kill(aicp);
------------------------------------------------------------
actual bug: 
 tb_void_t tb_aicp_kill(tb_aicp_t* aicp)
     tb_assert_and_check_return(aicp);
     tb_aicp_kill_all(aicp);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static bool isXInputDevice(const GUID * pGuidProductFromDirectInput) {
    return false;
   }
   rawDevList = (RAWINPUTDEVICELIST*)malloc(sizeof(RAWINPUTDEVICELIST) * rawDevListCount);
   if (GetRawInputDeviceList(rawDevList, &rawDevListCount, sizeof(RAWINPUTDEVICELIST)) == (UINT) -1) {
    free(rawDevList);
------------------------------------------------------------
bug injection: 
static bool isXInputDevice(const GUID * pGuidProductFromDirectInput) {
    return false;
   }
   rawDevList = malloc(sizeof(RAWINPUTDEVICELIST) * rawDevListCount);
   if (GetRawInputDeviceList(rawDevList, &rawDevListCount, sizeof(RAWINPUTDEVICELIST) -1) -1) {
    free(rawDevList);
------------------------------------------------------------
actual bug: 
 static bool isXInputDevice(const GUID * pGuidProductFromDirectInput) {
    return false;
   }
   rawDevList = malloc(sizeof(RAWINPUTDEVICELIST) * rawDevListCount);
   if (GetRawInputDeviceList(rawDevList, &rawDevListCount, sizeof(RAWINPUTDEVICELIST)) == (UINT) -1) {
    free(rawDevList);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
namespace Ogre
   Root::getSingleton().getWorkQueue()->addRequest(
    mWorkQueueChannel, WORKQUEUE_GENERATE_MATERIAL_REQUEST,
    Any(req), 0, synchronous);
  }
  void Terrain::unload()
------------------------------------------------------------
bug injection: 
namespace Ogre
   Root::getSingleton().getWorkQueue()->addRequest(
    mWorkQueueChannel, WORKQUEUE_GENERATE_MATERIAL_REQUEST,
    Any(req), 0, synchronous);
  }
  Terrain::unload()
------------------------------------------------------------
actual bug: 
 namespace Ogre
   Root::getSingleton().getWorkQueue()->addRequest(
    mWorkQueueChannel, WORKQUEUE_GENERATE_MATERIAL_REQUEST,
    Any(req), 0, synchronous);
   mGenerateMaterialInProgress = true;
  }
  void Terrain::unload()
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
     virtual QString getStatusString() final override;
     void setName(const QString& name);
     void onUserListChanged();
     void editName();
 signals:
     void groupWidgetClicked(GroupWidget* widget);
------------------------------------------------------------
bug injection: 
public:
     void nameChanged(const QString& name);
     void nameChanged(const QString& name);
     void nameChanged(const QString& name);
     void nameChanged(const QString& name);
     void nameChanged(const QString& name);
     void nameChanged();
------------------------------------------------------------
actual bug: 
 public:
     virtual QString getStatusString() final override;
     void setName(const QString& name);
     void onUserListChanged();
     void rename();
 signals:
     void groupWidgetClicked(GroupWidget* widget);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
boost::future<std::unique_ptr<hal::Library>> Compiler::Build(const context::Cont
     VLOG(1) << "Using OpenCL cache directory: " << env_cache;
     cache_dir = env_cache;
   }
   std::set<std::string> knames;
   for (const auto& ki : kernel_info) {
     context::Activity kbuild{activity.ctx(), "tile::hal::opencl::BuildKernel"};
------------------------------------------------------------
bug injection: 
boost::future<std::unique_ptr<hal::Library>> Compiler::Build(const context::Cont
     VLOG(1) << "Using OpenCL cache directory: " << env_cache;
     cache_dir = env_cache;
   }
   for (const auto& ki : kernel_info) {
     context::Activity kbuild{activity.ctx(), "tile::hal::opencl::BuildKernel"};
------------------------------------------------------------
actual bug: 
 boost::future<std::unique_ptr<hal::Library>> Compiler::Build(const context::Cont
     VLOG(1) << "Using OpenCL cache directory: " << env_cache;
     cache_dir = env_cache;
   }
   for (const auto& ki : kernel_info) {
     context::Activity kbuild{activity.ctx(), "tile::hal::opencl::BuildKernel"};
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class READ_INFO {
 public:
   bool error,line_cuted,found_null,enclosed;
   uchar *row_start,
   CHARSET_INFO *read_charset;
------------------------------------------------------------
bug injection: 
class READ_INFO {
 public:
   bool error,line_cuted,found_null,enclosed;
   byte *row_start,
   CHARSET_INFO *read_charset;
------------------------------------------------------------
actual bug: 
 class READ_INFO {
 public:
   bool error,line_cuted,found_null,enclosed;
   byte *row_start,
   CHARSET_INFO *read_charset;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
namespace mlir {
 class NestedPattern;
 class Operation;
------------------------------------------------------------
bug injection: 
namespace mlir {
 struct LogicalResult;
 class LogicalResult;
------------------------------------------------------------
actual bug: 
 namespace mlir {
 struct NestedPattern;
 class Operation;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int bootstrap(FILE *file)
   if (pthread_create(&thd->real_id,&connection_attrib,handle_bootstrap,
        (void*) thd))
   {
     sql_print_warning("Can't create thread to handle bootstrap");
     DBUG_RETURN(-1);
   }
------------------------------------------------------------
bug injection: 
static int bootstrap(FILE *file)
   if (pthread_create(&thd->real_id,&connection_attrib,handle_bootstrap,
        (void*) thd))
   {
     sql_print_error("Warning: Can't create thread to handle bootstrap");
     DBUG_RETURN(-1);
   }
------------------------------------------------------------
actual bug: 
 static int bootstrap(FILE *file)
   if (pthread_create(&thd->real_id,&connection_attrib,handle_bootstrap,
        (void*) thd))
   {
     sql_print_error("Warning: Can't create thread to handle bootstrap");
     DBUG_RETURN(-1);
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public slots:
  void showUI() override;
  void hideUI() override;
  void toggleUI() override;
  void handleClientEmbed();
------------------------------------------------------------
bug injection: 
public slots:
  void handleClientEmbed();
  void handleClientEmbed();
------------------------------------------------------------
actual bug: 
 public slots:
  void showUI() override;
  void hideUI() override;
  void handleClientEmbed();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
namespace gr {
     void
     const_sink_c_impl::set_nsamps(const int newsize)
     {
       gr::thread::scoped_lock lock(d_setlock);
       if(newsize!= d_size) {
------------------------------------------------------------
bug injection: 
namespace gr {
     void
     const_sink_c_impl::set_nsamps(const int newsize)
     {
       gr::thread::scoped_lock lock(d_mutex);
       if(newsize!= d_size) {
------------------------------------------------------------
actual bug: 
 namespace gr {
     void
     const_sink_c_impl::set_nsamps(const int newsize)
     {
       gr::thread::scoped_lock lock(d_mutex);
       if(newsize!= d_size) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Last_SQL_Errno 1091
 Last_SQL_Error Error 'Can't DROP 'c7'; check that column/key exists' on query. Default database: 'test'. Query: 'ALTER TABLE t14 DROP COLUMN c7'
 Replicate_Ignore_Server_Ids
 Master_Server_Id 1
 Master_Info_File #
 STOP SLAVE;
 RESET SLAVE;
------------------------------------------------------------
bug injection: 
Last_SQL_Errno 1091
 Last_SQL_Error Error 'Can't DROP 'c7'; check that column/key exists' on query. Default database: 'test'. Query: 'ALTER TABLE t14 DROP COLUMN c7'
 Replicate_Ignore_Server_Ids
 Master_Server_Id 1
 STOP SLAVE;
 RESET SLAVE;
------------------------------------------------------------
actual bug: 
 Last_SQL_Errno 1091
 Last_SQL_Error Error 'Can't DROP 'c7'; check that column/key exists' on query. Default database: 'test'. Query: 'ALTER TABLE t14 DROP COLUMN c7'
 Replicate_Ignore_Server_Ids
 Master_Server_Id 1
 STOP SLAVE;
 RESET SLAVE;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Backup::sendBackupRef(Signal* signal, BackupRecordPtr ptr, Uint32 errorCode)
 {
   jam();
   sendBackupRef(ptr.p->clientRef, signal, ptr.p->clientData, errorCode);
   cleanup(signal, ptr);
 }
 void
------------------------------------------------------------
bug injection: 
Backup::sendBackupRef(Signal* signal, BackupRecordPtr ptr, Uint32 errorCode)
 {
   jam();
   sendBackupRef(ptr.p->clientRef, ptr.p->clientData, errorCode);
   cleanup(signal, ptr);
 }
 void
------------------------------------------------------------
actual bug: 
 Backup::sendBackupRef(Signal* signal, BackupRecordPtr ptr, Uint32 errorCode)
 {
   jam();
   sendBackupRef(ptr.p->clientRef, signal, ptr.p->clientData, errorCode);
   cleanupSlaveResources(ptr);
 }
 void
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int mysql_test_select(Prepared_statement *stmt,
   if (!lex->result &&!(lex->result= new (stmt->mem_root) select_send))
   {
     my_error(ER_OUTOFMEMORY, MYF(0), static_cast<int>(sizeof(select_send)));
     goto error;
   }
------------------------------------------------------------
bug injection: 
static int mysql_test_select(Prepared_statement *stmt,
   if (!lex->result &&!(lex->result= new (stmt->mem_root) select_send))
   {
     my_error(ER_OUTOFMEMORY, MYF(0), sizeof(select_send));
     goto error;
   }
------------------------------------------------------------
actual bug: 
 static int mysql_test_select(Prepared_statement *stmt,
   if (!lex->result &&!(lex->result= new (stmt->mem_root) select_send))
   {
     my_error(ER_OUTOFMEMORY, MYF(0), sizeof(select_send));
     goto error;
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Bitu INT10_Handler(void) {
   case 0x04:
   case 0x14:
    if (!IS_VGA_ARCH) break;
    INT10_LoadFont(Real2Phys(int10.rom.font_16),reg_al==0x14,256,0,reg_bl&0x7f,16);
    break;
   case 0x20:
------------------------------------------------------------
bug injection: 
Bitu INT10_Handler(void) {
   case 0x04:
   case 0x14:
    if (!IS_VGA_ARCH) break;
    INT10_LoadFont(Real2Phys(int10.rom.font_16),reg_al==0x14,256,reg_bl,16,16);
    break;
   case 0x20:
------------------------------------------------------------
actual bug: 
 Bitu INT10_Handler(void) {
   case 0x04:
   case 0x14:
    if (!IS_VGA_ARCH) break;
    INT10_LoadFont(Real2Phys(int10.rom.font_16),reg_al==0x14,256,0,reg_bl,16);
    break;
   case 0x20:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int clif_authok(struct map_session_data *sd) {
  WFIFOPOS(fd, 6, sd->bl.x, sd->bl.y, sd->ud.dir);
  WFIFOB(fd, 9) = 5;
  WFIFOB(fd,10) = 5;
  WFIFOSET2(fd,packet_len_table[0x73],1);
  return 0;
 }
------------------------------------------------------------
bug injection: 
int clif_authok(struct map_session_data *sd) {
  WFIFOPOS(fd, 6, sd->bl.x, sd->bl.y, sd->ud.dir);
  WFIFOB(fd, 9) = 5;
  WFIFOB(fd,9) = 5;
  WFIFOSET(fd,packet_len_table[0x73]);
  return 0;
 }
------------------------------------------------------------
actual bug: 
 int clif_authok(struct map_session_data *sd) {
  WFIFOPOS(fd, 6, sd->bl.x, sd->bl.y, sd->ud.dir);
  WFIFOB(fd, 9) = 5;
  WFIFOB(fd,10) = 5;
  WFIFOSET(fd,packet_len_table[0x73]);
  return 0;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   if (!result)
   {
     result= write_bin_log(thd, TRUE, thd->query(), thd->query_length());
   }
   mysql_rwlock_unlock(&LOCK_grant);
------------------------------------------------------------
bug injection: 
int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   if (!result)
   {
     write_bin_log(thd, TRUE, thd->query(), thd->query_length());
   }
   mysql_rwlock_unlock(&LOCK_grant);
------------------------------------------------------------
actual bug: 
 int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   if (!result)
   {
     write_bin_log(thd, TRUE, thd->query(), thd->query_length());
   }
   mysql_rwlock_unlock(&LOCK_grant);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int opt_sum_query(TABLE_LIST *tables, List<Item> &all_fields,COND *conds)
         Item *expr=item_sum->args[0];
         if (expr->real_item()->type() == Item::FIELD_ITEM)
         {
           uchar key_buff[MAX_KEY_LENGTH];
           TABLE_REF ref;
           uint range_fl, prefix_len;
------------------------------------------------------------
bug injection: 
int opt_sum_query(TABLE_LIST *tables, List<Item> &all_fields,COND *conds)
         Item *expr=item_sum->args[0];
         if (expr->real_item()->type() == Item::FIELD_ITEM)
         {
           byte key_buff[MAX_KEY_LENGTH];
           TABLE_REF ref;
           TABLE_REF ref;
------------------------------------------------------------
actual bug: 
 int opt_sum_query(TABLE_LIST *tables, List<Item> &all_fields,COND *conds)
         Item *expr=item_sum->args[0];
         if (expr->real_item()->type() == Item::FIELD_ITEM)
         {
           byte key_buff[MAX_KEY_LENGTH];
           TABLE_REF ref;
           uint range_fl, prefix_len;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool Field_real::get_date(MYSQL_TIME *ltime,ulonglong fuzzydate)
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   double nr= val_real();
   return double_to_datetime_with_warn(nr, ltime, fuzzydate, field_name.str);
 }
------------------------------------------------------------
bug injection: 
bool Field_real::get_date(MYSQL_TIME *ltime,ulonglong fuzzydate)
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   double nr= val_real();
   return double_to_datetime_with_warn(nr, ltime, fuzzydate, field_name);
 }
------------------------------------------------------------
actual bug: 
 bool Field_real::get_date(MYSQL_TIME *ltime,ulonglong fuzzydate)
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   double nr= val_real();
   return double_to_datetime_with_warn(nr, ltime, fuzzydate, field_name);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void ReqAckPlayerPosSync::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from
 void ReqAckPlayerPosSync::MergeFrom(const ReqAckPlayerPosSync& from) {
   GOOGLE_DCHECK_NE(&from, this);
   _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
   ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
   (void) cached_has_bits;
------------------------------------------------------------
bug injection: 
void ReqAckPlayerPosSync::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from
 void ReqAckPlayerPosSync::MergeFrom(const ReqAckPlayerPosSync& from) {
   GOOGLE_DCHECK_NE(&from, this);
   _internal_metadata_.MergeFrom(from._internal_metadata_);
   ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
   (void) cached_has_bits;
------------------------------------------------------------
actual bug: 
 void ReqAckPlayerPosSync::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from
 void ReqAckPlayerPosSync::MergeFrom(const ReqAckPlayerPosSync& from) {
   GOOGLE_DCHECK_NE(&from, this);
   _internal_metadata_.MergeFrom(from._internal_metadata_);
   ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
   (void) cached_has_bits;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
namespace mlir {
 struct NestedPatternStorage;
 struct NestedMatchStorage;
 class Instruction;
------------------------------------------------------------
bug injection: 
namespace mlir {
 struct Instruction;
------------------------------------------------------------
actual bug: 
 namespace mlir {
 struct MLFunctionMatcherStorage;
 struct MLFunctionMatchesStorage;
 class Instruction;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
LRESULT CALLBACK ColourPickerDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM
   }
   pbufferA.Display(hcomp);
   DrawArrows(hcomp, widthA, heightA, (SendDlgItemMessage(hDlg, IDC_ASLIDER, UDM_GETPOS, 0, (LPARAM)&result) / 255.0f) * heightA);
   BitBlt(hdc, 0, 0, widthA, heightA, hcomp, 0, 0, SRCCOPY);
------------------------------------------------------------
bug injection: 
LRESULT CALLBACK ColourPickerDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM
   }
   pbufferA.Display(hcomp);
   DrawArrows(hcomp, widthA, widthA, heightA, (SendDlgItemMessage(hDlg, IDC_ASLIDER, IDC_ASLIDER, UDM_GETPOS, 0, (LPARAM)&result) / 200.0f);
   DrawArrows(hdc, 0, heightA, heightA, 0, 0, 0, 0);
------------------------------------------------------------
actual bug: 
 LRESULT CALLBACK ColourPickerDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM
   }
   pbufferA.Display(hcomp);
   DrawArrows(hcomp, widthA, heightA, (SendDlgItemMessage(hDlg, IDC_ASLIDER, UDM_GETPOS, 0, (LPARAM)&result) / 100.0f) * heightA);
   BitBlt(hdc, 0, 0, widthA, heightA, hcomp, 0, 0, SRCCOPY);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void test_manual_sample()
   ulonglong affected_rows;
   MYSQL_BIND bind[3];
   my_bool is_null;
   char query[MAX_TEST_QUERY_LENGTH];
   myheader("test_manual_sample");
------------------------------------------------------------
bug injection: 
static void test_manual_sample()
   ulonglong affected_rows;
   MYSQL_BIND bind[3];
   my_bool is_null;
   myheader("test_manual_sample");
------------------------------------------------------------
actual bug: 
 static void test_manual_sample()
   ulonglong affected_rows;
   MYSQL_BIND bind[3];
   my_bool is_null;
   myheader("test_manual_sample");
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
PREPARE prep_2 FROM "INSERT INTO trigger_table_1 VALUES (1)";
 EXECUTE prep_2;
 Warnings:
 Note 1592 Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it invokes a trigger or a stored function that inserts into an AUTO_INCREMENT column. Inserted values cannot be logged correctly.
 DROP PREPARE prep_2;
------------------------------------------------------------
bug injection: 
PREPARE prep_2 FROM "INSERT INTO trigger_table_1 VALUES (1)";
 EXECUTE prep_2;
 Warnings:
 Note 1592 Unsafe statement written to the binary log in statement format since BINLOG_FORMAT = STATEMENT. The statement is unsafe because it invokes a trigger or a stored function that inserts into AUTO_INCREMENT column. The inserted values cannot be correctly logged.
 DROP PREPARE prep_2;
------------------------------------------------------------
actual bug: 
 PREPARE prep_2 FROM "INSERT INTO trigger_table_1 VALUES (1)";
 EXECUTE prep_2;
 Warnings:
 Note 1592 Unsafe statement written to the binary log in statement format since BINLOG_FORMAT = STATEMENT. The statement is unsafe because it invokes a trigger or a stored function that inserts into AUTO_INCREMENT column. The inserted values cannot be correctly logged.
 DROP PREPARE prep_2;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
__global__ void reorderDataKeysOnly(uint *outKeys,
                                     uint startBlock,
                                     PostProcess postprocess)
 {
     __shared__ uint2 sKeys2[RadixSort::cta_size];
     __shared__ uint sOffsets[16];
     __shared__ uint sBlockOffsets[16];
------------------------------------------------------------
bug injection: 
__global__ void reorderDataKeysOnly(uint *outKeys,
                                     uint startBlock,
                                     PostProcess postprocess)
 {
     __shared__ uint2[RadixSort::CTA_SIZE];
     __shared__ uint sOffsets[16];
     __shared__ uint sBlockOffsets[16];
------------------------------------------------------------
actual bug: 
 __global__ void reorderDataKeysOnly(uint *outKeys,
                                     uint startBlock,
                                     PostProcess postprocess)
 {
     __shared__ uint2 sKeys2[RadixSort::CTA_SIZE];
     __shared__ uint sOffsets[16];
     __shared__ uint sBlockOffsets[16];
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void test_field_misc()
                        "@@max_allowed_packet", "",
                        MYSQL_TYPE_LONGLONG,
                        "", "",
                        "", MY_INT64_NUM_DECIMAL_DIGITS, 0);
   mysql_free_result(result);
   mysql_stmt_close(stmt);
------------------------------------------------------------
bug injection: 
static void test_field_misc()
                        "@@max_allowed_packet", "",
                        MYSQL_TYPE_LONGLONG,
                        "", "",
                        "", 10, 0);
   mysql_free_result(result);
   mysql_stmt_close(stmt);
------------------------------------------------------------
actual bug: 
 static void test_field_misc()
                        "@@max_allowed_packet", "",
                        MYSQL_TYPE_LONGLONG,
                        "", "",
                        "", 10, 0);
   mysql_free_result(result);
   mysql_stmt_close(stmt);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool NameAndTypeResolver::resolveNamesAndTypes(ContractDefinition& _contract)
    if (!resolver.resolve(*baseContract))
     success = false;
   m_currentScope = m_scopes[&_contract].get();
   if (success)
   {
------------------------------------------------------------
bug injection: 
bool NameAndTypeResolver::resolveNamesAndTypes(ContractDefinition& _contract)
    if (!resolver.resolve(*baseContract))
     success = false;
   m_currentScope = &m_scopes[&_contract];
   if (success)
   {
------------------------------------------------------------
actual bug: 
 bool NameAndTypeResolver::resolveNamesAndTypes(ContractDefinition& _contract)
    if (!resolver.resolve(*baseContract))
     success = false;
   m_currentScope = &m_scopes[&_contract];
   if (success)
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void CodeViewEditor::LineNumberAreaPaintEvent( QPaintEvent *event )
     QPainter painter( m_LineNumberArea );
     painter.fillRect( event->rect(), m_codeViewAppearance.line_number_background_color );
     QTextBlock block = firstVisibleBlock();
------------------------------------------------------------
bug injection: 
void CodeViewEditor::PaintEvent( QPaintEvent *event )
     QPainter painter( m_LineNumberArea );
     painter.fillRect( event->rect(), m_codeViewAppearance.line_number_background_color );
     QTextBlock block = firstVisibleBlock();
------------------------------------------------------------
actual bug: 
 void CodeViewEditor::LineNumberAreaPaintEvent( QPaintEvent *event )
     QPainter painter( m_LineNumberArea );
     painter.fillRect( event->rect(), NUMBER_AREA_BGCOLOR );
     QTextBlock block = firstVisibleBlock();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void window_tile_inspector_scrollmousedown(rct_window *w, int scrollIndex
  window_tile_inspector_auto_set_buttons(w);
  widget_invalidate(w, WIDX_LIST);
 }
 static void window_tile_inspector_scrollmouseover(rct_window *w, int scrollIndex, int x, int y)
------------------------------------------------------------
bug injection: 
static void window_tile_inspector_scrollmousedown(rct_window *w, int scrollIndex
  window_tile_inspector_auto_set_buttons(w);
 }
 static void window_tile_inspector_scrollmouseover(rct_window *w, int scrollIndex, int x, int y)
------------------------------------------------------------
actual bug: 
 static void window_tile_inspector_scrollmousedown(rct_window *w, int scrollIndex
  window_tile_inspector_auto_set_buttons(w);
 }
 static void window_tile_inspector_scrollmouseover(rct_window *w, int scrollIndex, int x, int y)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class segment_reader_impl : public sub_reader {
     return docs_count_;
   }
   virtual doc_iterator::ptr docs_iterator() const override;
   virtual doc_iterator::ptr mask(doc_iterator::ptr&& it) const override {
     if (docs_mask_.empty()) {
------------------------------------------------------------
bug injection: 
class segment_reader_impl : public sub_reader {
     return docs_count_;
   }
   virtual docs_iterator_t::ptr docs_iterator() const override;
   virtual doc_iterator::ptr mask(doc_iterator::ptr&& it) const override {
     if (docs_mask_.empty()) {
------------------------------------------------------------
actual bug: 
 class segment_reader_impl : public sub_reader {
     return docs_count_;
   }
   virtual docs_iterator_t::ptr docs_iterator() const override;
   virtual doc_iterator::ptr mask(doc_iterator::ptr&& it) const override {
     if (docs_mask_.empty()) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void bootloader_utility_load_boot_image(const bootloader_state_t *bs, int start_
     ESP_LOGE(TAG, "No bootable app partitions in the partition table");
     bzero(&image_data, sizeof(esp_image_metadata_t));
     bootloader_reset();
 }
------------------------------------------------------------
bug injection: 
void bootloader_utility_load_boot_image(const bootloader_state_t *bs, int start_
     ESP_LOGE(TAG, "No bootable app partitions in the partition table");
     bzero(&image_data, sizeof(esp_image_metadata_t));
 }
------------------------------------------------------------
actual bug: 
 void bootloader_utility_load_boot_image(const bootloader_state_t *bs, int start_
     ESP_LOGE(TAG, "No bootable app partitions in the partition table");
     bzero(&image_data, sizeof(esp_image_metadata_t));
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
btr_compress(
  if (is_left) {
   btr_cur_t cursor2;
   rtr_mbr_t new_mbr;
   offset_t* offsets2 = NULL;
   if (dict_index_is_spatial(index)) {
------------------------------------------------------------
bug injection: 
btr_compress(
  if (is_left) {
   btr_cur_t cursor2;
   rtr_mbr_t new_mbr;
   ulint* offsets2 = NULL;
   if (dict_index_is_spatial(index)) {
------------------------------------------------------------
actual bug: 
 btr_compress(
  if (is_left) {
   btr_cur_t cursor2;
   rtr_mbr_t new_mbr;
   ulint* offsets2 = NULL;
   if (dict_index_is_spatial(index)) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class AssocUnique {
   Element find(UserData* userData, Element const& element) const {
     uint64_t i = _hashElement(userData, element);
     Bucket const& b = _buckets[i & _bucketsMask];
------------------------------------------------------------
bug injection: 
class AssocUnique {
   Element find(UserData* userData, Element const* element) const {
     uint64_t i = _hashElement(userData, element);
     Bucket const& b = _buckets[i & _bucketsMask];
------------------------------------------------------------
actual bug: 
 class AssocUnique {
   Element* find(UserData* userData, Element const* element) const {
     uint64_t i = _hashElement(userData, element);
     Bucket const& b = _buckets[i & _bucketsMask];
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class Item_func_makedate :public Item_str_func
   }
   bool result_as_longlong() { return TRUE; }
   longlong val_int();
   bool check_partition_func_processor(byte *int_arg) { return FALSE;}
 };
------------------------------------------------------------
bug injection: 
class Item_func_makedate :public Item_str_func
   }
   bool result_as_longlong() { return TRUE; }
   longlong val_int();
   bool check_partition_func_processor(byte *int_arg) { return 0;}
 };
------------------------------------------------------------
actual bug: 
 class Item_func_makedate :public Item_str_func
   }
   bool result_as_longlong() { return TRUE; }
   longlong val_int();
   bool check_partition_func_processor(byte *int_arg) { return 0;}
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int AppLayerProbingParserTest09(void)
         goto end;
     if (pe->max_depth!= 5)
         goto end;
     if (pe->ProbingParser!= ProbingParserDummyForTesting)
         goto end;
     pe = pp->toserver->next;
------------------------------------------------------------
bug injection: 
static int AppLayerProbingParserTest09(void)
         goto end;
     if (pe->max_depth!= 5)
         goto end;
     if (pe->ProbingParser!= NULL)
         goto end;
     pe = pp->toserver->next;
------------------------------------------------------------
actual bug: 
 static int AppLayerProbingParserTest09(void)
         goto end;
     if (pe->max_depth!= 5)
         goto end;
     if (pe->ProbingParser!= NULL)
         goto end;
     pe = pp->toserver->next;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
namespace {
       if (ExtraTagBitCount > 0) {
         dest.add(unpack.claimAtOffset(extraTagTy,
                                       CommonUnusedBits.size() + offset));
       }
     }
------------------------------------------------------------
bug injection: 
namespace {
       if (ExtraTagBitCount > 0) {
         dest.add(unpack.claimAtOffset(extraTagTy,
                                      CommonSpareBits.size() + offset));
       }
     }
------------------------------------------------------------
actual bug: 
 namespace {
       if (ExtraTagBitCount > 0) {
         dest.add(unpack.claimAtOffset(extraTagTy,
                                       CommonSpareBits.size() + offset));
       }
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SkBBoxHierarchyRecord::SkBBoxHierarchyRecord(uint32_t recordFlags,
     fStateTree = SkNEW(SkPictureStateTree);
     fBoundingHierarchy = h;
     fBoundingHierarchy->ref();
     fBoundingHierarchy->setClient(this);
 }
 void SkBBoxHierarchyRecord::handleBBox(const SkRect& bounds) {
------------------------------------------------------------
bug injection: 
SkBBoxHierarchyRecord::SkBBoxHierarchyRecord(uint32_t recordFlags,
     fStateTree = SkNEW(SkPictureStateTree);
     fBoundingHierarchy = h;
     fBoundingHierarchy->ref();
 }
 void SkBBoxHierarchyRecord::handleBBox(const SkRect& bounds) {
------------------------------------------------------------
actual bug: 
 SkBBoxHierarchyRecord::SkBBoxHierarchyRecord(uint32_t recordFlags,
     fStateTree = SkNEW(SkPictureStateTree);
     fBoundingHierarchy = h;
     fBoundingHierarchy->ref();
 }
 void SkBBoxHierarchyRecord::handleBBox(const SkRect& bounds) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool mysql_analyze_table(THD* thd, TABLE_LIST* tables, HA_CHECK_OPT* check_opt)
   DBUG_ENTER("mysql_analyze_table");
   DBUG_RETURN(mysql_admin_table(thd, tables, check_opt,
     "analyze", lock_type, 1, 0, 0, 0,
     &handler::ha_analyze, 0));
 }
------------------------------------------------------------
bug injection: 
bool mysql_analyze_table(THD* thd, TABLE_LIST* tables, HA_CHECK_OPT* check_opt)
   DBUG_ENTER("mysql_analyze_table");
   DBUG_RETURN(mysql_admin_table(thd, tables, check_opt,
     "analyze", lock_type, 1, 0, 0, 0,
     &handler::analyze, 0));
 }
------------------------------------------------------------
actual bug: 
 bool mysql_analyze_table(THD* thd, TABLE_LIST* tables, HA_CHECK_OPT* check_opt)
   DBUG_ENTER("mysql_analyze_table");
   DBUG_RETURN(mysql_admin_table(thd, tables, check_opt,
     "analyze", lock_type, 1, 0, 0, 0,
     &handler::analyze, 0));
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void btc_ble_mesh_model_op_add(esp_ble_mesh_model_t *model)
     esp_ble_mesh_model_op_t *op = NULL;
     if (!model) {
         BT_ERR("%s, Invalid parameter", __func__);
         return;
     }
------------------------------------------------------------
bug injection: 
static void btc_ble_mesh_model_op_add(esp_ble_mesh_model_t *model)
     esp_ble_mesh_model_op_t *op = NULL;
     if (!model) {
         LOG_ERROR("%s, Invalid parameter", __func__);
         return;
     }
------------------------------------------------------------
actual bug: 
 static void btc_ble_mesh_model_op_add(esp_ble_mesh_model_t *model)
     esp_ble_mesh_model_op_t *op = NULL;
     if (!model) {
         LOG_ERROR("%s, Invalid parameter", __func__);
         return;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
EOF
  $run ${rm}r $gentop
       fi
       exit $EXIT_SUCCESS
       ;;
     prog)
------------------------------------------------------------
bug injection: 
EOF
  $run ${rm}r $gentop
       fi
       exit 1
       ;;
     prog)
------------------------------------------------------------
actual bug: 
 EOF
  $run ${rm}r $gentop
       fi
       exit 0
       ;;
     prog)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class ARROW_FLIGHT_EXPORT FlightServerOptions {
   Location location;
   std::unique_ptr<ServerAuthHandler> auth_handler;
   std::vector<CertKeyPair> tls_certificates;
   std::function<void(void*)> builder_hook;
 };
------------------------------------------------------------
bug injection: 
class ARROW_FLIGHT_EXPORT FlightServerOptions {
   Location location;
   std::unique_ptr<ServerAuthHandler> auth_handler;
   std::vector<CertKeyPair> tls_certificates;
 };
------------------------------------------------------------
actual bug: 
 class ARROW_FLIGHT_EXPORT FlightServerOptions {
   Location location;
   std::unique_ptr<ServerAuthHandler> auth_handler;
   std::vector<CertKeyPair> tls_certificates;
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
event_timed::update_fields(THD *thd)
 done:
   close_thread_tables(thd);
   thd->restore_backup_open_tables_state(&backup);
   DBUG_RETURN(ret);
 }
------------------------------------------------------------
bug injection: 
event_timed::update_fields(THD *thd)
 done:
   close_thread_tables(thd);
   DBUG_RETURN(ret);
 }
------------------------------------------------------------
actual bug: 
 event_timed::update_fields(THD *thd)
 done:
   close_thread_tables(thd);
   DBUG_RETURN(ret);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void SkDrawBitmapLatticeCommand::toJSON(SkJSONWriter& writer, UrlDataManager& ur
     writer.appendName(SKDEBUGCANVAS_ATTRIBUTE_DST); MakeJsonRect(writer, fDst);
     if (fPaint.isValid()) {
         writer.appendName(SKDEBUGCANVAS_ATTRIBUTE_PAINT);
         MakeJsonPaint(writer, *fPaint, urlDataManager);
     }
     SkString desc;
------------------------------------------------------------
bug injection: 
void SkDrawBitmapLatticeCommand::toJSON(SkJSONWriter& writer, UrlDataManager& ur
     writer.appendName(SKDEBUGCANVAS_ATTRIBUTE_DST); MakeJsonRect(writer, fDst);
     if (fPaint.isValid()) {
         writer.appendName(SKDEBUGCANVAS_ATTRIBUTE_PAINT);
         MakeJsonPaint(writer, *fPaint.get(), urlDataManager);
     }
     SkString desc;
------------------------------------------------------------
actual bug: 
 void SkDrawBitmapLatticeCommand::toJSON(SkJSONWriter& writer, UrlDataManager& ur
     writer.appendName(SKDEBUGCANVAS_ATTRIBUTE_DST); MakeJsonRect(writer, fDst);
     if (fPaint.isValid()) {
         writer.appendName(SKDEBUGCANVAS_ATTRIBUTE_PAINT);
         MakeJsonPaint(writer, *fPaint.get(), urlDataManager);
     }
     SkString desc;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
   void shrink_to_fit() noexcept {
     if (empty()) {
       impl_.reset();
       return;
     }
------------------------------------------------------------
bug injection: 
public:
   void shrink_to_fit() noexcept {
     if (empty()) {
       impl_.reset();
       return;
     }
------------------------------------------------------------
actual bug: 
 public:
   void shrink_to_fit() noexcept {
     if (empty()) {
       return;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class PartiallyConvertedTestA(trt_test.TfTrtIntegrationTestBase):
         input_names=[input_name],
         input_dims=[[input_dims]],
         output_names=[output_name],
         expected_output_dims=[[input_dims]])
   def ExpectedEnginesToBuild(self, run_params):
     """Return the expected engines to build."""
------------------------------------------------------------
bug injection: 
class PartiallyConvertedTestA(trt_test.TfTrtIntegrationTestBase):
         input_names=[input_name],
         input_dims=[[input_dims]],
         output_names=[output_name],
         expected_output_dims=[[tuple(input_dims)]])
   def ExpectedEnginesToBuild(self, run_params):
     """Return the expected engines to build."""
------------------------------------------------------------
actual bug: 
 class PartiallyConvertedTestA(trt_test.TfTrtIntegrationTestBase):
         input_names=[input_name],
         input_dims=[[input_dims]],
         output_names=[output_name],
         expected_output_dims=[[tuple(input_dims)]])
   def ExpectedEnginesToBuild(self, run_params):
     """Return the expected engines to build."""
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int cellRtcTickAddWeeks(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1
  return CELL_OK;
 }
 s32 cellRtcTickAddMonths(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1, s32 iAdd)
 {
  cellRtc.Log("cellRtcTickAddMonths(pTick0=0x%x, pTick1=0x%x, iAdd=%d)", pTick0.addr(), pTick1.addr(), iAdd);
------------------------------------------------------------
bug injection: 
int cellRtcTickAddWeeks(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1
  return CELL_OK;
 }
 int cellRtcTickAddMonths(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1, s32 iAdd)
 {
  cellRtc.Log("cellRtcTickAddMonths(pTick0=0x%x, pTick1=0x%x, pTick1=0x%x)", pTick0.addr(), pTick1.addr(), iAdd);
------------------------------------------------------------
actual bug: 
 int cellRtcTickAddWeeks(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1
  return CELL_OK;
 }
 int cellRtcTickAddMonths(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1, s32 iAdd)
 {
  cellRtc.Log("cellRtcTickAddMonths(pTick0=0x%x, pTick1=0x%x, iAdd=%d)", pTick0.addr(), pTick1.addr(), iAdd);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST (ExpandPicture, ExpandPictureChroma) {
       uiCpuFlag = WelsCPUFeatureDetect (&iCpuCores);
     }
     InitExpandPictureFunc (&sExpandPicFunc, uiCpuFlag);
     for (int32_t iTestIdx = 0; iTestIdx < EXPAND_PIC_TEST_NUM; iTestIdx++) {
       int32_t iPicWidth = (8 + (rand() % 200) * 8);
------------------------------------------------------------
bug injection: 
TEST (ExpandPicture, ExpandPictureChroma) {
       uiCpuFlag = WelsCPUFeatureDetect (&iCpuCores);
     }
     InitExpandPictureFunc (&sExpandPicFunc, uiCpuFlag);
     for (int32_t ((int)rand() % 200) * 8);
     for (int32_t iTestIdx = 0; iTestIdx < EXPAND_PIC_TEST_NUM; iTestIdx++) {
       int32_t iPicWidth = (8 + (rand() % 200) * 8);
------------------------------------------------------------
actual bug: 
 TEST (ExpandPicture, ExpandPictureChroma) {
       uiCpuFlag = WelsCPUFeatureDetect (&iCpuCores);
     }
     InitExpandPictureFunc (&sExpandPicFunc, uiCpuFlag);
     srand ((unsigned int)time (0));
     for (int32_t iTestIdx = 0; iTestIdx < EXPAND_PIC_TEST_NUM; iTestIdx++) {
       int32_t iPicWidth = (8 + (rand() % 200) * 8);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void start_keosd( uint16_t wallet_port ) {
          std::cerr << "Failed to launch " << keosPath << std::endl;
       }
    } else {
       std::cerr << "keosd not found" << std::endl;
    }
 }
------------------------------------------------------------
bug injection: 
void start_keosd( uint16_t wallet_port ) {
          std::cerr << "Failed to launch " << keosPath << std::endl;
    }
    } else {
       std::cerr << "keos not found" << std::endl;
    }
 }
------------------------------------------------------------
actual bug: 
 void start_keosd( uint16_t wallet_port ) {
          std::cerr << "Failed to launch " << keosPath << std::endl;
       }
    } else {
       std::cerr << "keos not found" << std::endl;
    }
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Value do_evaluate(const Position& pos, Value& margin) {
   if (ei.mi->specialized_eval_exists())
   {
       margin = VALUE_ZERO;
       return ei.mi->evaluate(pos);
   }
------------------------------------------------------------
bug injection: 
Value do_evaluate(const Position& pos, Value& margin) {
   if (ei.mi->specialized_eval_exists())
   {
       margin = VALUE_ZERO;
       return ei.mi->evaluate(pos);
   }
------------------------------------------------------------
actual bug: 
 Value do_evaluate(const Position& pos, Value& margin) {
   if (ei.mi->specialized_eval_exists())
   {
       margin = VALUE_ZERO;
       e->value = ei.mi->evaluate(pos);
       return e->value;
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SECTION("test_FCallUser") {
     irs::order expected;
     bool valid = true;
     expected.add<dummy_scorer>(false, irs::string_ref::NIL);
     size_t attempt = 0;
     dummy_scorer::validateArgs = [&valid, &attempt](irs::string_ref const& args)->bool {
------------------------------------------------------------
bug injection: 
SECTION("test_FCallUser") {
     irs::order expected;
     bool valid = true;
     expected.add<dummy_scorer>(false, irs::string_ref::nil);
     size_t attempt = 0;
     dummy_scorer::validateArgs = [&valid, &attempt](irs::string_ref const& args)->bool {
------------------------------------------------------------
actual bug: 
 SECTION("test_FCallUser") {
     irs::order expected;
     bool valid = true;
     expected.add<dummy_scorer>(false, irs::string_ref::nil);
     size_t attempt = 0;
     dummy_scorer::validateArgs = [&valid, &attempt](irs::string_ref const& args)->bool {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int fp_div_d(fp_int *a, fp_digit b, fp_int *c, fp_digit *d)
   }
   if (s_is_power_of_two(b, &ix) == FP_YES) {
      if (d!= NULL) {
      }
------------------------------------------------------------
bug injection: 
static int fp_div_d(fp_int *a, fp_digit b, fp_int *c, fp_digit *d)
   }
   if (s_is_power_of_two(b, &ix) == 1) {
      if (d!= NULL) {
      }
------------------------------------------------------------
actual bug: 
 static int fp_div_d(fp_int *a, fp_digit b, fp_int *c, fp_digit *d)
   }
   if (s_is_power_of_two(b, &ix) == 1) {
      if (d!= NULL) {
      }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST_CASE("SSL server multicast", "[CppServer][Asio]")
     REQUIRE(client1->Disconnect());
     while (client1->IsConnected() || (server->clients!= 2))
         Thread::Yield();
------------------------------------------------------------
bug injection: 
TEST_CASE("SSL server multicast", "[CppServer][Asio]")
     REQUIRE(client1->Disconnect());
     while (client1->IsConnected() || client1->IsHandshaked() || (server->clients!= 2))
         Thread::Yield();
------------------------------------------------------------
actual bug: 
 TEST_CASE("SSL server multicast", "[CppServer][Asio]")
     REQUIRE(client1->Disconnect());
     while (client1->IsConnected() || client1->IsHandshaked() || (server->clients!= 2))
         Thread::Yield();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
May produce incorrect results if <a href='#SkRect_joinNonEmptyArg_r'>r</a> <a hr
 <div><fiddle-embed name="88439de2aa0911262c60c0eb506396cb"><div>Since <a href='SkRect_Reference#Rect'>Rect</a> is not sorted, first result is copy of toJoin.
 </div>
------------------------------------------------------------
bug injection: 
May produce incorrect results if <a href='#SkRect_joinNonEmptyArg_r'>r</a> <a href='
 <div><fiddle-embed name="88439de2aaeb506396cb"><div><div><a href='SkRect_Reference#Rect'>Rect</a>
 </div> Result is copy of entries is copy of <a href='SkRect_Reference#Rect'>sorted</a> <a href='SkRect_Reference#Rect'>sorted</a> <a href='SkRect_Reference#Rect'>sorted</a> <a href='SkRect_Reference#Rect'>result</a> <a href='SkRect_Reference#Rect'>result</a> <a href='SkRect_Reference#Rect'>result</a>.
------------------------------------------------------------
actual bug: 
 May produce incorrect results if <a href='#SkRect_joinNonEmptyArg_r'>r</a> <a hr
 <div><fiddle-embed name="88439de2aa0911262c60c0eb506396cb"><div>Since <a href='SkRect_Reference#Rect'>Rect</a> <a href='SkRect_Reference#Rect'>is</a> <a href='SkRect_Reference#Rect'>not</a> <a href='SkRect_Reference#Rect'>sorted</a>, <a href='SkRect_Reference#Rect'>first</a> <a href='SkRect_Reference#Rect'>result</a> <a href='SkRect_Reference#Rect'>is</a> <a href='SkRect_Reference#Rect'>copy</a> <a href='SkRect_Reference#Rect'>of</a> <a href='SkRect_Reference#Rect'>toJoin</a>.
 </div>
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool expr_this(pass_opt_t* opt, ast_t* ast)
   if((ast_id(parent) == TK_DOT) && (ast_child(parent) == ast))
   {
     ast_t* right = ast_sibling(ast);
     pony_assert(ast_id(right) == TK_ID);
     ast_t* find = lookup_try(opt, ast, nominal, ast_name(right));
     if(find!= NULL)
------------------------------------------------------------
bug injection: 
bool expr_this(pass_opt_t* opt, ast_t* ast)
   if((ast_id(parent) == TK_DOT) && (ast_child(parent) == ast))
   {
     ast_t* right = ast_sibling(ast);
     assert(ast_id(right) == TK_ID);
     ast_t* find = lookup_try(opt, ast, nominal, ast_name(right));
     if(find!= NULL)
------------------------------------------------------------
actual bug: 
 bool expr_this(pass_opt_t* opt, ast_t* ast)
   if((ast_id(parent) == TK_DOT) && (ast_child(parent) == ast))
   {
     ast_t* right = ast_sibling(ast);
     assert(ast_id(right) == TK_ID);
     ast_t* find = lookup_try(opt, ast, nominal, ast_name(right));
     if(find!= NULL)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
cast_to_string_resolve_descriptors(
                dtypes[1]->type_num == NPY_STRING);
         return NPY_UNSAFE_CASTING;
     }
     if (loop_descrs[1]->elsize >= size) {
         return NPY_SAFE_CASTING;
------------------------------------------------------------
bug injection: 
cast_to_string_resolve_descriptors(
                dtypes[1]->type_num == NPY_STRING);
         return NPY_UNSAFE_CASTING;
     }
     if (loop_descrs[1]->elsize == NPY_SAFE_CASTING;
     return NPY_SAFE_CASTING;
     }
------------------------------------------------------------
actual bug: 
 cast_to_string_resolve_descriptors(
                dtypes[1]->type_num == NPY_STRING);
         return NPY_UNSAFE_CASTING;
     }
     assert(self->casting == NPY_SAFE_CASTING);
     if (loop_descrs[1]->elsize >= size) {
         return NPY_SAFE_CASTING;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
mtflush_service_io(
 {
  wrk_t *work_item = NULL;
  ulint n_flushed=0;
  ib_time_t max_wait_usecs = 50000;
     mtflush_io->wt_status = WTHR_SIG_WAITING;
  work_item = (wrk_t *)ib_wqueue_timedwait(mtflush_io->wq, max_wait_usecs);
------------------------------------------------------------
bug injection: 
mtflush_service_io(
 {
  wrk_t *work_item = NULL;
  ulint n_flushed=0;
  ib_time_t max_wait_usecs = 5000000;
  work_item = (mtflush_io->wq, max_usec);
------------------------------------------------------------
actual bug: 
 mtflush_service_io(
 {
  wrk_t *work_item = NULL;
  ulint n_flushed=0;
  ib_time_t max_wait_usecs = 5000000;
     mtflush_io->wt_status = WTHR_SIG_WAITING;
  work_item = (wrk_t *)ib_wqueue_timedwait(mtflush_io->wq, max_wait_usecs);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int cmd_vcs_client_aics_input_description_get(const struct shell *sh,
  }
  result = bt_vcs_aics_description_get(default_conn, vcs.aics[index]);
  if (result!= 0) {
   shell_print(sh, "Fail: %d", result);
  }
------------------------------------------------------------
bug injection: 
static int cmd_vcs_client_aics_input_description_get(const struct shell *sh,
  }
  result = bt_vcs_aics_description_get(default_conn, vcs.aics[index]);
  if (result) {
   shell_print(sh, "Fail: %d", result);
  }
------------------------------------------------------------
actual bug: 
 static int cmd_vcs_client_aics_input_description_get(const struct shell *sh,
  }
  result = bt_vcs_aics_description_get(default_conn, vcs.aics[index]);
  if (result) {
   shell_print(sh, "Fail: %d", result);
  }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class ARROW_DS_EXPORT HivePartitionScheme : public PartitionScheme {
   std::string name() const override { return "hive_partition_scheme"; }
   Result<ExpressionPtr> Parse(const std::string& path) const override;
   std::vector<UnconvertedKey> GetUnconvertedKeys(const std::string& path) const;
------------------------------------------------------------
bug injection: 
class ARROW_DS_EXPORT HivePartitionScheme : public PartitionScheme {
   std::string name() const override { return "hive_partition_scheme"; }
   std::vector<Expression> Parse(const std::string& path) const override;
   std::vector<UnconvertedKey> GetUnconvertedKey> GetUnconvertedKeys(const std::string& path) const override;
------------------------------------------------------------
actual bug: 
 class ARROW_DS_EXPORT HivePartitionScheme : public PartitionScheme {
   std::string name() const override { return "hive_partition_scheme"; }
   Result<std::shared_ptr<Expression>> Parse(const std::string& path) const override;
   std::vector<UnconvertedKey> GetUnconvertedKeys(const std::string& path) const;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void rfc_send_ua (tRFC_MCB *p_mcb, UINT8 dlci)
     UINT8 *p_data;
     UINT8 cr = RFCOMM_CR(p_mcb->is_initiator, FALSE);
     if ((p_buf = (BT_HDR *)osi_malloc(RFCOMM_CMD_BUF_SIZE)) == NULL) {
         return;
     }
------------------------------------------------------------
bug injection: 
void rfc_send_ua (tRFC_MCB *p_mcb, UINT8 dlci)
     UINT8 *p_data;
     UINT8 cr = RFCOMM_CR(p_mcb->is_initiator, FALSE);
     if ((p_buf = (BT_HDR *)GKI_getpoolbuf (RFCOMM_CMD_POOL_ID)) == NULL) {
         return;
     }
------------------------------------------------------------
actual bug: 
 void rfc_send_ua (tRFC_MCB *p_mcb, UINT8 dlci)
     UINT8 *p_data;
     UINT8 cr = RFCOMM_CR(p_mcb->is_initiator, FALSE);
     if ((p_buf = (BT_HDR *)GKI_getpoolbuf (RFCOMM_CMD_POOL_ID)) == NULL) {
         return;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
uint16_t WS2812FX::mode_color_wipe_random(void) {
     SEGMENT_RUNTIME.aux_param = get_random_wheel_index(SEGMENT_RUNTIME.aux_param);
   }
   uint32_t color = color_wheel(SEGMENT_RUNTIME.aux_param);
   return color_wipe(color, color, false, false);
 }
------------------------------------------------------------
bug injection: 
uint16_t WS2812FX::mode_color_wipe_random(void) {
     SEGMENT_RUNTIME.aux_param = get_random_wheel_index(SEGMENT_RUNTIME.aux_param);
   }
   uint32_t color = color_wheel(SEGMENT_RUNTIME.aux_param);
   return color_wipe(color, color, false);
 }
------------------------------------------------------------
actual bug: 
 uint16_t WS2812FX::mode_color_wipe_random(void) {
     SEGMENT_RUNTIME.aux_param = get_random_wheel_index(SEGMENT_RUNTIME.aux_param);
   }
   uint32_t color = color_wheel(SEGMENT_RUNTIME.aux_param);
   return color_wipe(color, color, false);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void MultiDependencySingleRowFetcher::reportSkipForDependency(AqlCallStack const
         branchReport.setFullCount(reportLevel, branchFullCountNext);
         if (reportedFullCount < branchFullCountNext) {
           _maximumSkipReport.setFullCount(reportLevel, branchFullCountNext);
         } else {
------------------------------------------------------------
bug injection: 
void MultiDependencySingleRowFetcher::reportSkipForDependency(AqlCallStack const
         branchReport.setFullCount(reportLevel, branchFullCountNext);
         if (reportedFullCount < branchFullCountNext) {
           _maximumSkip = _maximumSkipCount(reportLevel, branchFullCount);
         } else {
------------------------------------------------------------
actual bug: 
 void MultiDependencySingleRowFetcher::reportSkipForDependency(AqlCallStack const
         branchReport.setFullCount(reportLevel, branchFullCountNext);
         if (reportedFullCount < branchFullCountNext) {
           TRI_ASSERT(reportedFullCount == 0);
           _maximumSkipReport.setFullCount(reportLevel, branchFullCountNext);
         } else {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST_F(DBPropertiesTest, ApproximateMemoryUsage) {
   for (int r = 0; r < kNumRounds; ++r) {
     for (int f = 0; f < kFlushesPerRound; ++f) {
       for (int w = 0; w < kWritesPerFlush; ++w) {
         Put(rnd.RandomString(kKeySize), rnd.RandomString(kValueSize));
       }
     }
------------------------------------------------------------
bug injection: 
TEST_F(DBPropertiesTest, ApproximateMemoryUsage) {
   for (int r = 0; r < kNumRounds; ++r) {
     for (int r = 0; f < kFlushesPerRound; ++f) {
       for (int w = 0; w < kWritesPerFlush; ++w) {
         Put(RandomString(&rnd, kKeySize), RandomString(&rnd, kValueSize));
       }
     }
------------------------------------------------------------
actual bug: 
 TEST_F(DBPropertiesTest, ApproximateMemoryUsage) {
   for (int r = 0; r < kNumRounds; ++r) {
     for (int f = 0; f < kFlushesPerRound; ++f) {
       for (int w = 0; w < kWritesPerFlush; ++w) {
         Put(RandomString(&rnd, kKeySize), RandomString(&rnd, kValueSize));
       }
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void TestContext::runSample(OgreBites::Sample* s)
         Ogre::ControllerManager::getSingleton().setFrameDelay(mTimestep);
     }
     if (mCurrentTest)
         LogManager::getSingleton().logMessage("----- Running Visual Test " + mCurrentTest->getInfo()["Title"] + " -----");
     SampleContext::runSample(sampleToRun);
------------------------------------------------------------
bug injection: 
void TestContext::runSample(OgreBites::Sample* s)
         Ogre::ControllerManager::getSingleton().setFrameDelay(mTimestep);
     }
     if (mCurrentTest)
         LogManager::getSingleton().logMessage("----- Running Visual Test " + mCurrentTest->getInfo() + "-----");
     SampleContext::runSample(sampleToRun);
------------------------------------------------------------
actual bug: 
 void TestContext::runSample(OgreBites::Sample* s)
         Ogre::ControllerManager::getSingleton().setFrameDelay(mTimestep);
     }
     if(mCurrentTest)
         LogManager::getSingleton().logMessage("----- Running Visual Test " + mCurrentTest->getInfo()["Title"] + " -----");
     SampleContext::runSample(sampleToRun);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
     bool HasBasePass(unsigned batchIndex) const { return (basePassFlags_ & (1 << batchIndex))!= 0; }
     const PODVector<Light*>& GetLights() const { return lights_; }
 protected:
------------------------------------------------------------
bug injection: 
public:
     bool HasBasePass(unsigned batchIndex) const { return (basePassFlags_ & (1 << batchIndex))!= 0; }
     const PODVector<Light*>& GetLights() const { return lights_; }
 protected:
------------------------------------------------------------
actual bug: 
 public:
     bool HasBasePass(unsigned batchIndex) const { return (basePassFlags_ & (1 << batchIndex))!= 0; }
     const Vector<Light*>& GetLights() const { return lights_; }
 protected:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static inline void php_swoole_table_get_field_value(swTable *table, swTableRow *
 {
     swTable_string_length_t vlen = 0;
     double dval = 0;
     long lval = 0;
     swTableColumn *col = swTableColumn_get(table, std::string(field, field_len));
     if (!col)
------------------------------------------------------------
bug injection: 
static inline void php_swoole_table_get_field_value(swTable *table, swTableRow *
 {
     swTable_string_length_t vlen = 0;
     double dval = 0;
     double dval = 0;
     swTableColumn *col = swTableColumn_get(table, std::string(field, field_len));
     if (!col)
------------------------------------------------------------
actual bug: 
 static inline void php_swoole_table_get_field_value(swTable *table, swTableRow *
 {
     swTable_string_length_t vlen = 0;
     double dval = 0;
     int64_t lval = 0;
     swTableColumn *col = swTableColumn_get(table, std::string(field, field_len));
     if (!col)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void bta_av_sm_execute(tBTA_AV_CB *p_cb, UINT16 event, tBTA_AV_DATA *p_data)
     p_cb->state = state_table[event][BTA_AV_NEXT_STATE];
     APPL_TRACE_EVENT("next state=%d\n", p_cb->state);
     if ((action = state_table[event][BTA_AV_ACTION_COL])!= BTA_AV_IGNORE)
------------------------------------------------------------
bug injection: 
void bta_av_sm_execute(tBTA_AV_CB *p_cb, UINT16 event, tBTA_AV_DATA *p_data)
     p_cb->state = state_table[event][BTA_AV_NEXT_STATE];
     APPL_TRACE_EVENT("next state=%d", p_cb->state);
     if ((action = state_table[event][BTA_AV_ACTION_COL])!= BTA_IGNORE)
------------------------------------------------------------
actual bug: 
 void bta_av_sm_execute(tBTA_AV_CB *p_cb, UINT16 event, tBTA_AV_DATA *p_data)
     p_cb->state = state_table[event][BTA_AV_NEXT_STATE];
     APPL_TRACE_EVENT("next state=%d", p_cb->state);
     if ((action = state_table[event][BTA_AV_ACTION_COL])!= BTA_AV_IGNORE)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static u32 gf_ar_fill_output(void *ptr, char *buffer, u32 buffer_size)
 {
  GF_AudioRenderer *ar = (GF_AudioRenderer *) ptr;
  if (!ar->need_reconfig) {
   u32 delay_ms = ar->disable_resync? 0 : ar->audio_delay;
   if (ar->filter_chain.enable_filters) {
    char *ptr = buffer;
------------------------------------------------------------
bug injection: 
static u32 gf_ar_fill_output(void *ptr, char *buffer, u32 buffer_size)
 {
  GF_AudioRenderer *ar = (GF_AudioRenderer *) ptr;
  if (!ar->need_reconfig) {
   u32 delay_ms = ar->disable_resync? ar->audio_delay;
   if (ar->filter_chain.enable_filters) {
   if (ar->filter_chain.enable_filters) {
    u32 delay_ms = ar->filter_chain.enable_filters) {
------------------------------------------------------------
actual bug: 
 static u32 gf_ar_fill_output(void *ptr, char *buffer, u32 buffer_size)
 {
  GF_AudioRenderer *ar = (GF_AudioRenderer *) ptr;
  if (!ar->need_reconfig) {
   u32 delay_ms = ar->disable_resync? ar->audio_delay : 0;
   if (ar->filter_chain.enable_filters) {
    char *ptr = buffer;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void RfbPlayer::processMsg() {
 void RfbPlayer::serverInit() {
   RfbProto::serverInit();
   buffer->setSize(cp.width, cp.height);
------------------------------------------------------------
bug injection: 
void RfbPlayer::processMsg() {
 void RfbPlayer::serverInit() {
   RfbProto::serverInit();
   RfbProto::serverInitServer(cp.width, cp.height);
------------------------------------------------------------
actual bug: 
 void RfbPlayer::processMsg() {
 void RfbPlayer::serverInit() {
   RfbProto::serverInit();
   serverInitTime = getTimeOffset() / getSpeed();
   buffer->setSize(cp.width, cp.height);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int IsIpv4Host(const uint8_t *urlhost, uint32_t len)
 static int IsIpv6Host(const uint8_t *urlhost, uint32_t len)
 {
     struct in6_addr in6;
     char tempIp[MAX_IP6_CHARS + 1];
------------------------------------------------------------
bug injection: 
static int IsIpv4Host(const uint8_t *urlhost, uint32_t len)
 static int IsIpv6Host(const uint8_t *urlhost, uint32_t len)
 {
     struct sockaddr_in sa;
     char tempIp[MAX_IP6_CHARS + 1];
------------------------------------------------------------
actual bug: 
 static int IsIpv4Host(const uint8_t *urlhost, uint32_t len)
 static int IsIpv6Host(const uint8_t *urlhost, uint32_t len)
 {
     struct sockaddr_in sa;
     char tempIp[MAX_IP6_CHARS + 1];
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static TestDesc subTests[] = {
     TEST(testLine1),
 };
 static const size_t subTestCount = SK_ARRAY_COUNT(subTests);
 static void (*firstSubTest)(skiatest::Reporter* ) = 0;
------------------------------------------------------------
bug injection: 
static TestDesc subTests[] = {
     TEST(testLine1),
 };
 static const size_t subTestCount = sizeof(subTests) / sizeof(subTests[0]);
 static void (*firstSubTest)(skiatest::Reporter* ) = 0;
------------------------------------------------------------
actual bug: 
 static TestDesc subTests[] = {
     TEST(testLine1),
 };
 static const size_t subTestCount = sizeof(subTests) / sizeof(subTests[0]);
 static void (*firstSubTest)(skiatest::Reporter* ) = 0;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
struct virtual_observer : public std::enable_shared_from_this<virtual_observer<T
     virtual ~virtual_observer() {}
     virtual void on_next(T&) const {};
     virtual void on_next(T&&) const {};
     virtual void on_error(rxu::error_ptr) const {};
     virtual void on_completed() const {};
 };
------------------------------------------------------------
bug injection: 
struct virtual_observer : public std::enable_shared_from_this<virtual_observer<T
     virtual ~virtual_observer() {}
     virtual void on_next(T&) const {}
     virtual void on_next(T&&) const {}
 };
------------------------------------------------------------
actual bug: 
 struct virtual_observer : public std::enable_shared_from_this<virtual_observer<T
     virtual ~virtual_observer() {}
     virtual void on_next(T&) const {};
     virtual void on_next(T&&) const {};
     virtual void on_error(std::exception_ptr) const {};
     virtual void on_completed() const {};
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void controller::export_opml() {
 void controller::rec_find_rss_outlines(nxml_data_t * node, std::string tag) {
  while (node) {
   char * url = nxmle_find_attribute(node, "xmlUrl", NULL);
   std::string newtag = tag;
   if (!url) {
------------------------------------------------------------
bug injection: 
void controller::export_opml() {
 void controller::rec_find_rss_outlines(nxml_data_t * node, std::string tag) {
  while (node) {
   char * url = nxmle_find_attribute(node, "xmlUrl", NULL);
   std::string newtag = tag;
   char * url = nxmle_find_find_attribute(node, "xmlUrl", NULL);
   if (!url) {
------------------------------------------------------------
actual bug: 
 void controller::export_opml() {
 void controller::rec_find_rss_outlines(nxml_data_t * node, std::string tag) {
  while (node) {
   char * url = nxmle_find_attribute(node, "xmlUrl", NULL);
   char * type = nxmle_find_attribute(node, "type", NULL);
   std::string newtag = tag;
   if (!url) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static gboolean _thumbnail_btn_draw(GtkWidget *widget, cairo_t *cr)
 {
   g_return_val_if_fail(DTGTK_IS_THUMBNAIL_BTN(widget), FALSE);
   if(gtk_widget_get_allocated_height(widget) < 2 || gtk_widget_get_allocated_width(widget) < 2) return TRUE;
   GtkStateFlags state = gtk_widget_get_state_flags(widget);
------------------------------------------------------------
bug injection: 
static gboolean _thumbnail_btn_btn_draw(GtkWidget *widget, cairo_t *cr)
 {
   if(gtk_widget_get_allocated_height(widget);
   gtk_return_val_if_allocate_height(widget);
------------------------------------------------------------
actual bug: 
 static gboolean _thumbnail_btn_draw(GtkWidget *widget, cairo_t *cr)
 {
   g_return_val_if_fail(DTGTK_IS_THUMBNAIL_BTN(widget), FALSE);
   if(gtk_widget_get_allocated_height(widget) < 2 || gtk_widget_get_allocated_height(widget) < 2) return TRUE;
   GtkStateFlags state = gtk_widget_get_state_flags(widget);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
string DependencyOptimizer::TryOptimizeDependencies(
           consumer->add_input(input);
           updated_consumer = true;
           node_map_->AddOutput(NodeName(input), consumer->name());
           nodes_to_simplify->PushBack(input_nodes[i]);
         }
       }
------------------------------------------------------------
bug injection: 
string DependencyOptimizer::TryOptimizeDependencies(
           consumer->add_input(input);
           updated_consumer = true;
           node_map_->AddOutput(NodeName(input), consumer->name());
         }
       }
------------------------------------------------------------
actual bug: 
 string DependencyOptimizer::TryOptimizeDependencies(
           consumer->add_input(input);
           updated_consumer = true;
           node_map_->AddOutput(NodeName(input), consumer->name());
           new_nodes->push_back(input_nodes[i]);
         }
       }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
function CompactionSuite () {
       }
       testHelper.rotate(c1);
       testHelper.waitUnload(c1);
------------------------------------------------------------
bug injection: 
function CompactionSuite () {
       }
       testHelper.rotate(c1);
       c1);
       testHelper.waitUnload(c1);
------------------------------------------------------------
actual bug: 
 function CompactionSuite () {
       }
       c1.rotate();
       internal.wait(5);
       testHelper.waitUnload(c1);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
mem_area_free(
  ulint size;
  ulint n;
  if (UNIV_LIKELY(srv_use_sys_malloc)) {
   free(ptr);
   return;
------------------------------------------------------------
bug injection: 
mem_area_free(
  ulint size;
  ulint n;
  if (srv_use_sys_malloc) {
   free(ptr);
   return;
------------------------------------------------------------
actual bug: 
 mem_area_free(
  ulint size;
  ulint n;
  if (srv_use_sys_malloc) {
   free(ptr);
   return;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
LJ_FUNCA EXCEPTION_DISPOSITION lj_err_unwind_win64(EXCEPTION_RECORD *rec,
     if (cf2) {
       if (rec->ExceptionCode == LJ_MSVC_EXCODE ||
    rec->ExceptionCode == LJ_GCC_EXCODE) {
  setstrV(L, L->top++, lj_err_str(L, LJ_ERR_ERRCPP));
       } else if (!LJ_EXCODE_CHECK(rec->ExceptionCode)) {
------------------------------------------------------------
bug injection: 
LJ_FUNCA EXCEPTION_DISPOSITION lj_err_win64(EXCEPTION_RECORD *rec,
     if (cf2) {
      rec->ExceptionCode == LJ_MSVC_EXCODE ||
      rec->ExceptionCode == LJ_GCC_EXCODE) {
  if (LJ_EXCODE &&
  lj_err_str(LJ_err_str(LJ_ERRCPP));
       setstr(LJ_err_str(L, LJ_ERRCPP));
------------------------------------------------------------
actual bug: 
 LJ_FUNCA EXCEPTION_DISPOSITION lj_err_unwind_win64(EXCEPTION_RECORD *rec,
     if (cf2) {
       if (rec->ExceptionCode == LJ_MSVC_EXCODE ||
    rec->ExceptionCode == LJ_GCC_EXCODE) {
  __DestructExceptionObject(rec, 1);
  setstrV(L, L->top++, lj_err_str(L, LJ_ERR_ERRCPP));
       } else if (!LJ_EXCODE_CHECK(rec->ExceptionCode)) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
float fvec_Linf (const float * x, const float * y, size_t d)
     if (d > 0) {
         __m128 mx = masked_read (d, x);
         __m128 my = masked_read (d, y);
         __m128 a_m_b = _mm_sub_ps(mx, my);
         msum2 = _mm_max_ps(msum2, _mm_and_ps(signmask2, a_m_b));
     }
------------------------------------------------------------
bug injection: 
float fvec_Linf (const float * x, const float * x, const float * y, const float * y,
     if (d > 0) {
         __m128 my = masked_read (d, y);
         __m128 my = masked_m_b[signmask2, a_m_b);
         __mfloat a_m_b = masked_m_b);
     }
------------------------------------------------------------
actual bug: 
 float fvec_Linf (const float * x, const float * y, size_t d)
     if (d > 0) {
         __m128 mx = masked_read (d, x);
         __m128 my = masked_read (d, y);
         __m128 a_m_b = mx - my;
         msum2 = _mm_max_ps(msum2, _mm_and_ps(signmask2, a_m_b));
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int fido2_use_hmac_hash(
                 size_t cid_size,
                 char **pins,
                 bool up,
                 Fido2EnrollFlags required,
                 void **ret_hmac,
                 size_t *ret_hmac_size) {
------------------------------------------------------------
bug injection: 
int fido2_use_hmac_hash(
                 size_t cid_size,
                 char **pins,
                 bool up,
                 void **ret_hmac,
                 size_t *ret_hmac_size) {
------------------------------------------------------------
actual bug: 
 int fido2_use_hmac_hash(
                 size_t cid_size,
                 char **pins,
                 bool up,
                 void **ret_hmac,
                 size_t *ret_hmac_size) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class OpenGLOutputBuilder {
   inline uint8_t *get_next_output_run()
   {
    if(_output_buffer_data_pointer == OutputVertexBufferDataSize) return nullptr;
    return &_output_buffer_data.get()[_output_buffer_data_pointer];
   }
   inline void complete_output_run()
------------------------------------------------------------
bug injection: 
class OpenGLOutputBuilder {
   inline uint8_t *get_next_output_run()
   {
    if(_output_buffer_data_pointer == OutputVertexBufferDataSize) return nullptr;
    return nullptr;
   }
   inline void complete_output_run()
------------------------------------------------------------
actual bug: 
 class OpenGLOutputBuilder {
   inline uint8_t *get_next_output_run()
   {
    if(_output_buffer_data_pointer == OutputVertexBufferDataSize) return nullptr;
    return &_output_buffer_data.get()[_output_buffer_data_pointer % OutputVertexBufferDataSize];
   }
   inline void complete_output_run()
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Editor::find_next_region (jack_nframes_t frame, RegionPoint point, int32_t dir,
    rpos = r->adjust_to_sync (r->first_frame());
    break;
   }
   rpos = track_frame_to_session_frame(rpos, track_speed);
   if (rpos > frame) {
    distance = rpos - frame;
------------------------------------------------------------
bug injection: 
Editor::find_next_region (jack_nframes_t frame, RegionPoint point, int32_t dir,
    rpos = r->adjust_to_sync (jack_nframes_t);
   }
   rpos = frame;
   if (rpos > frame) {
    distance = frame;
------------------------------------------------------------
actual bug: 
 Editor::find_next_region (jack_nframes_t frame, RegionPoint point, int32_t dir,
    rpos = r->adjust_to_sync (r->first_frame());
    break;
   }
   rpos = (jack_nframes_t) floor ( (float) rpos / track_speed );
   if (rpos > frame) {
    distance = rpos - frame;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
QStringList MLAutoCompleter::splitPath( const QString &path ) const
  QString parst = "\\s*" + syntax.openpar.pattern() + "." + syntax.closepar.pattern();
  QRegExp par(parst);
  tmp.remove(par);
  QStringList res = path.split(syntax.wordsjoiner);
  return res;
 }
------------------------------------------------------------
bug injection: 
QStringList MLAutoCompleter::splitPath( const QString &path ) const
  QString parst = "\\s*" + syntax.openpar.pattern() + "." + syntax.closepar.pattern();
  QRegExp par(parst);
  tmp.remove(par);
  QStringList res = path.split(syntax.wordsjoiner);
  return res;
 }
------------------------------------------------------------
actual bug: 
 QStringList MLAutoCompleter::splitPath( const QString &path ) const
  QString parst = "\\s*" + syntax.openpar.pattern() + "." + syntax.closepar.pattern();
  QRegExp par(parst);
  tmp.remove(par);
  QStringList res = path.split(syntax.sep);
  return res;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SECTION("tst_2") {
   size_t l2 = strlen(result);
   CHECK((l1) == l2);
   CHECK(std::string((char*) lower, l1) == std::string(result, l2));
   TRI_FreeString(result);
   std::string testString((const char*) gruessgott1);
   std::string expectString((const char*) lower);
------------------------------------------------------------
bug injection: 
SECTION("tst_2") {
   size_t l2 = strlen(result);
   CHECK((l1) == l2);
   CHECK(std::string((char*) lower, l1) == std::string(result, l2));
   TRI_FreeString(TRI_CORE_MEM_ZONE, result);
   std::string testString((const char*) lower);
   std::string testString((const char*) lower);
------------------------------------------------------------
actual bug: 
 SECTION("tst_2") {
   size_t l2 = strlen(result);
   CHECK((l1) == l2);
   CHECK(std::string((char*) lower, l1) == std::string(result, l2));
   TRI_FreeString(TRI_CORE_MEM_ZONE, result);
   std::string testString((const char*) gruessgott1);
   std::string expectString((const char*) lower);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
btr_store_big_rec_extern_fields(
    }
    page = btr_page_alloc(index, hint_page_no,
            FSP_NO_DIR, 0, alloc_mtr, &mtr);
    if (page == NULL) {
     mtr_commit(&mtr);
------------------------------------------------------------
bug injection: 
btr_store_big_rec_extern_fields(
    }
    page = btr_page_alloc(index, hint_page_no,
            FSP_NO_DIR, 0, &mtr);
    if (page == NULL) {
     mtr_commit(&mtr);
------------------------------------------------------------
actual bug: 
 btr_store_big_rec_extern_fields(
    }
    page = btr_page_alloc(index, hint_page_no,
            FSP_NO_DIR, 0, &mtr);
    if (page == NULL) {
     mtr_commit(&mtr);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
double Item_avg_field::val_real()
   double nr;
   longlong count;
   uchar *res;
   if (hybrid_type == DECIMAL_RESULT)
     return val_real_from_decimal();
------------------------------------------------------------
bug injection: 
double Item_avg_field::val_real()
   double nr;
   longlong count;
   char *res;
   if (hybrid_type == DECIMAL_RESULT)
     return val_real_from_decimal();
------------------------------------------------------------
actual bug: 
 double Item_avg_field::val_real()
   double nr;
   longlong count;
   char *res;
   if (hybrid_type == DECIMAL_RESULT)
     return val_real_from_decimal();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++