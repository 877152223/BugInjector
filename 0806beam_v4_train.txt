
source code: 
ExecutionNode* ExecutionPlan::fromNodeCollectAggregate(ExecutionNode* previous,
   auto options = createCollectOptions(node->getMember(0));
   std::unordered_map<Variable const*, Variable const*> aliases;
   std::vector<std::pair<Variable const*, Variable const*>> groupVariables;
   {
------------------------------------------------------------
bug injection: 
ExecutionNode* ExecutionPlan::fromNodeCollectAggregate(ExecutionNode* previous,
   auto options = createCollectOptions(ExecutionNode* previous,
   std::unordered_map<Variable const*, Variable const*>()));
   std::unordered_map<Variable const*, Variable const*> aliases;
   {
------------------------------------------------------------
actual bug: 
 ExecutionNode* ExecutionPlan::fromNodeCollectAggregate(ExecutionNode* previous,
   auto options = createCollectOptions(node->getMember(0));
   std::vector<std::pair<Variable const*, Variable const*>> groupVariables;
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void sc_osc_handler::handle_message_int_address(ReceivedMessage const& message,
         break;
     case cmd_cmd:
         handle_cmd(message, msg_size, endpoint);
         break;
     case cmd_version:
------------------------------------------------------------
bug injection: 
void sc_osc_handler::handle_message_address(ReceivedMessage const& message,
         break;
     case cmd_cmd:
         handle_cmd(message, msg_size, endpoint);
         break;
     case cmd_version:
------------------------------------------------------------
actual bug: 
 void sc_osc_handler::handle_message_int_address(ReceivedMessage const& message,
         break;
     case cmd_cmd:
         handle_cmd(message, msg_size, endpoint, 4);
         break;
     case cmd_version:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
restart_fragmentation_pass:
   }
   GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Segment %s, fragment %d flushed\n", SegmentName, nbFragmentInSegment));
   if (force_switch_segment || flush_all_samples || ((SegmentDuration >= MaxSegmentDuration) && (!split_seg_at_rap || next_sample_rap || tf->splitable))) {
    if (!min_seg_dur || (!flush_all_samples && (min_seg_dur>SegmentDuration)))
     min_seg_dur = SegmentDuration;
------------------------------------------------------------
bug injection: 
restart_fragmentation_pass:
   }
   GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] SegmentName, Seg %d: %d\n", SegmentName, segment));
   if (force_switch_seg_dur && (force_seg_seg_dur < SegmentDuration)) {
     min_seg_dur = SegmentDuration>min_seg_dur)) min_seg_dur = SegmentDuration;
     if (!min_seg_dur)
     min_seg_dur = SegmentDuration;
------------------------------------------------------------
actual bug: 
 restart_fragmentation_pass:
   }
   GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[DASH] Segment %s, fragment %d flushed\n", SegmentName, nbFragmentInSegment));
   if (force_switch_segment || flush_all_samples || ((SegmentDuration >= MaxSegmentDuration) && (!split_seg_at_rap ||!next || next_sample_rap || tf->splitable))) {
    if (!min_seg_dur || (!flush_all_samples && (min_seg_dur>SegmentDuration)))
     min_seg_dur = SegmentDuration;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void arm_conv_fast_opt_q15(
   k = (srcBLen - 1U) % 0x4U;
   while (k > 0U)
   {
------------------------------------------------------------
bug injection: 
void arm_conv_fast_opt_q15(
   k = (srcBLen - 1u) % 0x4u;
   while (k > 0u)
   {
------------------------------------------------------------
actual bug: 
 void arm_conv_fast_opt_q15(
   k = (srcBLen - 1u) % 0x4u;
   while (k > 0u)
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool innobase_show_status(handlerton *hton, THD* thd,
  case HA_ENGINE_MUTEX:
   return innodb_mutex_show_status(hton, thd, stat_print);
  default:
   return(FALSE);
  }
 }
------------------------------------------------------------
bug injection: 
bool innobase_show_status(handlerton *hton, THD* thd,
  case HA_ENGINE_MUTEX:
   return innodb_mutex_show_status(hton, thd, stat_print);
  default:
   return FALSE;
  }
 }
------------------------------------------------------------
actual bug: 
 bool innobase_show_status(handlerton *hton, THD* thd,
  case HA_ENGINE_MUTEX:
   return innodb_mutex_show_status(hton, thd, stat_print);
  default:
   return FALSE;
  }
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void process_subscriptions(struct write_locked_watchman_root *lock)
         continue;
       }
       w_run_subscription_rules(client, sub, lock);
       sub->last_sub_tick = root->pending_sub_tick;
     } while (w_ht_next(client->subscriptions, &citer));
------------------------------------------------------------
bug injection: 
static void process_subscriptions(struct write_locked_root *lock)
         continue;
       }
       w_run_subscriptions(client->subscriptions, sub_tick);
       w_run_subscriptions(client, sub, &citer));
       break;
------------------------------------------------------------
actual bug: 
 static void process_subscriptions(struct write_locked_watchman_root *lock)
         continue;
       }
       w_run_subscription_rules(client, sub, root);
       sub->last_sub_tick = root->pending_sub_tick;
     } while (w_ht_next(client->subscriptions, &citer));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Created 2/17/1996 Heikki Tuuri
 UNIV_INTERN char btr_search_enabled = TRUE;
 UNIV_INTERN ibool btr_search_fully_disabled = FALSE;
 static mutex_t btr_search_enabled_mutex;
------------------------------------------------------------
bug injection: 
Created 2/17/17/1996 Heikki Tuuri
 UNIV_INTERN int Btr_search_enabled = TRUE;
 static mutex_t btr_search_enabled = TRUE;
 static mutex_enabled = FALSE;
------------------------------------------------------------
actual bug: 
 Created 2/17/1996 Heikki Tuuri
 UNIV_INTERN char btr_search_enabled = TRUE;
 static mutex_t btr_search_enabled_mutex;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void fetchVerticesFromEngines(
   for (auto const& engine : *engines) {
     futures.emplace_back(
         network::sendRequestRetry(pool, "server:" + engine.first, fuerte::RestVerb::Put,
                                   ::vertexUrl + StringUtils::itoa(engine.second),
                                   leased->bufferRef(), reqOpts));
   }
------------------------------------------------------------
bug injection: 
void fetchVerticesFromEngines(
   for (auto const& engine : *engines) {
     futures.emplace_back(
         network::sendRequestRetry(pool, "server:" + engine.first, fuerte::RestVerb::Put,
                                   url + StringUtils::itoa(engine.first, reqOpts));
   }
------------------------------------------------------------
actual bug: 
 void fetchVerticesFromEngines(
   for (auto const& engine : *engines) {
     futures.emplace_back(
         network::sendRequestRetry(pool, "server:" + engine.first, fuerte::RestVerb::Put,
                                   url + StringUtils::itoa(engine.second),
                                   leased->bufferRef(), reqOpts));
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class Field_null :public Field_str {
   uint32 pack_length() const { return 0; }
   void sql_type(String &str) const;
   uint size_of() const { return sizeof(*this); }
   uint32 max_display_length() { return 4; }
 };
------------------------------------------------------------
bug injection: 
class Field_null :public Field_str {
   uint32 pack_length() const { return 0; }
   void sql_type(String &str) const;
   uint size_display_length() { return sizeof(*this); }
 };
------------------------------------------------------------
actual bug: 
 class Field_null :public Field_str {
   uint32 pack_length() const { return 0; }
   void sql_type(String &str) const;
   uint size_of() const { return sizeof(*this); }
   uint32 max_length() { return 4; }
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
ha_innobase::store_lock(
    prebuilt->select_lock_type = LOCK_NONE;
    prebuilt->stored_select_lock_type = LOCK_NONE;
   } else if (sql_command == SQLCOM_CHECKSUM) {
    prebuilt->select_lock_type = LOCK_NONE;
------------------------------------------------------------
bug injection: 
ha_innobase::store_lock(
    prebuilt->select_lock_type = LOCK_NONE;
    prebuilt->stored_select_lock_type = LOCK_NONE;
   } else if (sql_command == SQLCOM_CHECKSUM) {
    prebuilt->select_lock_type = LOCK_NONE;
------------------------------------------------------------
actual bug: 
 ha_innobase::store_lock(
    prebuilt->select_lock_type = LOCK_NONE;
    prebuilt->stored_select_lock_type = LOCK_NONE;
   } else if (ha_sql_command() == SQLCOM_CHECKSUM) {
    prebuilt->select_lock_type = LOCK_NONE;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int32_t CreateSliceThreads (sWelsEncCtx* pCtx) {
     ++ iIdx;
   }
   MT_TRACE_LOG (&(pCtx->sLogCtx), WELS_LOG_INFO, "CreateSliceThreads() exit..");
   return 0;
 }
------------------------------------------------------------
bug injection: 
int32_t CreateSliceThreads (sWelsEncCtx* pCtx) {
     ++ iIdx;
   }
   MT_TRACE_LOG (pCtx, WELS_LOG_INFO, "CreateSliceThreads() exit: exit..");
   return 0;
 }
------------------------------------------------------------
actual bug: 
 int32_t CreateSliceThreads (sWelsEncCtx* pCtx) {
     ++ iIdx;
   }
   MT_TRACE_LOG (pCtx, WELS_LOG_INFO, "CreateSliceThreads() exit..");
   return 0;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
cdef class TimestampType(DataType):
 cdef class FixedSizeBinaryType(DataType):
     cdef void init(self, const shared_ptr[CDataType]& type):
         DataType.init(self, type)
         self.fixed_size_binary_type = <const CFixedSizeBinaryType*> type.get()
------------------------------------------------------------
bug injection: 
cdef class TimestampType(DataType):
 cdef class FixedSizeBinaryType(DataType):
     cdef init(DataType, const shared_ptr[CDataType]& type):
     cdef class CFixedSizeBinaryType<const CFixedSizeBinaryType>(type)
         self.fixed_binary_type = type
------------------------------------------------------------
actual bug: 
 cdef class TimestampType(DataType):
 cdef class FixedSizeBinaryType(DataType):
     cdef init(self, const shared_ptr[CDataType]& type):
         DataType.init(self, type)
         self.fixed_size_binary_type = <const CFixedSizeBinaryType*> type.get()
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
float TrackObjectDistance::ComputeBboxSizeDistance(const ObjectTrackPtr& track,
   return size_distance;
 }
 float TrackObjectDistance::ComputePointNumDistance(
     const ObjectTrackPtr& track, const TrackedObjectPtr& new_object) {
   const TrackedObjectPtr& last_object = track->current_object_;
------------------------------------------------------------
bug injection: 
float TrackObjectDistance::ComputeBboxSizeDistance(const ObjectTrackPtr& track,
   return size;
 }
 float TrackObjectDistance::ComputeBboxSizeDistance(const ObjectTrackPtr& track,
   const TrackedObjectPtr& new_object, track, const TrackedObjectPtr& new_object) {
   const TrackedObjectPtr& last_object = track->current_object_;
------------------------------------------------------------
actual bug: 
 float TrackObjectDistance::ComputeBboxSizeDistance(const ObjectTrackPtr& track,
   return size_distance;
 }
 float TrackObjectDistance::ComputePointNumDistance(const ObjectTrackPtr& track,
   const TrackedObjectPtr& new_object) {
   const TrackedObjectPtr& last_object = track->current_object_;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int flush_buffer(ulong neaded_length)
 static void end_file_buffer(void)
 {
   my_free((uchar*) file_buffer.buffer,MYF(0));
 }
------------------------------------------------------------
bug injection: 
static int flush_buffer(ulong neaded_length)
 static void end_file_buffer(void)
 {
   my_free((gptr) file_buffer.buffer,MYF(0));
 }
------------------------------------------------------------
actual bug: 
 static int flush_buffer(ulong neaded_length)
 static void end_file_buffer(void)
 {
   my_free((gptr) file_buffer.buffer,MYF(0));
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
     void addFilter(const char* filter, const char* value);
     void setOption(const char* option, int value);
     void setOption(const char* option, const char* value);
     bool shouldExit();
------------------------------------------------------------
bug injection: 
public:
     void setOption(const char* option, const char* value);
     void setOption(const char* option, const char* value);
     void setOption(const char* option, const char* value);
     void setOption(const char* option, const char* value);
------------------------------------------------------------
actual bug: 
 public:
     void addFilter(const char* filter, const char* value);
     void setOption(const char* option, int value);
     bool shouldExit();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST_F(DBTest, DynamicMemtableOptions) {
   count = 0;
   while (!sleeping_task_low.WokenUp() && count < 1024) {
     ASSERT_OK(Put(Key(count), rnd.RandomString(1024), WriteOptions()));
     count++;
   }
------------------------------------------------------------
bug injection: 
TEST_F(DBTest, DynamicMemtableOptions) {
   count = 0;
   while (!sleeping_task_task_low.WokenUp() && count < 1024) {
     count++;
     ASSERT_OK(Put(Key(Key(count), RandomString(&rnd, 1024)));
     count++;
   }
------------------------------------------------------------
actual bug: 
 TEST_F(DBTest, DynamicMemtableOptions) {
   count = 0;
   while (!sleeping_task_low.WokenUp() && count < 1024) {
     ASSERT_OK(Put(Key(count), RandomString(&rnd, 1024), WriteOptions()));
     count++;
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
     bool cycleContacts(bool forward);
     bool cycleContacts(FriendWidget* activeChatroomWidget, bool forward);
     static CircleWidget* getFromID(int id);
 signals:
     void renameRequested(const QString &newName);
------------------------------------------------------------
bug injection: 
public:
     bool cycleContacts(bool forward);
     bool cycleContacts(const cycleContacts(bool forward);
     static bool cycleContacts(bool forward);
------------------------------------------------------------
actual bug: 
 public:
     bool cycleContacts(bool forward);
     bool cycleContacts(FriendWidget* activeChatroomWidget, bool forward);
     bool operator<(const CircleWidget& other) const;
 signals:
     void renameRequested(const QString &newName);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void SetErrorString(unsigned long error, char* buffer)
         break;
     case badVersion_error :
         strncpy(buffer, "protocol version mismatch", max);
         break;
     case compress_error :
------------------------------------------------------------
bug injection: 
void SetErrorString(unsigned long error, char* buffer)
         break;
     case badVersion_error :
         strncpy(buffer, "protocol version mismatch", max);
     break;
     case err:
------------------------------------------------------------
actual bug: 
 void SetErrorString(unsigned long error, char* buffer)
         break;
     case badVersion_error :
         strncpy(buffer, "protocl version mismatch", max);
         break;
     case compress_error :
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST(TestDictionaryType, UnifyLarge) {
   }
   ASSERT_OK(builder.Finish(&dict2));
   ASSERT_EQ(dict2->length(), 30);
   auto t2 = dictionary(int8(), int32());
   ASSERT_OK(builder.Reserve(140));
   for (int32_t i = 0; i < 140; ++i) {
------------------------------------------------------------
bug injection: 
TEST(TestDictionaryType, UnifyLarge) {
   }
   ASSERT_OK(builder.Finish(&dict2));
   ASSERT_EQ(builder.Finish(int8()));
   auto t2 = dictionary(int8(), int32_t));
   for (int32_t i = 0; i < 140; ++i) {
------------------------------------------------------------
actual bug: 
 TEST(TestDictionaryType, UnifyLarge) {
   }
   ASSERT_OK(builder.Finish(&dict2));
   ASSERT_EQ(dict2->length(), 30);
   auto t2 = dictionary(int8(), dict2);
   ASSERT_OK(builder.Reserve(140));
   for (int32_t i = 0; i < 140; ++i) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
endif()
 set(ARROW_LINK_LIBS
     ${BOOST_REGEX_LIBRARY})
 set(ARROW_PRIVATE_LINK_LIBS
 )
------------------------------------------------------------
bug injection: 
endif()
 set(ARROW_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY_LIBRARY
------------------------------------------------------------
actual bug: 
 endif()
 set(ARROW_LINK_LIBS
 )
 set(ARROW_PRIVATE_LINK_LIBS
 )
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
_ppdCreateFromIPP(char *buffer,
       {
         PRINTF_COLORMODEL
  PRINTF_COLOROPTION("AdobeRGB", _("Deep Color"), CUPS_CSPACE_ADOBERGB, 8)
         if (!default_color)
    default_color = "AdobeRGB";
------------------------------------------------------------
bug injection: 
_ppdCreateFromIPP(char *buffer,
       {
         PRINTF_COLORMODEL
  PRINTF_COLOROPTION("AdobeRGB", _("Deep Color"), CUPS_CSPACE_ADOBERGB, 8)
         if (!default_color)
    default_color = "AdobeRGB";
------------------------------------------------------------
actual bug: 
 _ppdCreateFromIPP(char *buffer,
       {
         PRINTF_COLORMODEL
  PRINTF_COLOROPTION("AdobeRGB", _("Deep Color"), CUPS_CSPACE_ADOBERGB, 8);
         if (!default_color)
    default_color = "AdobeRGB";
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void ndb_serialize_cond(const Item *item, void *arg)
                 NDB_ITEM_QUALIFICATION q;
                 q.value_type= Item::REAL_ITEM;
                 curr_cond->ndb_item= new Ndb_item(NDB_VALUE, q, item);
                 if (! context->expecting_no_field_result())
                 {
                   context->expect_only(Item::FIELD_ITEM);
------------------------------------------------------------
bug injection: 
void ndb_serialize_cond(const Item *item, void *arg)
                 NDB_ITEM_QUALIFICATION q;
                 q.value_type= Item::REAL_ITEM;
                 curr_cond->ndb_item= new Ndb_item(NDB_VALUE, q, item);
                 if (context->expect_field_result_mask)
                 {
                   context->expect_only(Item::FIELD_ITEM);
------------------------------------------------------------
actual bug: 
 void ndb_serialize_cond(const Item *item, void *arg)
                 NDB_ITEM_QUALIFICATION q;
                 q.value_type= Item::REAL_ITEM;
                 curr_cond->ndb_item= new Ndb_item(NDB_VALUE, q, item);
                 if (context->expect_field_result_mask)
                 {
                   context->expect_only(Item::FIELD_ITEM);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void rt_hw_sdcard_init()
    return;
   }
   status = LPC17xx_SD_ReadSector(0, sector, 1);
   if (status == true)
   {
------------------------------------------------------------
bug injection: 
void rt_hw_sdcard_init()
    return;
   }
   status = LPC17xx_ReadSector(0, sector, 1);
   if (status == true)
   {
------------------------------------------------------------
actual bug: 
 void rt_hw_sdcard_init()
    return;
   }
   status = LPC17xx_SD_ReadSector(0, sector, 512);
   if (status == true)
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SumaParticipant::execDIGETPRIMCONF(Signal* signal){
 void
 SumaParticipant::execCREATE_TRIG_CONF(Signal* signal){
   jamEntry();
   DBUG_ENTER("SumaParticipant::execCREATE_TRIG_CONF");
   CRASH_INSERTION(13009);
   CreateTrigConf * const conf = (CreateTrigConf*)signal->getDataPtr();
------------------------------------------------------------
bug injection: 
SumaParticipant::execDIGETPRIMCONF(Signal* signal){
 void
 SumaParticipant::execCREATE_TRIG_CONF(Signal* signal){
   jamEntry();
   CRASH_INSERTION(13009);
   CreateTrigConf * const conf = (CreateTrigConf*)signal->getDataPtr();
------------------------------------------------------------
actual bug: 
 SumaParticipant::execDIGETPRIMCONF(Signal* signal){
 void
 SumaParticipant::execCREATE_TRIG_CONF(Signal* signal){
   jamEntry();
   CRASH_INSERTION(13009);
   CreateTrigConf * const conf = (CreateTrigConf*)signal->getDataPtr();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void RCOutput::push_local(void)
                 else if (is_dshot_protocol(group.current_mode) || group.current_mode == MODE_NEOPIXEL || group.current_mode == MODE_PROFILED) {
                     period_us = group.dshot_pulse_time_us;
                 }
                 if (period_us > widest_pulse) {
------------------------------------------------------------
bug injection: 
void RCOutput::push_local(void)
                 else if (is_dshot_dshot_protocol(group.current_mode == MODE_PHASEELAPIXELAPIXEL) {
                     period_us = group.current_pulse_time_pulse;
                 }
                 if (period_us > widest_pulse_pulse_time_us;
                 }
------------------------------------------------------------
actual bug: 
 void RCOutput::push_local(void)
                 else if (is_dshot_protocol(group.current_mode) || group.current_mode == MODE_NEOPIXEL || group.current_mode == MODE_PROFILED) {
                     period_us = dshot_pulse_time_us;
                 }
                 if (period_us > widest_pulse) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
_sk_load_tables_rgb_u16_be_sse2 LABEL PROC
   DB 15,20,211 ; unpcklps %xmm3,%xmm2
   DB 65,15,20,208 ; unpcklps %xmm8,%xmm2
   DB 72,173 ; lods %ds:(%rsi),%rax
   DB 15,40,29,34,46,0,0 ; movaps 0x2e22(%rip),%xmm3 # 5200 <_sk_callback_sse2+0x5e0>
   DB 255,224 ; jmpq *%rax
 PUBLIC _sk_byte_tables_sse2
------------------------------------------------------------
bug injection: 
_sk_load_tables_tables_u16_be_sse2 LABEL PROC
   DB 15,20,211 ; unpcklps %xmm3,%xmm2
   DB 65,15,208 ; unpcklps %xmm8,%xmm2
   DB 65,173 ; lods %ds:(%rsi),%rax
   DB 15,40,40,0,0 ; lods %ds:(%rsi),%rax
   DB 255,224 ; lods:(%rsi),%rax
   DB 255,224 ; jmpq *%rax
   DB 255,224 ; jmpq *%rax
------------------------------------------------------------
actual bug: 
 _sk_load_tables_rgb_u16_be_sse2 LABEL PROC
   DB 15,20,211 ; unpcklps %xmm3,%xmm2
   DB 65,15,20,208 ; unpcklps %xmm8,%xmm2
   DB 72,173 ; lods %ds:(%rsi),%rax
   DB 15,40,29,114,45,0,0 ; movaps 0x2d72(%rip),%xmm3 # 5150 <_sk_callback_sse2+0x5ea>
   DB 255,224 ; jmpq *%rax
 PUBLIC _sk_byte_tables_sse2
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
struct InsertImplicitCastsImpl {
     return or_(std::move(lhs.expr), std::move(rhs.expr));
   }
   Result<ExpressionPtr> operator()(const ComparisonExpression& expr) {
     ARROW_ASSIGN_OR_RAISE(auto lhs, Validate(*expr.left_operand()));
     ARROW_ASSIGN_OR_RAISE(auto rhs, Validate(*expr.right_operand()));
------------------------------------------------------------
bug injection: 
struct InsertImplicitCastsImpl {
     return or_(std::move(lhs.expr), std::move(rhs.expr));
   }
   Result<std::shared_ptr<Expression>> operator()(const ComparisonExpression& expr) {
     ARROW_ASSIGN_OR_RAISE(auto lhs, Validate(*expr.left_operand()));
     ARROW_ASSIGN_OR_RAISE(auto rhs, Validate(*expr.right_operand()));
------------------------------------------------------------
actual bug: 
 struct InsertImplicitCastsImpl {
     return or_(std::move(lhs.expr), std::move(rhs.expr));
   }
   Result<std::shared_ptr<Expression>> operator()(const ComparisonExpression& expr) {
     ARROW_ASSIGN_OR_RAISE(auto lhs, Validate(*expr.left_operand()));
     ARROW_ASSIGN_OR_RAISE(auto rhs, Validate(*expr.right_operand()));
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class LinearClassifierTest(test.TestCase):
     self.assertGreater(scores['accuracy'], 0.9)
   def testSdcaOptimizerMixedFeatures(self):
     """Tests LinearClassifier with SDCAOptimizer and a mix of features."""
     def input_fn():
       return {
------------------------------------------------------------
bug injection: 
class LinearClassifierTest(test.TestCase):
     self.assertGreater(scores['accuracy'], 0.0)
   def testSdcaOptimizerMixedFeatures(self):
     """Tests with SDCAOptimizer and with SDCAOptimizer and with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer with SDCAOptimizer
------------------------------------------------------------
actual bug: 
 class LinearClassifierTest(test.TestCase):
     self.assertGreater(scores['accuracy'], 0.9)
   def testSdcaOptimizerMixedFeatures(self):
     """Tests LinearClasssifier with SDCAOptimizer and a mix of features."""
     def input_fn():
       return {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int register_service(void)
            (attr_count - svc_attr_count);
  server_svcs[svc_count].attr_count = svc_attr_count;
  return bt_gatt_service_register(&server_svcs[svc_count]);
 }
 static void add_service(u8_t *data, u16_t len)
------------------------------------------------------------
bug injection: 
static int register_service(void)
             (attr_count - svc_attr_count);
  server_svcs[svc_count];
  set_gatt_service(u8_t *data, u16_t len)
------------------------------------------------------------
actual bug: 
 static int register_service(void)
            (attr_count - svc_attr_count);
  server_svcs[svc_count].attr_count = svc_attr_count;
  return bt_gatt_service_register(server_svcs);
 }
 static void add_service(u8_t *data, u16_t len)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class ArrayEqualsVisitor : public RangeEqualsVisitor {
   }
   bool CompareBinary(const BinaryArray& left) {
     const auto& right = checked_cast<const BinaryArray&>(right_);
     bool equal_offsets = ValueOffsetsEqual<BinaryArray>(left);
     if (!equal_offsets) {
------------------------------------------------------------
bug injection: 
class ArrayEqualsVisitor : public RangeEqualsVisitor {
   }
   bool operator==(const BinaryArray& left) {
     const BinaryArray& right = static_cast<BinaryArray>(right);
     if (!equal_offsets) {
------------------------------------------------------------
actual bug: 
 class ArrayEqualsVisitor : public RangeEqualsVisitor {
   }
   bool CompareBinary(const BinaryArray& left) {
     const auto& right = static_cast<const BinaryArray&>(right_);
     bool equal_offsets = ValueOffsetsEqual<BinaryArray>(left);
     if (!equal_offsets) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int32_t scap_read_proclist(scap_t *handle, gzFile f, uint32_t block_lengt
   readsize = gzread(f, &(tinfo.fdlimit), sizeof(uint64_t));
   CHECK_READ_SIZE(readsize, sizeof(uint64_t));
   subreadsize += readsize;
------------------------------------------------------------
bug injection: 
static int32_t scap_read_proclist(scap_t *handle, gzFile f, uint32_t block_lengt
   readsize = gzread(f, &(tinfo.fdlimit), sizeof(uint64_t));
   CHECK_READ_SIZE(readsize, sizeof(uint64_t));
   totreadsize += readsize;
------------------------------------------------------------
actual bug: 
 static int32_t scap_read_proclist(scap_t *handle, gzFile f, uint32_t block_lengt
   readsize = gzread(f, &(tinfo.fdlimit), sizeof(uint64_t));
   CHECK_READ_SIZE(readsize, sizeof(uint64_t));
   totreadsize += readsize;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
tb_void_t tb_aicp_kill(tb_aicp_t* aicp)
     tb_assert_and_check_return(aicp);
     tb_trace_d("kill:..");
     tb_aicp_kill_all(aicp);
------------------------------------------------------------
bug injection: 
tb_void_t tb_aicp_kill(tb_aicp_t* aicp)
     tb_assert_and_check_check_return(aicp);
     tb_trace_d("kill:..");
     tb_trace_d("kill:..");
------------------------------------------------------------
actual bug: 
 tb_void_t tb_aicp_kill(tb_aicp_t* aicp)
     tb_assert_and_check_return(aicp);
     tb_aicp_kill_all(aicp);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static bool isXInputDevice(const GUID * pGuidProductFromDirectInput) {
    return false;
   }
   rawDevList = (RAWINPUTDEVICELIST*)malloc(sizeof(RAWINPUTDEVICELIST) * rawDevListCount);
   if (GetRawInputDeviceList(rawDevList, &rawDevListCount, sizeof(RAWINPUTDEVICELIST)) == (UINT) -1) {
    free(rawDevList);
------------------------------------------------------------
bug injection: 
static bool isXInputDevice(const GUID * pGuidProductFrom) {
    return false;
   }
   rawDevList = (RAWINPUTDEVICELIST)malloc(RAWINPUTDEVICELIST)malloc(sizeof(RAWINPUTDEVICELIST))) {
    free(RAWINPUTDEVICELIST) {
    free(RAWINPUTDEVICELIST) + (RAWINPUTDEVICELIST) +1) == (RAWINPUTDEVICELIST) +1) == -1) {
------------------------------------------------------------
actual bug: 
 static bool isXInputDevice(const GUID * pGuidProductFromDirectInput) {
    return false;
   }
   rawDevList = malloc(sizeof(RAWINPUTDEVICELIST) * rawDevListCount);
   if (GetRawInputDeviceList(rawDevList, &rawDevListCount, sizeof(RAWINPUTDEVICELIST)) == (UINT) -1) {
    free(rawDevList);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
namespace Ogre
   Root::getSingleton().getWorkQueue()->addRequest(
    mWorkQueueChannel, WORKQUEUE_GENERATE_MATERIAL_REQUEST,
    Any(req), 0, synchronous);
  }
  void Terrain::unload()
------------------------------------------------------------
bug injection: 
namespace Ogre
   Root::getSingleton().getWorkQueue()->addRequest(
    mWorkQueueChannel, WORKQUEUE_GENERATE_MATERIAL_REQUEST,
    Any(req), 0);
  }
  Terrain::unload()
------------------------------------------------------------
actual bug: 
 namespace Ogre
   Root::getSingleton().getWorkQueue()->addRequest(
    mWorkQueueChannel, WORKQUEUE_GENERATE_MATERIAL_REQUEST,
    Any(req), 0, synchronous);
   mGenerateMaterialInProgress = true;
  }
  void Terrain::unload()
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
     virtual QString getStatusString() final override;
     void setName(const QString& name);
     void onUserListChanged();
     void editName();
 signals:
     void groupWidgetClicked(GroupWidget* widget);
------------------------------------------------------------
bug injection: 
public:
     void nameChanged(const QString& name);
     void nameChanged(const QString& name);
     void nameChanged(const QString& name);
     void nameChanged(const QString& name);
------------------------------------------------------------
actual bug: 
 public:
     virtual QString getStatusString() final override;
     void setName(const QString& name);
     void onUserListChanged();
     void rename();
 signals:
     void groupWidgetClicked(GroupWidget* widget);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
boost::future<std::unique_ptr<hal::Library>> Compiler::Build(const context::Cont
     VLOG(1) << "Using OpenCL cache directory: " << env_cache;
     cache_dir = env_cache;
   }
   std::set<std::string> knames;
   for (const auto& ki : kernel_info) {
     context::Activity kbuild{activity.ctx(), "tile::hal::opencl::BuildKernel"};
------------------------------------------------------------
bug injection: 
boost::future<std::unique_ptr<hal::Lib
     VLOG(1) << " << " << env_cache directory: " << env_cache directory: " << env_cache;
   }
   for (const auto& ki : kname;
     context::Activity kbuild{
     context::Activity kbuild{
     context::Activity kbuild{activity};
------------------------------------------------------------
actual bug: 
 boost::future<std::unique_ptr<hal::Library>> Compiler::Build(const context::Cont
     VLOG(1) << "Using OpenCL cache directory: " << env_cache;
     cache_dir = env_cache;
   }
   for (const auto& ki : kernel_info) {
     context::Activity kbuild{activity.ctx(), "tile::hal::opencl::BuildKernel"};
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class READ_INFO {
 public:
   bool error,line_cuted,found_null,enclosed;
   uchar *row_start,
   CHARSET_INFO *read_charset;
------------------------------------------------------------
bug injection: 
class READ_INFO {
 public:
   bool error,line_cuted,enclosed;
   CHARSET_INFO *read_charset;
   CHARSET_INFO *read_charset;
   char *read_charset;
------------------------------------------------------------
actual bug: 
 class READ_INFO {
 public:
   bool error,line_cuted,found_null,enclosed;
   byte *row_start,
   CHARSET_INFO *read_charset;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
namespace mlir {
 class NestedPattern;
 class Operation;
------------------------------------------------------------
bug injection: 
namespace mlir {
 class Operation;
------------------------------------------------------------
actual bug: 
 namespace mlir {
 struct NestedPattern;
 class Operation;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int bootstrap(FILE *file)
   if (pthread_create(&thd->real_id,&connection_attrib,handle_bootstrap,
        (void*) thd))
   {
     sql_print_warning("Can't create thread to handle bootstrap");
     DBUG_RETURN(-1);
   }
------------------------------------------------------------
bug injection: 
static int bootstrap(FILE *file)
   if (pthread_create(&thd->real_attrib,handle_bootstrap,handle_bootstrap,
                     &thd->real_attrib,
                     thd->loader))
   {
     sql_print_warning("Can't create thread to handle bootstrap");
     return -1;
   }
------------------------------------------------------------
actual bug: 
 static int bootstrap(FILE *file)
   if (pthread_create(&thd->real_id,&connection_attrib,handle_bootstrap,
        (void*) thd))
   {
     sql_print_error("Warning: Can't create thread to handle bootstrap");
     DBUG_RETURN(-1);
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public slots:
  void showUI() override;
  void hideUI() override;
  void toggleUI() override;
  void handleClientEmbed();
------------------------------------------------------------
bug injection: 
public slots:
  void showUI() override;
  void hideUI() override;
  void toggleUI() override;
  void handleClientEmbed();
------------------------------------------------------------
actual bug: 
 public slots:
  void showUI() override;
  void hideUI() override;
  void handleClientEmbed();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
namespace gr {
     void
     const_sink_c_impl::set_nsamps(const int newsize)
     {
       gr::thread::scoped_lock lock(d_setlock);
       if(newsize!= d_size) {
------------------------------------------------------------
bug injection: 
namespace gr {
     void
     const_sink_impl::set_nsamps(const int newsize)
     {
       gr::thread::scoped_lock lock(d_setlock);
       if(newsize!= d_size) {
------------------------------------------------------------
actual bug: 
 namespace gr {
     void
     const_sink_c_impl::set_nsamps(const int newsize)
     {
       gr::thread::scoped_lock lock(d_mutex);
       if(newsize!= d_size) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Last_SQL_Errno 1091
 Last_SQL_Error Error 'Can't DROP 'c7'; check that column/key exists' on query. Default database: 'test'. Query: 'ALTER TABLE t14 DROP COLUMN c7'
 Replicate_Ignore_Server_Ids
 Master_Server_Id 1
 Master_Info_File #
 STOP SLAVE;
 RESET SLAVE;
------------------------------------------------------------
bug injection: 
Last_SQL_Errno 1091
 Last_SQL_Error Error 'Can't DROP 'c7'; check that column/key exists' on query. Default database: 'test'. Query: 'ALTER TABLE t14 DROP COLUMN c7'
 Replicate_Ignore_Server_Ids
 Master_Server_Id 1
 Master_Info_File #
 STOP SLAVE;
 RESET SLAVE;
------------------------------------------------------------
actual bug: 
 Last_SQL_Errno 1091
 Last_SQL_Error Error 'Can't DROP 'c7'; check that column/key exists' on query. Default database: 'test'. Query: 'ALTER TABLE t14 DROP COLUMN c7'
 Replicate_Ignore_Server_Ids
 Master_Server_Id 1
 STOP SLAVE;
 RESET SLAVE;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Backup::sendBackupRef(Signal* signal, BackupRecordPtr ptr, Uint32 errorCode)
 {
   jam();
   sendBackupRef(ptr.p->clientRef, signal, ptr.p->clientData, errorCode);
   cleanup(signal, ptr);
 }
 void
------------------------------------------------------------
bug injection: 
Backup::sendBackupRef(Signal* signal, BackupRecordPtr ptr, Uint32 errorCode)
 {
   jam();
   sendBackupRef(signal, ptr.p->senderRef, errorCode);
   failed();
 }
 void
------------------------------------------------------------
actual bug: 
 Backup::sendBackupRef(Signal* signal, BackupRecordPtr ptr, Uint32 errorCode)
 {
   jam();
   sendBackupRef(ptr.p->clientRef, signal, ptr.p->clientData, errorCode);
   cleanupSlaveResources(ptr);
 }
 void
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int mysql_test_select(Prepared_statement *stmt,
   if (!lex->result &&!(lex->result= new (stmt->mem_root) select_send))
   {
     my_error(ER_OUTOFMEMORY, MYF(0), static_cast<int>(sizeof(select_send)));
     goto error;
   }
------------------------------------------------------------
bug injection: 
static int mysql_test_select(Prepared_statement *stmt,
   if (!lex->result &&!(lex->result= new (stmt->mem_root) new (lex->mem_send))
   {
     my_error(ER_OUTOFMEMORY, MYF(0), sizeof(select_send)));
     goto error;
   }
------------------------------------------------------------
actual bug: 
 static int mysql_test_select(Prepared_statement *stmt,
   if (!lex->result &&!(lex->result= new (stmt->mem_root) select_send))
   {
     my_error(ER_OUTOFMEMORY, MYF(0), sizeof(select_send));
     goto error;
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Bitu INT10_Handler(void) {
   case 0x04:
   case 0x14:
    if (!IS_VGA_ARCH) break;
    INT10_LoadFont(Real2Phys(int10.rom.font_16),reg_al==0x14,256,0,reg_bl&0x7f,16);
    break;
   case 0x20:
------------------------------------------------------------
bug injection: 
Bitu INT10_Handler(void) {
   case 0x04:
   case 0x04:
    if (!IS_VGA_ARCH)
    break;
   case 0x04:
   case 0x20:
------------------------------------------------------------
actual bug: 
 Bitu INT10_Handler(void) {
   case 0x04:
   case 0x14:
    if (!IS_VGA_ARCH) break;
    INT10_LoadFont(Real2Phys(int10.rom.font_16),reg_al==0x14,256,0,reg_bl,16);
    break;
   case 0x20:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int clif_authok(struct map_session_data *sd) {
  WFIFOPOS(fd, 6, sd->bl.x, sd->bl.y, sd->ud.dir);
  WFIFOB(fd, 9) = 5;
  WFIFOB(fd,10) = 5;
  WFIFOSET2(fd,packet_len_table[0x73],1);
  return 0;
 }
------------------------------------------------------------
bug injection: 
int clif_authok(struct map_session_data *sd) {
  WFIFOPOS(fd, 6, sd->bl.y, sd->bl.dir);
  WFIFOB(fd,10) = 5;
  WFIFOB(fd,10) = 5;
  WFIFOB(fd,9) = 5;
  WFIFOSET(fd, packet_len_table[0x73],1);
  return 0;
 }
------------------------------------------------------------
actual bug: 
 int clif_authok(struct map_session_data *sd) {
  WFIFOPOS(fd, 6, sd->bl.x, sd->bl.y, sd->ud.dir);
  WFIFOB(fd, 9) = 5;
  WFIFOB(fd,10) = 5;
  WFIFOSET(fd,packet_len_table[0x73]);
  return 0;
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   if (!result)
   {
     result= write_bin_log(thd, TRUE, thd->query(), thd->query_length());
   }
   mysql_rwlock_unlock(&LOCK_grant);
------------------------------------------------------------
bug injection: 
int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   if (!result)
   {
     write_bin_log(thd, TRUE, thd->query(), thd->query_length());
   }
   mysql_rwlock_unlock(&LOCK_grant);
------------------------------------------------------------
actual bug: 
 int mysql_table_grant(THD *thd, TABLE_LIST *table_list,
   if (!result)
   {
     write_bin_log(thd, TRUE, thd->query(), thd->query_length());
   }
   mysql_rwlock_unlock(&LOCK_grant);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int opt_sum_query(TABLE_LIST *tables, List<Item> &all_fields,COND *conds)
         Item *expr=item_sum->args[0];
         if (expr->real_item()->type() == Item::FIELD_ITEM)
         {
           uchar key_buff[MAX_KEY_LENGTH];
           TABLE_REF ref;
           uint range_fl, prefix_len;
------------------------------------------------------------
bug injection: 
int opt_sum_query(TABLE_LIST *tables, List<Item> &all_fields,COND *conds)
         Item *expr=item_sum->args[0];
         if (expr->real_item()->type()!= Item::FIELD_ITEM)
         {
           TABLE_REF ref;
           TABLE_REF ref;
           uint range_fl;
------------------------------------------------------------
actual bug: 
 int opt_sum_query(TABLE_LIST *tables, List<Item> &all_fields,COND *conds)
         Item *expr=item_sum->args[0];
         if (expr->real_item()->type() == Item::FIELD_ITEM)
         {
           byte key_buff[MAX_KEY_LENGTH];
           TABLE_REF ref;
           uint range_fl, prefix_len;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool Field_real::get_date(MYSQL_TIME *ltime,ulonglong fuzzydate)
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   double nr= val_real();
   return double_to_datetime_with_warn(nr, ltime, fuzzydate, field_name.str);
 }
------------------------------------------------------------
bug injection: 
bool Field_real::get_date(MYSQL_TIME *ltime,MYSQL_TIME *ltime)
 {
   ASSERT_COLUMN_MARKED_MARKED_FOR_READ();
   return double nr= val_real();
 }
------------------------------------------------------------
actual bug: 
 bool Field_real::get_date(MYSQL_TIME *ltime,ulonglong fuzzydate)
 {
   ASSERT_COLUMN_MARKED_FOR_READ;
   double nr= val_real();
   return double_to_datetime_with_warn(nr, ltime, fuzzydate, field_name);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void ReqAckPlayerPosSync::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from
 void ReqAckPlayerPosSync::MergeFrom(const ReqAckPlayerPosSync& from) {
   GOOGLE_DCHECK_NE(&from, this);
   _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
   ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
   (void) cached_has_bits;
------------------------------------------------------------
bug injection: 
void ReqAckPlayerPosSync::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from
 void ReqAckPlayerPosSync::MergeFrom(const ReqAckPlayerPosSync& from) {
   GOOGLE_DCHECK_NE(&from, this);
   _internal_metadata_.MergeFrom(from._internal_metadata_);
   ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
   (void) cached_has_bits;
------------------------------------------------------------
actual bug: 
 void ReqAckPlayerPosSync::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from
 void ReqAckPlayerPosSync::MergeFrom(const ReqAckPlayerPosSync& from) {
   GOOGLE_DCHECK_NE(&from, this);
   _internal_metadata_.MergeFrom(from._internal_metadata_);
   ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
   (void) cached_has_bits;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
namespace mlir {
 struct NestedPatternStorage;
 struct NestedMatchStorage;
 class Instruction;
------------------------------------------------------------
bug injection: 
namespace mlir {
 struct LogicalResult;
 struct LogicalResult;
 struct LogicalResult;
------------------------------------------------------------
actual bug: 
 namespace mlir {
 struct MLFunctionMatcherStorage;
 struct MLFunctionMatchesStorage;
 class Instruction;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
LRESULT CALLBACK ColourPickerDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM
   }
   pbufferA.Display(hcomp);
   DrawArrows(hcomp, widthA, heightA, (SendDlgItemMessage(hDlg, IDC_ASLIDER, UDM_GETPOS, 0, (LPARAM)&result) / 255.0f) * heightA);
   BitBlt(hdc, 0, 0, widthA, heightA, hcomp, 0, 0, SRCCOPY);
------------------------------------------------------------
bug injection: 
LRESULT CALLBACK ColourPickerDlg, WPARAM wParam, WPARAM wParam, WPARAM wParam, WPARAM wParam,
   }
   DrawArrows(hcomp, widthA, heightA
   DrawArrows(hcomp, widthA, heightA, 0);
   DrawArrows(hdc, 0, heightA, heightA, (DRAW);
   DrawArrows(hdc, 0, heightA - heightA, heightA, heightA, 0, 0);
------------------------------------------------------------
actual bug: 
 LRESULT CALLBACK ColourPickerDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM
   }
   pbufferA.Display(hcomp);
   DrawArrows(hcomp, widthA, heightA, (SendDlgItemMessage(hDlg, IDC_ASLIDER, UDM_GETPOS, 0, (LPARAM)&result) / 100.0f) * heightA);
   BitBlt(hdc, 0, 0, widthA, heightA, hcomp, 0, 0, SRCCOPY);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void test_manual_sample()
   ulonglong affected_rows;
   MYSQL_BIND bind[3];
   my_bool is_null;
   char query[MAX_TEST_QUERY_LENGTH];
   myheader("test_manual_sample");
------------------------------------------------------------
bug injection: 
static void test_manual_sample()
   ulonglong affected_rows;
   ulonglong affected_rows;
   myheader("test_manual_sample");
   MYSQL_BIND bind[3];
   myheader("test_manual_sample");
------------------------------------------------------------
actual bug: 
 static void test_manual_sample()
   ulonglong affected_rows;
   MYSQL_BIND bind[3];
   my_bool is_null;
   myheader("test_manual_sample");
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
PREPARE prep_2 FROM "INSERT INTO trigger_table_1 VALUES (1)";
 EXECUTE prep_2;
 Warnings:
 Note 1592 Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT. Statement is unsafe because it invokes a trigger or a stored function that inserts into an AUTO_INCREMENT column. Inserted values cannot be logged correctly.
 DROP PREPARE prep_2;
------------------------------------------------------------
bug injection: 
PREPARE prep_2 FROM "INSERT INTO trigger_table_1 VALUES (1)";
 EXECUTE prep_2;
 Warnings:
 Note 1592 Unsafe statement written to the binary log in statement format since BINLOG_FORMAT = STATEMENT. The statement is unsafe because it invokes a trigger or a stored function that inserts into AUTO_INCREMENT column. The inserted values cannot be correctly logged.
 DROP PREPARE prep_2;
------------------------------------------------------------
actual bug: 
 PREPARE prep_2 FROM "INSERT INTO trigger_table_1 VALUES (1)";
 EXECUTE prep_2;
 Warnings:
 Note 1592 Unsafe statement written to the binary log in statement format since BINLOG_FORMAT = STATEMENT. The statement is unsafe because it invokes a trigger or a stored function that inserts into AUTO_INCREMENT column. The inserted values cannot be correctly logged.
 DROP PREPARE prep_2;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
__global__ void reorderDataKeysOnly(uint *outKeys,
                                     uint startBlock,
                                     PostProcess postprocess)
 {
     __shared__ uint2 sKeys2[RadixSort::cta_size];
     __shared__ uint sOffsets[16];
     __shared__ uint sBlockOffsets[16];
------------------------------------------------------------
bug injection: 
__global__ void reorderDataKeysOnly(uint *outKeys,
                                     uint startBlock,
                                     PostProcess postProcess postProcess postProcess postprocess)
 {
     __shared__ uint2[RadixSort::ctaSize];
     __shared__ uint sOffsets[16];
------------------------------------------------------------
actual bug: 
 __global__ void reorderDataKeysOnly(uint *outKeys,
                                     uint startBlock,
                                     PostProcess postprocess)
 {
     __shared__ uint2 sKeys2[RadixSort::CTA_SIZE];
     __shared__ uint sOffsets[16];
     __shared__ uint sBlockOffsets[16];
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void test_field_misc()
                        "@@max_allowed_packet", "",
                        MYSQL_TYPE_LONGLONG,
                        "", "",
                        "", MY_INT64_NUM_DECIMAL_DIGITS, 0);
   mysql_free_result(result);
   mysql_stmt_close(stmt);
------------------------------------------------------------
bug injection: 
static void test_field_misc()
                        "@@max_allowed_packet", "",
                        MYSQL_TYPE_LONGLONG,
                        "", "",
                        "", MY_INT64_NUM_DECIMAL_DIGITS, 0);
   mysql_free_result(result);
   mysql_stmt_close(stmt);
------------------------------------------------------------
actual bug: 
 static void test_field_misc()
                        "@@max_allowed_packet", "",
                        MYSQL_TYPE_LONGLONG,
                        "", "",
                        "", 10, 0);
   mysql_free_result(result);
   mysql_stmt_close(stmt);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool NameAndTypeResolver::resolveNamesAndTypes(ContractDefinition& _contract)
    if (!resolver.resolve(*baseContract))
     success = false;
   m_currentScope = m_scopes[&_contract].get();
   if (success)
   {
------------------------------------------------------------
bug injection: 
bool NameAndTypeResolver::resolveNamesAndTypes(contractDefinition& _contract)
    if (!resolver.resolve(*baseContractDefinition& _contract)
     m_currentScope = &this;
   if (success)
   {
------------------------------------------------------------
actual bug: 
 bool NameAndTypeResolver::resolveNamesAndTypes(ContractDefinition& _contract)
    if (!resolver.resolve(*baseContract))
     success = false;
   m_currentScope = &m_scopes[&_contract];
   if (success)
   {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void CodeViewEditor::LineNumberAreaPaintEvent( QPaintEvent *event )
     QPainter painter( m_LineNumberArea );
     painter.fillRect( event->rect(), m_codeViewAppearance.line_number_background_color );
     QTextBlock block = firstVisibleBlock();
------------------------------------------------------------
bug injection: 
void CodeViewEditor::PaintEvent( QPaintEvent *event )
     QPainter painter( m_LineNumberArea );
     painter.fillRect( event->rect(), m_codeViewAppearance.line_number_background_color );
     QTextBlock block = firstVisibleBlock();
------------------------------------------------------------
actual bug: 
 void CodeViewEditor::LineNumberAreaPaintEvent( QPaintEvent *event )
     QPainter painter( m_LineNumberArea );
     painter.fillRect( event->rect(), NUMBER_AREA_BGCOLOR );
     QTextBlock block = firstVisibleBlock();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void window_tile_inspector_scrollmousedown(rct_window *w, int scrollIndex
  window_tile_inspector_auto_set_buttons(w);
  widget_invalidate(w, WIDX_LIST);
 }
 static void window_tile_inspector_scrollmouseover(rct_window *w, int scrollIndex, int x, int y)
------------------------------------------------------------
bug injection: 
static void window_tile_inspector_scrollmousedown(rct_window *w, int scrollIndex
  window_tile_set_buttons(wIDX_window *w, int y, int y);
 }
 static void window_tile_inspector_tile_inspector_close(rct_window *w, int y)
------------------------------------------------------------
actual bug: 
 static void window_tile_inspector_scrollmousedown(rct_window *w, int scrollIndex
  window_tile_inspector_auto_set_buttons(w);
 }
 static void window_tile_inspector_scrollmouseover(rct_window *w, int scrollIndex, int x, int y)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class segment_reader_impl : public sub_reader {
     return docs_count_;
   }
   virtual doc_iterator::ptr docs_iterator() const override;
   virtual doc_iterator::ptr mask(doc_iterator::ptr&& it) const override {
     if (docs_mask_.empty()) {
------------------------------------------------------------
bug injection: 
class segment_reader_impl : public sub_reader {
     return docs_count_;
   }
   virtual doc_iterator::ptr docs_iterator() const override;
   virtual doc_iterator::ptr docs_iterator() const override;
------------------------------------------------------------
actual bug: 
 class segment_reader_impl : public sub_reader {
     return docs_count_;
   }
   virtual docs_iterator_t::ptr docs_iterator() const override;
   virtual doc_iterator::ptr mask(doc_iterator::ptr&& it) const override {
     if (docs_mask_.empty()) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void bootloader_utility_load_boot_image(const bootloader_state_t *bs, int start_
     ESP_LOGE(TAG, "No bootable app partitions in the partition table");
     bzero(&image_data, sizeof(esp_image_metadata_t));
     bootloader_reset();
 }
------------------------------------------------------------
bug injection: 
void bootloader_utility_load_image(const bootloader_state_state_t *bs, int start_
     ESP_LOGD(TAG, "Bad app partitions in the partition table");
     bzero(&image_data, sizeof(esp_image_metadata_t));
 }
------------------------------------------------------------
actual bug: 
 void bootloader_utility_load_boot_image(const bootloader_state_t *bs, int start_
     ESP_LOGE(TAG, "No bootable app partitions in the partition table");
     bzero(&image_data, sizeof(esp_image_metadata_t));
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
btr_compress(
  if (is_left) {
   btr_cur_t cursor2;
   rtr_mbr_t new_mbr;
   offset_t* offsets2 = NULL;
   if (dict_index_is_spatial(index)) {
------------------------------------------------------------
bug injection: 
btr_compress(
  if (is_left) {
   btr_cur_t cursor;
   rtr_mbr_t* new_mbr;
   if (dict_index_is_spatial(index)) {
------------------------------------------------------------
actual bug: 
 btr_compress(
  if (is_left) {
   btr_cur_t cursor2;
   rtr_mbr_t new_mbr;
   ulint* offsets2 = NULL;
   if (dict_index_is_spatial(index)) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class AssocUnique {
   Element find(UserData* userData, Element const& element) const {
     uint64_t i = _hashElement(userData, element);
     Bucket const& b = _buckets[i & _bucketsMask];
------------------------------------------------------------
bug injection: 
class AssocUnique {
   Element find(UserData* userData, Element const& element) const {
     uint64_t i = _hashElement(userData, element);
     Bucket const& b = _bucketsMask];
------------------------------------------------------------
actual bug: 
 class AssocUnique {
   Element* find(UserData* userData, Element const* element) const {
     uint64_t i = _hashElement(userData, element);
     Bucket const& b = _buckets[i & _bucketsMask];
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class Item_func_makedate :public Item_str_func
   }
   bool result_as_longlong() { return TRUE; }
   longlong val_int();
   bool check_partition_func_processor(byte *int_arg) { return FALSE;}
 };
------------------------------------------------------------
bug injection: 
class Item_func_makedate :public Item_str_func
   }
   bool result_as_longlong() { return TRUE; }
   bool result_as_longlong() { return TRUE;}
   longlong val_int();
 };
------------------------------------------------------------
actual bug: 
 class Item_func_makedate :public Item_str_func
   }
   bool result_as_longlong() { return TRUE; }
   longlong val_int();
   bool check_partition_func_processor(byte *int_arg) { return 0;}
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int AppLayerProbingParserTest09(void)
         goto end;
     if (pe->max_depth!= 5)
         goto end;
     if (pe->ProbingParser!= ProbingParserDummyForTesting)
         goto end;
     pe = pp->toserver->next;
------------------------------------------------------------
bug injection: 
static int AppLayerProbingParserTest09(void)
         goto end;
     if (pe->max_depth!= 5)
         goto end;
     if (pe->ProbingParser!= NULL)
         goto end;
     pe = pp->toserver->next;
------------------------------------------------------------
actual bug: 
 static int AppLayerProbingParserTest09(void)
         goto end;
     if (pe->max_depth!= 5)
         goto end;
     if (pe->ProbingParser!= NULL)
         goto end;
     pe = pp->toserver->next;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
namespace {
       if (ExtraTagBitCount > 0) {
         dest.add(unpack.claimAtOffset(extraTagTy,
                                       CommonUnusedBits.size() + offset));
       }
     }
------------------------------------------------------------
bug injection: 
namespace {
       if (ExtraTagBitCount > 0) {
       if (ExtraTagBitCount > 0) {
         dest.claimAtOffset(dest, CommonBits.size() + CommonBits.size() - CommonBits.size() - offset     }
       }
     }
------------------------------------------------------------
actual bug: 
 namespace {
       if (ExtraTagBitCount > 0) {
         dest.add(unpack.claimAtOffset(extraTagTy,
                                       CommonSpareBits.size() + offset));
       }
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SkBBoxHierarchyRecord::SkBBoxHierarchyRecord(uint32_t recordFlags,
     fStateTree = SkNEW(SkPictureStateTree);
     fBoundingHierarchy = h;
     fBoundingHierarchy->ref();
     fBoundingHierarchy->setClient(this);
 }
 void SkBBoxHierarchyRecord::handleBBox(const SkRect& bounds) {
------------------------------------------------------------
bug injection: 
SkBBoxHierarchyRecord::SkBBoxHierarchyRecord(uint32_t recordFlags,
     fStateTree = SkNEW(SkPictureStateTree);
     fBoundingHierarchy = h;
     fBoundingHierarchy->ref();
 }
 void SkBBoxHierarchyRecord::handleBBox(const SkRect& bounds) {
------------------------------------------------------------
actual bug: 
 SkBBoxHierarchyRecord::SkBBoxHierarchyRecord(uint32_t recordFlags,
     fStateTree = SkNEW(SkPictureStateTree);
     fBoundingHierarchy = h;
     fBoundingHierarchy->ref();
 }
 void SkBBoxHierarchyRecord::handleBBox(const SkRect& bounds) {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool mysql_analyze_table(THD* thd, TABLE_LIST* tables, HA_CHECK_OPT* check_opt)
   DBUG_ENTER("mysql_analyze_table");
   DBUG_RETURN(mysql_admin_table(thd, tables, check_opt,
     "analyze", lock_type, 1, 0, 0, 0,
     &handler::ha_analyze, 0));
 }
------------------------------------------------------------
bug injection: 
bool mysql_analyze_table(THD* thd, TABLE_LIST* tables, HA_CHECK_OPT* check_opt)
   DBUG_ENTER("mysql_analyze_table");
   DBUG_RETURN(mysql_admin_table(thd, tables, check_opt,
     "analyze", lock_type, 1, 0, 0, 0,
     &handler::ha_analyze, 0));
 }
------------------------------------------------------------
actual bug: 
 bool mysql_analyze_table(THD* thd, TABLE_LIST* tables, HA_CHECK_OPT* check_opt)
   DBUG_ENTER("mysql_analyze_table");
   DBUG_RETURN(mysql_admin_table(thd, tables, check_opt,
     "analyze", lock_type, 1, 0, 0, 0,
     &handler::analyze, 0));
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static void btc_ble_mesh_model_op_add(esp_ble_mesh_model_t *model)
     esp_ble_mesh_model_op_t *op = NULL;
     if (!model) {
         BT_ERR("%s, Invalid parameter", __func__);
         return;
     }
------------------------------------------------------------
bug injection: 
static void btc_ble_mesh_model_add(esp_mesh_model_model_t *op)
     esp_mesh_mesh_model_t *op = NULL;
     if (!model) {
         LOG_ERROR("%s, Invalid parameter", __func__);
         return;
     }
------------------------------------------------------------
actual bug: 
 static void btc_ble_mesh_model_op_add(esp_ble_mesh_model_t *model)
     esp_ble_mesh_model_op_t *op = NULL;
     if (!model) {
         LOG_ERROR("%s, Invalid parameter", __func__);
         return;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
EOF
  $run ${rm}r $gentop
       fi
       exit $EXIT_SUCCESS
       ;;
     prog)
------------------------------------------------------------
bug injection: 
EOF
  $run ${rm}r $gentop
       fi
       exit $EXIT_SUCCESS
       ;;
     prog)
------------------------------------------------------------
actual bug: 
 EOF
  $run ${rm}r $gentop
       fi
       exit 0
       ;;
     prog)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class ARROW_FLIGHT_EXPORT FlightServerOptions {
   Location location;
   std::unique_ptr<ServerAuthHandler> auth_handler;
   std::vector<CertKeyPair> tls_certificates;
   std::function<void(void*)> builder_hook;
 };
------------------------------------------------------------
bug injection: 
class ARROW_FLIGHT_EXPORT FlightServerOptions {
   Location location;
   std::unique_ptr<ServerAuthHandler> auth_handler;
 };
------------------------------------------------------------
actual bug: 
 class ARROW_FLIGHT_EXPORT FlightServerOptions {
   Location location;
   std::unique_ptr<ServerAuthHandler> auth_handler;
   std::vector<CertKeyPair> tls_certificates;
 };
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
event_timed::update_fields(THD *thd)
 done:
   close_thread_tables(thd);
   thd->restore_backup_open_tables_state(&backup);
   DBUG_RETURN(ret);
 }
------------------------------------------------------------
bug injection: 
event_timed::update_fields(THD *thd)
 done:
   close_thread_tables(thd);
   DBUG_RETURN(ret);
 }
------------------------------------------------------------
actual bug: 
 event_timed::update_fields(THD *thd)
 done:
   close_thread_tables(thd);
   DBUG_RETURN(ret);
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void SkDrawBitmapLatticeCommand::toJSON(SkJSONWriter& writer, UrlDataManager& ur
     writer.appendName(SKDEBUGCANVAS_ATTRIBUTE_DST); MakeJsonRect(writer, fDst);
     if (fPaint.isValid()) {
         writer.appendName(SKDEBUGCANVAS_ATTRIBUTE_PAINT);
         MakeJsonPaint(writer, *fPaint, urlDataManager);
     }
     SkString desc;
------------------------------------------------------------
bug injection: 
void SkDrawBitmapLatticeCommand::toJSON(SkJSONWriter& writer, UrlDataManager& ur
     writer.appendName(SKDEBUGCANVAS_ATTRIBUTE_DST); MakeJsonPaint(writer, fDst);
     if (fPaint.isValid()) {
         writer.appendName(writer, *fPaint);
     }
     if (fPaint.isValid()) {
------------------------------------------------------------
actual bug: 
 void SkDrawBitmapLatticeCommand::toJSON(SkJSONWriter& writer, UrlDataManager& ur
     writer.appendName(SKDEBUGCANVAS_ATTRIBUTE_DST); MakeJsonRect(writer, fDst);
     if (fPaint.isValid()) {
         writer.appendName(SKDEBUGCANVAS_ATTRIBUTE_PAINT);
         MakeJsonPaint(writer, *fPaint.get(), urlDataManager);
     }
     SkString desc;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
public:
   void shrink_to_fit() noexcept {
     if (empty()) {
       impl_.reset();
       return;
     }
------------------------------------------------------------
bug injection: 
public:
   void shrink_to_fit() noexcept {
     if (empty()) {
       impl_.reset();
       return;
     }
------------------------------------------------------------
actual bug: 
 public:
   void shrink_to_fit() noexcept {
     if (empty()) {
       return;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class PartiallyConvertedTestA(trt_test.TfTrtIntegrationTestBase):
         input_names=[input_name],
         input_dims=[[input_dims]],
         output_names=[output_name],
         expected_output_dims=[[input_dims]])
   def ExpectedEnginesToBuild(self, run_params):
     """Return the expected engines to build."""
------------------------------------------------------------
bug injection: 
class PartiallyConvertedTestA(trt_test.TfTrtIntegrationTestBase):
         input_names=[input_name],
         input_names=[output_names=[output_name],
         output_output_names=[output_name],
         expected_output_dims=[[input_dims]],
   def ExpectedEnginesToBuild(self, run_params):
     """Return the expected engines to build.
------------------------------------------------------------
actual bug: 
 class PartiallyConvertedTestA(trt_test.TfTrtIntegrationTestBase):
         input_names=[input_name],
         input_dims=[[input_dims]],
         output_names=[output_name],
         expected_output_dims=[[tuple(input_dims)]])
   def ExpectedEnginesToBuild(self, run_params):
     """Return the expected engines to build."""
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
int cellRtcTickAddWeeks(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1
  return CELL_OK;
 }
 s32 cellRtcTickAddMonths(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1, s32 iAdd)
 {
  cellRtc.Log("cellRtcTickAddMonths(pTick0=0x%x, pTick1=0x%x, iAdd=%d)", pTick0.addr(), pTick1.addr(), iAdd);
------------------------------------------------------------
bug injection: 
int cellRtcTickAddWeeks(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1
  return CELL_OK;
 }
 int cellRtcTickAddMonths(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1, s32 iAdd)
 {
  cellRtc.Log("cellRtcTickAddMonths(pTick0=0x%x, pTick1=0x%x, iAdd=%d)", pTick0.addr(), pTick0.addr(), iAdd);
------------------------------------------------------------
actual bug: 
 int cellRtcTickAddWeeks(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1
  return CELL_OK;
 }
 int cellRtcTickAddMonths(vm::ptr<CellRtcTick> pTick0, vm::ptr<CellRtcTick> pTick1, s32 iAdd)
 {
  cellRtc.Log("cellRtcTickAddMonths(pTick0=0x%x, pTick1=0x%x, iAdd=%d)", pTick0.addr(), pTick1.addr(), iAdd);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST (ExpandPicture, ExpandPictureChroma) {
       uiCpuFlag = WelsCPUFeatureDetect (&iCpuCores);
     }
     InitExpandPictureFunc (&sExpandPicFunc, uiCpuFlag);
     for (int32_t iTestIdx = 0; iTestIdx < EXPAND_PIC_TEST_NUM; iTestIdx++) {
       int32_t iPicWidth = (8 + (rand() % 200) * 8);
------------------------------------------------------------
bug injection: 
TEST (ExpandPicture, ExpandPictureChroma) {
       uiCpuFlag = WelsCPUFeatureDetect (&iCpuCores);
       }
     uiCpuFlag = WelsCPUFeature (&iTestIdx = 0;
     for (int32_t*) rand () / 200);
     for (int32_t iTestIdx = 0; iTestIdx++) {
       int32_t iTestIdx = (rand () % 200);
------------------------------------------------------------
actual bug: 
 TEST (ExpandPicture, ExpandPictureChroma) {
       uiCpuFlag = WelsCPUFeatureDetect (&iCpuCores);
     }
     InitExpandPictureFunc (&sExpandPicFunc, uiCpuFlag);
     srand ((unsigned int)time (0));
     for (int32_t iTestIdx = 0; iTestIdx < EXPAND_PIC_TEST_NUM; iTestIdx++) {
       int32_t iPicWidth = (8 + (rand() % 200) * 8);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void start_keosd( uint16_t wallet_port ) {
          std::cerr << "Failed to launch " << keosPath << std::endl;
       }
    } else {
       std::cerr << "keosd not found" << std::endl;
    }
 }
------------------------------------------------------------
bug injection: 
void start_keosd( uint16_t wallet_listen( uint16_t wallet_port ) {
       std::cerr << "Failed to start" << std::endl;
    }
    }
 }
------------------------------------------------------------
actual bug: 
 void start_keosd( uint16_t wallet_port ) {
          std::cerr << "Failed to launch " << keosPath << std::endl;
       }
    } else {
       std::cerr << "keos not found" << std::endl;
    }
 }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
Value do_evaluate(const Position& pos, Value& margin) {
   if (ei.mi->specialized_eval_exists())
   {
       margin = VALUE_ZERO;
       return ei.mi->evaluate(pos);
   }
------------------------------------------------------------
bug injection: 
Value do_evaluate(const Position& pos, Value& margin) {
   if (ei.mi->specialized_eval_exists())
   {
     margin = VALUE_ZERO;
   }
------------------------------------------------------------
actual bug: 
 Value do_evaluate(const Position& pos, Value& margin) {
   if (ei.mi->specialized_eval_exists())
   {
       margin = VALUE_ZERO;
       e->value = ei.mi->evaluate(pos);
       return e->value;
   }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
SECTION("test_FCallUser") {
     irs::order expected;
     bool valid = true;
     expected.add<dummy_scorer>(false, irs::string_ref::NIL);
     size_t attempt = 0;
     dummy_scorer::validateArgs = [&valid, &attempt](irs::string_ref const& args)->bool {
------------------------------------------------------------
bug injection: 
SECTION("test_FCallUser") {
     irs::order expected;
     expected;
     expected.add<dummy_scorer>(false, irs::string_ref::nil);
     expected.field(false, [&attempt](irs::string_ref const& args[])bool {
------------------------------------------------------------
actual bug: 
 SECTION("test_FCallUser") {
     irs::order expected;
     bool valid = true;
     expected.add<dummy_scorer>(false, irs::string_ref::nil);
     size_t attempt = 0;
     dummy_scorer::validateArgs = [&valid, &attempt](irs::string_ref const& args)->bool {
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int fp_div_d(fp_int *a, fp_digit b, fp_int *c, fp_digit *d)
   }
   if (s_is_power_of_two(b, &ix) == FP_YES) {
      if (d!= NULL) {
      }
------------------------------------------------------------
bug injection: 
static int fp_div_d(fp_int *a, fp_int *a, fp_int *c, fp_int *c, fp_int *d!= NULL)
   }
   if (d!= NULL) {
   if (d!= NULL) {
    }
------------------------------------------------------------
actual bug: 
 static int fp_div_d(fp_int *a, fp_digit b, fp_int *c, fp_digit *d)
   }
   if (s_is_power_of_two(b, &ix) == 1) {
      if (d!= NULL) {
      }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
TEST_CASE("SSL server multicast", "[CppServer][Asio]")
     REQUIRE(client1->Disconnect());
     while (client1->IsConnected() || (server->clients!= 2))
         Thread::Yield();
------------------------------------------------------------
bug injection: 
TEST_CASE("SSL server multicast", "[CppServer][Asio]")
     REQUIRE(client1->Disconnect());
     while (client1->IsConnected() || (server->clients!= 2))
         Thread::Yield();
------------------------------------------------------------
actual bug: 
 TEST_CASE("SSL server multicast", "[CppServer][Asio]")
     REQUIRE(client1->Disconnect());
     while (client1->IsConnected() || client1->IsHandshaked() || (server->clients!= 2))
         Thread::Yield();
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
May produce incorrect results if <a href='#SkRect_joinNonEmptyArg_r'>r</a> <a hr
 <div><fiddle-embed name="88439de2aa0911262c60c0eb506396cb"><div>Since <a href='SkRect_Reference#Rect'>Rect</a> is not sorted, first result is copy of toJoin.
 </div>
------------------------------------------------------------
bug injection: 
May produce incorrect results if <a href='#SkRect_joinNonEmptyArg_r'>r</a> and <a href='#SkRect_join
 <div><fiddle-embed name="a name="r1e90e9c2"><div><div><a href='SkRect_Reference#Rect'>Rect</a> <a href='SkRect_Reference#Rect'>copy</a> <a href='SkRect_Reference#Rect'>is</a> <a href='SkRect_Reference#Rect'>is</a> <a href='SkRect_Reference#Rect'>is</a> <a href='SkRect_Reference#Rect'>is</a> <a href='SkRect_Reference#Rect'>copy</a> <a href='SkRect_Reference#Rect'>copy</a> <a href='SkRect_Reference#Rect'>copy</a> <a href='SkRect_Reference#Rect'>is</a> <a href='SkRect_Reference#Rect'>is</a> <a href='#SkRect'>is</a> <a href='#SkRect'>is</a> <a href='#SkRect'>is</a>
------------------------------------------------------------
actual bug: 
 May produce incorrect results if <a href='#SkRect_joinNonEmptyArg_r'>r</a> <a hr
 <div><fiddle-embed name="88439de2aa0911262c60c0eb506396cb"><div>Since <a href='SkRect_Reference#Rect'>Rect</a> <a href='SkRect_Reference#Rect'>is</a> <a href='SkRect_Reference#Rect'>not</a> <a href='SkRect_Reference#Rect'>sorted</a>, <a href='SkRect_Reference#Rect'>first</a> <a href='SkRect_Reference#Rect'>result</a> <a href='SkRect_Reference#Rect'>is</a> <a href='SkRect_Reference#Rect'>copy</a> <a href='SkRect_Reference#Rect'>of</a> <a href='SkRect_Reference#Rect'>toJoin</a>.
 </div>
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
bool expr_this(pass_opt_t* opt, ast_t* ast)
   if((ast_id(parent) == TK_DOT) && (ast_child(parent) == ast))
   {
     ast_t* right = ast_sibling(ast);
     pony_assert(ast_id(right) == TK_ID);
     ast_t* find = lookup_try(opt, ast, nominal, ast_name(right));
     if(find!= NULL)
------------------------------------------------------------
bug injection: 
bool expr_this(pass_opt_t* opt, ast_t* ast)
   if((ast_id(find) == TK_DOT) && (ast_child(find) == ast))
   {
     ast_t* right = ast_sibling(ast);
     assert(ast_id(right) == TK_ID);
     ast_t* find = lookup_try(opt, ast, nominal, ast_name(right));
     if(find!= NULL)
------------------------------------------------------------
actual bug: 
 bool expr_this(pass_opt_t* opt, ast_t* ast)
   if((ast_id(parent) == TK_DOT) && (ast_child(parent) == ast))
   {
     ast_t* right = ast_sibling(ast);
     assert(ast_id(right) == TK_ID);
     ast_t* find = lookup_try(opt, ast, nominal, ast_name(right));
     if(find!= NULL)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
cast_to_string_resolve_descriptors(
                dtypes[1]->type_num == NPY_STRING);
         return NPY_UNSAFE_CASTING;
     }
     if (loop_descrs[1]->elsize >= size) {
         return NPY_SAFE_CASTING;
------------------------------------------------------------
bug injection: 
cast_to_string_descriptors(
            dtypes[1]->type_num == NPY_num == NPY_STRING);
         return NPY_SAFE_CASTING;
     }
     if (loop_descrs[1]->elsize == NPY_SAFE_CASTING;
     return NPY_CASTING;
------------------------------------------------------------
actual bug: 
 cast_to_string_resolve_descriptors(
                dtypes[1]->type_num == NPY_STRING);
         return NPY_UNSAFE_CASTING;
     }
     assert(self->casting == NPY_SAFE_CASTING);
     if (loop_descrs[1]->elsize >= size) {
         return NPY_SAFE_CASTING;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
mtflush_service_io(
 {
  wrk_t *work_item = NULL;
  ulint n_flushed=0;
  ib_time_t max_wait_usecs = 50000;
     mtflush_io->wt_status = WTHR_SIG_WAITING;
  work_item = (wrk_t *)ib_wqueue_timedwait(mtflush_io->wq, max_wait_usecs);
------------------------------------------------------------
bug injection: 
mtflush_service_service_io(
 {
  w_item = NULL;
  wrk_item = NULL;
  ulint n_flushed=5000000, max_wait_usecs = 50000;
     mtflush_io->wq_io->wq_timedwait_usecs = 50000;
------------------------------------------------------------
actual bug: 
 mtflush_service_io(
 {
  wrk_t *work_item = NULL;
  ulint n_flushed=0;
  ib_time_t max_wait_usecs = 5000000;
     mtflush_io->wt_status = WTHR_SIG_WAITING;
  work_item = (wrk_t *)ib_wqueue_timedwait(mtflush_io->wq, max_wait_usecs);
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
static int cmd_vcs_client_aics_input_description_get(const struct shell *sh,
  }
  result = bt_vcs_aics_description_get(default_conn, vcs.aics[index]);
  if (result!= 0) {
   shell_print(sh, "Fail: %d", result);
  }
------------------------------------------------------------
bug injection: 
static int cmd_vcs_client_aics_input_aics_get(const struct shell *sh,
  }
  result = bt_vcs_aics_description_get(default_conn, vcs.aics[index]);
  if (result) {
   shell_print(sh, "Fail: %d", result);
  }
------------------------------------------------------------
actual bug: 
 static int cmd_vcs_client_aics_input_description_get(const struct shell *sh,
  }
  result = bt_vcs_aics_description_get(default_conn, vcs.aics[index]);
  if (result) {
   shell_print(sh, "Fail: %d", result);
  }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
class ARROW_DS_EXPORT HivePartitionScheme : public PartitionScheme {
   std::string name() const override { return "hive_partition_scheme"; }
   Result<ExpressionPtr> Parse(const std::string& path) const override;
   std::vector<UnconvertedKey> GetUnconvertedKeys(const std::string& path) const;
------------------------------------------------------------
bug injection: 
class ARROW_DS_EXPORT HivePartitionScheme : public PartitionScheme {
   std::string name() const override { return "hive_partition_scheme"; }
   std::vector<Expression> Parse(const std::string& path) const override;
   std::vector<Expression>> Parse(const std::vector<const std::string& path) const override;
------------------------------------------------------------
actual bug: 
 class ARROW_DS_EXPORT HivePartitionScheme : public PartitionScheme {
   std::string name() const override { return "hive_partition_scheme"; }
   Result<std::shared_ptr<Expression>> Parse(const std::string& path) const override;
   std::vector<UnconvertedKey> GetUnconvertedKeys(const std::string& path) const;
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

source code: 
void rfc_send_ua (tRFC_MCB *p_mcb, UINT8 dlci)
     UINT8 *p_data;
     UINT8 cr = RFCOMM_CR(p_mcb->is_initiator, FALSE);
     if ((p_buf = (BT_HDR *)osi_malloc(RFCOMM_CMD_BUF_SIZE)) == NULL) {
         return;
     }
------------------------------------------------------------
bug injection: 
void rfc_send_ua (tRFC_MCB *p_mcb, UINT8 dlci)
     UINT8 *p_data;
     UINT8 cr = RFCOMM_CR(p_mcb->is_initiator, FALSE);
     if ((p_buf = (BT_HDR *)GKI_getpoolbuf (RFCOMM_CMD_POOL_ID)) == NULL) {
         return;
     }
------------------------------------------------------------
actual bug: 
 void rfc_send_ua (tRFC_MCB *p_mcb, UINT8 dlci)
     UINT8 *p_data;
     UINT8 cr = RFCOMM_CR(p_mcb->is_initiator, FALSE);
     if ((p_buf = (BT_HDR *)GKI_getpoolbuf (RFCOMM_CMD_POOL_ID)) == NULL) {
         return;
     }
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++